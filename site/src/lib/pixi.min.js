var PIXI = (function (exports) { 'use strict'; var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {}; function unwrapExports (x) { return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x.default : x } function createCommonjsModule (fn, module) { return fn(module = { exports: {} }, module.exports), module.exports } var promise = createCommonjsModule(function (module, exports) { !(function (global) { var NativePromise = global.Promise; var nativePromiseSupported = NativePromise && 'resolve' in NativePromise && 'reject' in NativePromise && 'all' in NativePromise && 'race' in NativePromise && (function () { var resolve; return new NativePromise(function (r) { resolve = r }), typeof resolve === 'function' }()); exports ? (exports.Promise = nativePromiseSupported ? NativePromise : Promise, exports.Polyfill = Promise) : nativePromiseSupported || (global.Promise = Promise); function NOOP () {} var PENDING = 'pending'; var SEALED = 'sealed'; var FULFILLED = 'fulfilled'; var REJECTED = 'rejected'; function isArray (value) { return Object.prototype.toString.call(value) === '[object Array]' } var asyncTimer; var asyncSetTimer = typeof setImmediate !== 'undefined' ? setImmediate : setTimeout; var asyncQueue = []; function asyncFlush () { for (var i = 0; i < asyncQueue.length; i++)asyncQueue[i][0](asyncQueue[i][1]); asyncTimer = !(asyncQueue = []) } function asyncCall (callback, arg) { asyncQueue.push([callback, arg]), asyncTimer || (asyncTimer = !0, asyncSetTimer(asyncFlush, 0)) } function invokeCallback (subscriber) { var owner = subscriber.owner; var settled = owner.state_; var value = owner.data_; var callback = subscriber[settled]; var promise = subscriber.then; if (typeof callback === 'function') { settled = FULFILLED; try { value = callback(value) } catch (e) { reject(promise, e) } }handleThenable(promise, value) || (settled === FULFILLED && resolve(promise, value), settled === REJECTED && reject(promise, value)) } function handleThenable (promise, value) { var resolved; try { if (promise === value) throw new TypeError('A promises callback cannot return that same promise.'); if (value && (typeof value === 'function' || typeof value === 'object')) { var then = value.then; if (typeof then === 'function') return then.call(value, function (val) { resolved || (resolved = !0, value !== val ? resolve(promise, val) : fulfill(promise, val)) }, function (reason) { resolved || (resolved = !0, reject(promise, reason)) }), !0 } } catch (e) { return resolved || reject(promise, e), !0 } return !1 } function resolve (promise, value) { promise !== value && handleThenable(promise, value) || fulfill(promise, value) } function fulfill (promise, value) { promise.state_ === PENDING && (promise.state_ = SEALED, promise.data_ = value, asyncCall(publishFulfillment, promise)) } function reject (promise, reason) { promise.state_ === PENDING && (promise.state_ = SEALED, promise.data_ = reason, asyncCall(publishRejection, promise)) } function publish (promise) { var callbacks = promise.then_; promise.then_ = void 0; for (var i = 0; i < callbacks.length; i++)invokeCallback(callbacks[i]) } function publishFulfillment (promise) { promise.state_ = FULFILLED, publish(promise) } function publishRejection (promise) { promise.state_ = REJECTED, publish(promise) } function Promise (resolver) { if (typeof resolver !== 'function') throw new TypeError('Promise constructor takes a function argument'); if (this instanceof Promise == !1) throw new TypeError("Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function."); this.then_ = [], (function (resolver, promise) { function rejectPromise (reason) { reject(promise, reason) } try { resolver(function (value) { resolve(promise, value) }, rejectPromise) } catch (e) { rejectPromise(e) } }(resolver, this)) }Promise.prototype = { constructor: Promise, state_: PENDING, then_: null, data_: void 0, then: function (onFulfillment, onRejection) { var subscriber = { owner: this, then: new this.constructor(NOOP), fulfilled: onFulfillment, rejected: onRejection }; return this.state_ === FULFILLED || this.state_ === REJECTED ? asyncCall(invokeCallback, subscriber) : this.then_.push(subscriber), subscriber.then }, catch: function (onRejection) { return this.then(null, onRejection) } }, Promise.all = function (promises) { if (!isArray(promises)) throw new TypeError('You must pass an array to Promise.all().'); return new this(function (resolve, reject) { var results = []; var remaining = 0; function resolver (index) { return remaining++, function (value) { results[index] = value, --remaining || resolve(results) } } for (var promise, i = 0; i < promises.length; i++)(promise = promises[i]) && typeof promise.then === 'function' ? promise.then(resolver(i), reject) : results[i] = promise; remaining || resolve(results) }) }, Promise.race = function (promises) { if (!isArray(promises)) throw new TypeError('You must pass an array to Promise.race().'); return new this(function (resolve, reject) { for (var promise, i = 0; i < promises.length; i++)(promise = promises[i]) && typeof promise.then === 'function' ? promise.then(resolve, reject) : resolve(promise) }) }, Promise.resolve = function (value) { return value && typeof value === 'object' && value.constructor === this ? value : new this(function (resolve) { resolve(value) }) }, Promise.reject = function (reason) { return new this(function (resolve, reject) { reject(reason) }) } }(typeof window !== 'undefined' ? window : void 0 !== commonjsGlobal ? commonjsGlobal : typeof self !== 'undefined' ? self : commonjsGlobal)) }); var promise_2 = (promise.Promise, promise.Polyfill); var getOwnPropertySymbols = Object.getOwnPropertySymbols; var hasOwnProperty = Object.prototype.hasOwnProperty; var propIsEnumerable = Object.prototype.propertyIsEnumerable; var objectAssign = (function () { try { if (!Object.assign) return !1; var test1 = new String('abc'); if (test1[5] = 'de', Object.getOwnPropertyNames(test1)[0] === '5') return !1; for (var test2 = {}, i = 0; i < 10; i++)test2['_' + String.fromCharCode(i)] = i; if (Object.getOwnPropertyNames(test2).map(function (n) { return test2[n] }).join('') !== '0123456789') return !1; var test3 = {}; return 'abcdefghijklmnopqrst'.split('').forEach(function (letter) { test3[letter] = letter }), Object.keys(Object.assign({}, test3)).join('') === 'abcdefghijklmnopqrst' } catch (err) { return !1 } }()) ? Object.assign : function (target, source) { for (var from, symbols, arguments$1 = arguments, to = (function (val) { if (val == null) throw new TypeError('Object.assign cannot be called with null or undefined'); return Object(val) }(target)), s = 1; s < arguments.length; s++) { for (var key in from = Object(arguments$1[s]))hasOwnProperty.call(from, key) && (to[key] = from[key]); if (getOwnPropertySymbols) { symbols = getOwnPropertySymbols(from); for (var i = 0; i < symbols.length; i++)propIsEnumerable.call(from, symbols[i]) && (to[symbols[i]] = from[symbols[i]]) } } return to }; window.Promise || (window.Promise = promise_2), Object.assign || (Object.assign = objectAssign); var commonjsGlobal$1 = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {}; if (Date.now && Date.prototype.getTime || (Date.now = function () { return (new Date()).getTime() }), !commonjsGlobal$1.performance || !commonjsGlobal$1.performance.now) { var startTime = Date.now(); commonjsGlobal$1.performance || (commonjsGlobal$1.performance = {}), commonjsGlobal$1.performance.now = function () { return Date.now() - startTime } } for (var lastTime = Date.now(), vendors = ['ms', 'moz', 'webkit', 'o'], x = 0; x < vendors.length && !commonjsGlobal$1.requestAnimationFrame; ++x) { var p = vendors[x]; commonjsGlobal$1.requestAnimationFrame = commonjsGlobal$1[p + 'RequestAnimationFrame'], commonjsGlobal$1.cancelAnimationFrame = commonjsGlobal$1[p + 'CancelAnimationFrame'] || commonjsGlobal$1[p + 'CancelRequestAnimationFrame'] }commonjsGlobal$1.requestAnimationFrame || (commonjsGlobal$1.requestAnimationFrame = function (callback) { if (typeof callback !== 'function') throw new TypeError(callback + 'is not a function'); var currentTime = Date.now(); var delay = 16 + lastTime - currentTime; return delay < 0 && (delay = 0), lastTime = currentTime, setTimeout(function () { lastTime = Date.now(), callback(performance.now()) }, delay) }), commonjsGlobal$1.cancelAnimationFrame || (commonjsGlobal$1.cancelAnimationFrame = function (id) { return clearTimeout(id) }), Math.sign || (Math.sign = function (x) { return (x = Number(x)) === 0 || isNaN(x) ? x : x > 0 ? 1 : -1 }), Number.isInteger || (Number.isInteger = function (value) { return typeof value === 'number' && isFinite(value) && Math.floor(value) === value }), window.ArrayBuffer || (window.ArrayBuffer = Array), window.Float32Array || (window.Float32Array = Array), window.Uint32Array || (window.Uint32Array = Array), window.Uint16Array || (window.Uint16Array = Array), window.Uint8Array || (window.Uint8Array = Array), window.Int32Array || (window.Int32Array = Array); var isMobile_min = createCommonjsModule(function (module) { function m (e, i) { return e.test(i) } function i (e) { var i = e || (typeof navigator !== 'undefined' ? navigator.userAgent : ''); var o = i.split('[FBAN'); void 0 !== o[1] && (i = o[0]), void 0 !== (o = i.split('Twitter'))[1] && (i = o[0]); var d = { apple: { phone: m(n, i) && !m(f, i), ipod: m(t, i), tablet: !m(n, i) && m(r, i) && !m(f, i), device: (m(n, i) || m(t, i) || m(r, i)) && !m(f, i) }, amazon: { phone: m(b, i), tablet: !m(b, i) && m(l, i), device: m(b, i) || m(l, i) }, android: { phone: !m(f, i) && m(b, i) || !m(f, i) && m(a, i), tablet: !m(f, i) && !m(b, i) && !m(a, i) && (m(l, i) || m(p, i)), device: !m(f, i) && (m(b, i) || m(l, i) || m(a, i) || m(p, i)) || m(/\bokhttp\b/i, i) }, windows: { phone: m(f, i), tablet: m(s, i), device: m(f, i) || m(s, i) }, other: { blackberry: m(u, i), blackberry10: m(c, i), opera: m(h, i), firefox: m(w, i), chrome: m(v, i), device: m(u, i) || m(c, i) || m(h, i) || m(w, i) || m(v, i) } }; return d.any = d.apple.device || d.android.device || d.windows.device || d.other.device, d.phone = d.apple.phone || d.android.phone || d.windows.phone, d.tablet = d.apple.tablet || d.android.tablet || d.windows.tablet, d } var e, n, t, r, a, p, b, l, f, s, u, c, h, v, w; e = commonjsGlobal, n = /iPhone/i, t = /iPod/i, r = /iPad/i, a = /\bAndroid(?:.+)Mobile\b/i, p = /Android/i, b = /\bAndroid(?:.+)SD4930UR\b/i, l = /\bAndroid(?:.+)(?:KF[A-Z]{2,4})\b/i, f = /Windows Phone/i, s = /\bWindows(?:.+)ARM\b/i, u = /BlackBerry/i, c = /BB10/i, h = /Opera Mini/i, v = /\b(CriOS|Chrome)(?:.+)Mobile/i, w = /Mobile(?:.+)Firefox\b/i, module.exports && typeof window === 'undefined' ? module.exports = i : module.exports && typeof window !== 'undefined' ? (module.exports = i(), module.exports.isMobile = i) : e.isMobile = i() }); isMobile_min.isMobile; var settings = { MIPMAP_TEXTURES: 1, RESOLUTION: 1, FILTER_RESOLUTION: 1, SPRITE_MAX_TEXTURES: (function (max) { var allowMax = !0; if (isMobile_min.tablet || isMobile_min.phone) { if (allowMax = !1, isMobile_min.apple.device) { var match = navigator.userAgent.match(/OS (\d+)_(\d+)?/); if (match)parseInt(match[1], 10) >= 11 && (allowMax = !0) } if (isMobile_min.android.device) { var match$1 = navigator.userAgent.match(/Android\s([0-9.]*)/); if (match$1)parseInt(match$1[1], 10) >= 7 && (allowMax = !0) } } return allowMax ? max : 4 }(32)), SPRITE_BATCH_SIZE: 4096, RENDER_OPTIONS: { view: null, antialias: !1, forceFXAA: !1, autoDensity: !1, transparent: !1, backgroundColor: 0, clearBeforeRender: !0, preserveDrawingBuffer: !1, width: 800, height: 600, legacy: !1 }, GC_MODE: 0, GC_MAX_IDLE: 3600, GC_MAX_CHECK_COUNT: 600, WRAP_MODE: 33071, SCALE_MODE: 1, PRECISION_VERTEX: 'highp', PRECISION_FRAGMENT: isMobile_min.apple.device ? 'highp' : 'mediump', CAN_UPLOAD_SAME_BUFFER: !isMobile_min.apple.device, CREATE_IMAGE_BITMAP: !1, ROUND_PIXELS: !1 }; var eventemitter3 = createCommonjsModule(function (module) { var has = Object.prototype.hasOwnProperty; var prefix = '~'; function Events () {} function EE (fn, context, once) { this.fn = fn, this.context = context, this.once = once || !1 } function addListener (emitter, event, fn, context, once) { if (typeof fn !== 'function') throw new TypeError('The listener must be a function'); var listener = new EE(fn, context || emitter, once); var evt = prefix ? prefix + event : event; return emitter._events[evt] ? emitter._events[evt].fn ? emitter._events[evt] = [emitter._events[evt], listener] : emitter._events[evt].push(listener) : (emitter._events[evt] = listener, emitter._eventsCount++), emitter } function clearEvent (emitter, evt) { --emitter._eventsCount == 0 ? emitter._events = new Events() : delete emitter._events[evt] } function EventEmitter () { this._events = new Events(), this._eventsCount = 0 }Object.create && (Events.prototype = Object.create(null), (new Events()).__proto__ || (prefix = !1)), EventEmitter.prototype.eventNames = function () { var events; var name; var names = []; if (this._eventsCount === 0) return names; for (name in events = this._events)has.call(events, name) && names.push(prefix ? name.slice(1) : name); return Object.getOwnPropertySymbols ? names.concat(Object.getOwnPropertySymbols(events)) : names }, EventEmitter.prototype.listeners = function (event) { var evt = prefix ? prefix + event : event; var handlers = this._events[evt]; if (!handlers) return []; if (handlers.fn) return [handlers.fn]; for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++)ee[i] = handlers[i].fn; return ee }, EventEmitter.prototype.listenerCount = function (event) { var evt = prefix ? prefix + event : event; var listeners = this._events[evt]; return listeners ? listeners.fn ? 1 : listeners.length : 0 }, EventEmitter.prototype.emit = function (event, a1, a2, a3, a4, a5) { var arguments$1 = arguments; var evt = prefix ? prefix + event : event; if (!this._events[evt]) return !1; var args; var i; var listeners = this._events[evt]; var len = arguments.length; if (listeners.fn) { switch (listeners.once && this.removeListener(event, listeners.fn, void 0, !0), len) { case 1:return listeners.fn.call(listeners.context), !0; case 2:return listeners.fn.call(listeners.context, a1), !0; case 3:return listeners.fn.call(listeners.context, a1, a2), !0; case 4:return listeners.fn.call(listeners.context, a1, a2, a3), !0; case 5:return listeners.fn.call(listeners.context, a1, a2, a3, a4), !0; case 6:return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), !0 } for (i = 1, args = new Array(len - 1); i < len; i++)args[i - 1] = arguments$1[i]; listeners.fn.apply(listeners.context, args) } else { var j; var length = listeners.length; for (i = 0; i < length; i++) switch (listeners[i].once && this.removeListener(event, listeners[i].fn, void 0, !0), len) { case 1:listeners[i].fn.call(listeners[i].context); break; case 2:listeners[i].fn.call(listeners[i].context, a1); break; case 3:listeners[i].fn.call(listeners[i].context, a1, a2); break; case 4:listeners[i].fn.call(listeners[i].context, a1, a2, a3); break; default:if (!args) for (j = 1, args = new Array(len - 1); j < len; j++)args[j - 1] = arguments$1[j]; listeners[i].fn.apply(listeners[i].context, args) } } return !0 }, EventEmitter.prototype.on = function (event, fn, context) { return addListener(this, event, fn, context, !1) }, EventEmitter.prototype.once = function (event, fn, context) { return addListener(this, event, fn, context, !0) }, EventEmitter.prototype.removeListener = function (event, fn, context, once) { var evt = prefix ? prefix + event : event; if (!this._events[evt]) return this; if (!fn) return clearEvent(this, evt), this; var listeners = this._events[evt]; if (listeners.fn)listeners.fn !== fn || once && !listeners.once || context && listeners.context !== context || clearEvent(this, evt); else { for (var i = 0, events = [], length = listeners.length; i < length; i++)(listeners[i].fn !== fn || once && !listeners[i].once || context && listeners[i].context !== context) && events.push(listeners[i]); events.length ? this._events[evt] = events.length === 1 ? events[0] : events : clearEvent(this, evt) } return this }, EventEmitter.prototype.removeAllListeners = function (event) { var evt; return event ? (evt = prefix ? prefix + event : event, this._events[evt] && clearEvent(this, evt)) : (this._events = new Events(), this._eventsCount = 0), this }, EventEmitter.prototype.off = EventEmitter.prototype.removeListener, EventEmitter.prototype.addListener = EventEmitter.prototype.on, EventEmitter.prefixed = prefix, EventEmitter.EventEmitter = EventEmitter, module.exports = EventEmitter }); var earcut_1 = earcut; var default_1 = earcut; function earcut (data, holeIndices, dim) { dim = dim || 2; var minX; var minY; var maxX; var maxY; var x; var y; var invSize; var hasHoles = holeIndices && holeIndices.length; var outerLen = hasHoles ? holeIndices[0] * dim : data.length; var outerNode = linkedList(data, 0, outerLen, dim, !0); var triangles = []; if (!outerNode || outerNode.next === outerNode.prev) return triangles; if (hasHoles && (outerNode = (function (data, holeIndices, outerNode, dim) { var i; var len; var start; var end; var list; var queue = []; for (i = 0, len = holeIndices.length; i < len; i++)start = holeIndices[i] * dim, end = i < len - 1 ? holeIndices[i + 1] * dim : data.length, (list = linkedList(data, start, end, dim, !1)) === list.next && (list.steiner = !0), queue.push(getLeftmost(list)); for (queue.sort(compareX), i = 0; i < queue.length; i++)eliminateHole(queue[i], outerNode), outerNode = filterPoints(outerNode, outerNode.next); return outerNode }(data, holeIndices, outerNode, dim))), data.length > 80 * dim) { minX = maxX = data[0], minY = maxY = data[1]; for (var i = dim; i < outerLen; i += dim)(x = data[i]) < minX && (minX = x), (y = data[i + 1]) < minY && (minY = y), maxX < x && (maxX = x), maxY < y && (maxY = y); invSize = (invSize = Math.max(maxX - minX, maxY - minY)) !== 0 ? 1 / invSize : 0 } return earcutLinked(outerNode, triangles, dim, minX, minY, invSize), triangles } function linkedList (data, start, end, dim, clockwise) { var i, last; if (clockwise === signedArea(data, start, end, dim) > 0) for (i = start; i < end; i += dim)last = insertNode(i, data[i], data[i + 1], last); else for (i = end - dim; start <= i; i -= dim)last = insertNode(i, data[i], data[i + 1], last); return last && equals(last, last.next) && (removeNode(last), last = last.next), last } function filterPoints (start, end) { if (!start) return start; end = end || start; var again; var p = start; do { if (again = !1, p.steiner || !equals(p, p.next) && area(p.prev, p, p.next) !== 0)p = p.next; else { if (removeNode(p), (p = end = p.prev) === p.next) break; again = !0 } } while (again || p !== end);return end } function earcutLinked (ear, triangles, dim, minX, minY, invSize, pass) { if (ear) { !pass && invSize && (function (start, minX, minY, invSize) { var p = start; for (;p.z === null && (p.z = zOrder(p.x, p.y, minX, minY, invSize)), p.prevZ = p.prev, p.nextZ = p.next, p = p.next, p !== start;);p.prevZ.nextZ = null, p.prevZ = null, (function (list) { var i; var p; var q; var e; var tail; var numMerges; var pSize; var qSize; var inSize = 1; do { for (p = list, tail = list = null, numMerges = 0; p;) { for (numMerges++, q = p, i = pSize = 0; i < inSize && (pSize++, q = q.nextZ); i++);for (qSize = inSize; pSize > 0 || qSize > 0 && q;)pSize !== 0 && (qSize === 0 || !q || p.z <= q.z) ? (p = (e = p).nextZ, pSize--) : (q = (e = q).nextZ, qSize--), tail ? tail.nextZ = e : list = e, e.prevZ = tail, tail = e; p = q }tail.nextZ = null, inSize *= 2 } while (numMerges > 1) }(p)) }(ear, minX, minY, invSize)); for (var prev, next, stop = ear; ear.prev !== ear.next;) if (prev = ear.prev, next = ear.next, invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear))triangles.push(prev.i / dim), triangles.push(ear.i / dim), triangles.push(next.i / dim), removeNode(ear), ear = next.next, stop = next.next; else if ((ear = next) === stop) { pass ? pass === 1 ? earcutLinked(ear = cureLocalIntersections(ear, triangles, dim), triangles, dim, minX, minY, invSize, 2) : pass === 2 && splitEarcut(ear, triangles, dim, minX, minY, invSize) : earcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1); break } } } function isEar (ear) { var a = ear.prev; var b = ear; var c = ear.next; if (area(a, b, c) >= 0) return !1; for (var p = ear.next.next; p !== ear.prev;) { if (pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && area(p.prev, p, p.next) >= 0) return !1; p = p.next } return !0 } function isEarHashed (ear, minX, minY, invSize) { var a = ear.prev; var b = ear; var c = ear.next; if (area(a, b, c) >= 0) return !1; for (var minTX = a.x < b.x ? a.x < c.x ? a.x : c.x : b.x < c.x ? b.x : c.x, minTY = a.y < b.y ? a.y < c.y ? a.y : c.y : b.y < c.y ? b.y : c.y, maxTX = a.x > b.x ? a.x > c.x ? a.x : c.x : b.x > c.x ? b.x : c.x, maxTY = a.y > b.y ? a.y > c.y ? a.y : c.y : b.y > c.y ? b.y : c.y, minZ = zOrder(minTX, minTY, minX, minY, invSize), maxZ = zOrder(maxTX, maxTY, minX, minY, invSize), p = ear.prevZ, n = ear.nextZ; p && p.z >= minZ && n && n.z <= maxZ;) { if (p !== ear.prev && p !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && area(p.prev, p, p.next) >= 0) return !1; if (p = p.prevZ, n !== ear.prev && n !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y) && area(n.prev, n, n.next) >= 0) return !1; n = n.nextZ } for (;p && p.z >= minZ;) { if (p !== ear.prev && p !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && area(p.prev, p, p.next) >= 0) return !1; p = p.prevZ } for (;n && n.z <= maxZ;) { if (n !== ear.prev && n !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y) && area(n.prev, n, n.next) >= 0) return !1; n = n.nextZ } return !0 } function cureLocalIntersections (start, triangles, dim) { var p = start; do { var a = p.prev; var b = p.next.next; !equals(a, b) && intersects(a, p, p.next, b) && locallyInside(a, b) && locallyInside(b, a) && (triangles.push(a.i / dim), triangles.push(p.i / dim), triangles.push(b.i / dim), removeNode(p), removeNode(p.next), p = start = b), p = p.next } while (p !== start);return p } function splitEarcut (start, triangles, dim, minX, minY, invSize) { var a = start; do { for (var b = a.next.next; b !== a.prev;) { if (a.i !== b.i && isValidDiagonal(a, b)) { var c = splitPolygon(a, b); return a = filterPoints(a, a.next), c = filterPoints(c, c.next), earcutLinked(a, triangles, dim, minX, minY, invSize), void earcutLinked(c, triangles, dim, minX, minY, invSize) }b = b.next }a = a.next } while (a !== start) } function compareX (a, b) { return a.x - b.x } function eliminateHole (hole, outerNode) { if (outerNode = (function (hole, outerNode) { var m; var p = outerNode; var hx = hole.x; var hy = hole.y; var qx = -1 / 0; do { if (hy <= p.y && hy >= p.next.y && p.next.y !== p.y) { var x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y); if (x <= hx && qx < x) { if ((qx = x) === hx) { if (hy === p.y) return p; if (hy === p.next.y) return p.next }m = p.x < p.next.x ? p : p.next } }p = p.next } while (p !== outerNode);if (!m) return null; if (hx === qx) return m.prev; var tan; var stop = m; var mx = m.x; var my = m.y; var tanMin = 1 / 0; p = m.next; for (;p !== stop;)hx >= p.x && p.x >= mx && hx !== p.x && pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y) && ((tan = Math.abs(hy - p.y) / (hx - p.x)) < tanMin || tan === tanMin && p.x > m.x) && locallyInside(p, hole) && (m = p, tanMin = tan), p = p.next; return m }(hole, outerNode))) { var b = splitPolygon(outerNode, hole); filterPoints(b, b.next) } } function zOrder (x, y, minX, minY, invSize) { return (x = 1431655765 & ((x = 858993459 & ((x = 252645135 & ((x = 16711935 & ((x = 32767 * (x - minX) * invSize) | x << 8)) | x << 4)) | x << 2)) | x << 1)) | (y = 1431655765 & ((y = 858993459 & ((y = 252645135 & ((y = 16711935 & ((y = 32767 * (y - minY) * invSize) | y << 8)) | y << 4)) | y << 2)) | y << 1)) << 1 } function getLeftmost (start) { for (var p = start, leftmost = start; (p.x < leftmost.x || p.x === leftmost.x && p.y < leftmost.y) && (leftmost = p), (p = p.next) !== start;);return leftmost } function pointInTriangle (ax, ay, bx, by, cx, cy, px, py) { return (cx - px) * (ay - py) - (ax - px) * (cy - py) >= 0 && (ax - px) * (by - py) - (bx - px) * (ay - py) >= 0 && (bx - px) * (cy - py) - (cx - px) * (by - py) >= 0 } function isValidDiagonal (a, b) { return a.next.i !== b.i && a.prev.i !== b.i && !(function (a, b) { var p = a; do { if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i && intersects(p, p.next, a, b)) return !0; p = p.next } while (p !== a);return !1 }(a, b)) && locallyInside(a, b) && locallyInside(b, a) && (function (a, b) { var p = a; var inside = !1; var px = (a.x + b.x) / 2; var py = (a.y + b.y) / 2; for (;p.y > py != p.next.y > py && p.next.y !== p.y && px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x && (inside = !inside), p = p.next, p !== a;);return inside }(a, b)) } function area (p, q, r) { return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y) } function equals (p1, p2) { return p1.x === p2.x && p1.y === p2.y } function intersects (p1, q1, p2, q2) { return !!(equals(p1, q1) && equals(p2, q2) || equals(p1, q2) && equals(p2, q1)) || area(p1, q1, p2) > 0 != area(p1, q1, q2) > 0 && area(p2, q2, p1) > 0 != area(p2, q2, q1) > 0 } function locallyInside (a, b) { return area(a.prev, a, a.next) < 0 ? area(a, b, a.next) >= 0 && area(a, a.prev, b) >= 0 : area(a, b, a.prev) < 0 || area(a, a.next, b) < 0 } function splitPolygon (a, b) { var a2 = new Node(a.i, a.x, a.y); var b2 = new Node(b.i, b.x, b.y); var an = a.next; var bp = b.prev; return (a.next = b).prev = a, (a2.next = an).prev = a2, (b2.next = a2).prev = b2, (bp.next = b2).prev = bp, b2 } function insertNode (i, x, y, last) { var p = new Node(i, x, y); return last ? (p.next = last.next, (p.prev = last).next.prev = p, last.next = p) : (p.prev = p).next = p, p } function removeNode (p) { p.next.prev = p.prev, p.prev.next = p.next, p.prevZ && (p.prevZ.nextZ = p.nextZ), p.nextZ && (p.nextZ.prevZ = p.prevZ) } function Node (i, x, y) { this.i = i, this.x = x, this.y = y, this.prev = null, this.next = null, this.z = null, this.prevZ = null, this.nextZ = null, this.steiner = !1 } function signedArea (data, start, end, dim) { for (var sum = 0, i = start, j = end - dim; i < end; i += dim)sum += (data[j] - data[i]) * (data[i + 1] + data[j + 1]), j = i; return sum }earcut.deviation = function (data, holeIndices, dim, triangles) { var hasHoles = holeIndices && holeIndices.length; var outerLen = hasHoles ? holeIndices[0] * dim : data.length; var polygonArea = Math.abs(signedArea(data, 0, outerLen, dim)); if (hasHoles) for (var i = 0, len = holeIndices.length; i < len; i++) { var start = holeIndices[i] * dim; var end = i < len - 1 ? holeIndices[i + 1] * dim : data.length; polygonArea -= Math.abs(signedArea(data, start, end, dim)) } var trianglesArea = 0; for (i = 0; i < triangles.length; i += 3) { var a = triangles[i] * dim; var b = triangles[i + 1] * dim; var c = triangles[i + 2] * dim; trianglesArea += Math.abs((data[a] - data[c]) * (data[1 + b] - data[1 + a]) - (data[a] - data[b]) * (data[1 + c] - data[1 + a])) } return polygonArea === 0 && trianglesArea === 0 ? 0 : Math.abs((trianglesArea - polygonArea) / polygonArea) }, earcut.flatten = function (data) { for (var dim = data[0][0].length, result = { vertices: [], holes: [], dimensions: dim }, holeIndex = 0, i = 0; i < data.length; i++) { for (var j = 0; j < data[i].length; j++) for (var d = 0; d < dim; d++)result.vertices.push(data[i][j][d]); i > 0 && (holeIndex += data[i - 1].length, result.holes.push(holeIndex)) } return result }, earcut_1.default = default_1; var punycode = createCommonjsModule(function (module, exports) { !(function (root) { var freeExports = exports && !exports.nodeType && exports; var freeModule = module && !module.nodeType && module; var freeGlobal = typeof commonjsGlobal === 'object' && commonjsGlobal; freeGlobal.global !== freeGlobal && freeGlobal.window !== freeGlobal && freeGlobal.self !== freeGlobal || (root = freeGlobal); var punycode; var key; var maxInt = 2147483647; var base = 36; var tMin = 1; var tMax = 26; var skew = 38; var damp = 700; var initialBias = 72; var initialN = 128; var delimiter = '-'; var regexPunycode = /^xn--/; var regexNonASCII = /[^\x20-\x7E]/; var regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g; var errors = { overflow: 'Overflow: input needs wider integers to process', 'not-basic': 'Illegal input >= 0x80 (not a basic code point)', 'invalid-input': 'Invalid input' }; var baseMinusTMin = base - tMin; var floor = Math.floor; var stringFromCharCode = String.fromCharCode; function error (type) { throw RangeError(errors[type]) } function map (array, fn) { for (var length = array.length, result = []; length--;)result[length] = fn(array[length]); return result } function mapDomain (string, fn) { var parts = string.split('@'); var result = ''; return parts.length > 1 && (result = parts[0] + '@', string = parts[1]), result + map((string = string.replace(regexSeparators, '.')).split('.'), fn).join('.') } function ucs2decode (string) { for (var value, extra, output = [], counter = 0, length = string.length; counter < length;)(value = string.charCodeAt(counter++)) >= 55296 && value <= 56319 && counter < length ? (64512 & (extra = string.charCodeAt(counter++))) == 56320 ? output.push(((1023 & value) << 10) + (1023 & extra) + 65536) : (output.push(value), counter--) : output.push(value); return output } function ucs2encode (array) { return map(array, function (value) { var output = ''; return value > 65535 && (output += stringFromCharCode((value -= 65536) >>> 10 & 1023 | 55296), value = 56320 | 1023 & value), output += stringFromCharCode(value) }).join('') } function digitToBasic (digit, flag) { return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5) } function adapt (delta, numPoints, firstTime) { var k = 0; for (delta = firstTime ? floor(delta / damp) : delta >> 1, delta += floor(delta / numPoints); baseMinusTMin * tMax >> 1 < delta; k += base)delta = floor(delta / baseMinusTMin); return floor(k + (baseMinusTMin + 1) * delta / (delta + skew)) } function decode (input) { var out; var basic; var j; var index; var oldi; var w; var k; var digit; var t; var baseMinusT; var codePoint; var output = []; var inputLength = input.length; var i = 0; var n = initialN; var bias = initialBias; for ((basic = input.lastIndexOf(delimiter)) < 0 && (basic = 0), j = 0; j < basic; ++j)input.charCodeAt(j) >= 128 && error('not-basic'), output.push(input.charCodeAt(j)); for (index = basic > 0 ? basic + 1 : 0; index < inputLength;) { for (oldi = i, w = 1, k = base; inputLength <= index && error('invalid-input'), codePoint = input.charCodeAt(index++), (base <= (digit = codePoint - 48 < 10 ? codePoint - 22 : codePoint - 65 < 26 ? codePoint - 65 : codePoint - 97 < 26 ? codePoint - 97 : base) || digit > floor((maxInt - i) / w)) && error('overflow'), i += digit * w, !(digit < (t = k <= bias ? tMin : bias + tMax <= k ? tMax : k - bias)); k += base)w > floor(maxInt / (baseMinusT = base - t)) && error('overflow'), w *= baseMinusT; bias = adapt(i - oldi, out = output.length + 1, oldi == 0), floor(i / out) > maxInt - n && error('overflow'), n += floor(i / out), i %= out, output.splice(i++, 0, n) } return ucs2encode(output) } function encode (input) { var n; var delta; var handledCPCount; var basicLength; var bias; var j; var m; var q; var k; var t; var currentValue; var inputLength; var handledCPCountPlusOne; var baseMinusT; var qMinusT; var output = []; for (inputLength = (input = ucs2decode(input)).length, n = initialN, bias = initialBias, j = delta = 0; j < inputLength; ++j)(currentValue = input[j]) < 128 && output.push(stringFromCharCode(currentValue)); for (handledCPCount = basicLength = output.length, basicLength && output.push(delimiter); handledCPCount < inputLength;) { for (m = maxInt, j = 0; j < inputLength; ++j)n <= (currentValue = input[j]) && currentValue < m && (m = currentValue); for (m - n > floor((maxInt - delta) / (handledCPCountPlusOne = handledCPCount + 1)) && error('overflow'), delta += (m - n) * handledCPCountPlusOne, n = m, j = 0; j < inputLength; ++j) if ((currentValue = input[j]) < n && ++delta > maxInt && error('overflow'), currentValue == n) { for (q = delta, k = base; !(q < (t = k <= bias ? tMin : bias + tMax <= k ? tMax : k - bias)); k += base)qMinusT = q - t, baseMinusT = base - t, output.push(stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))), q = floor(qMinusT / baseMinusT); output.push(stringFromCharCode(digitToBasic(q, 0))), bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength), delta = 0, ++handledCPCount }++delta, ++n } return output.join('') } if (punycode = { version: '1.3.2', ucs2: { decode: ucs2decode, encode: ucs2encode }, decode: decode, encode: encode, toASCII: function (input) { return mapDomain(input, function (string) { return regexNonASCII.test(string) ? 'xn--' + encode(string) : string }) }, toUnicode: function (input) { return mapDomain(input, function (string) { return regexPunycode.test(string) ? decode(string.slice(4).toLowerCase()) : string }) } }, freeExports && freeModule) if (module.exports == freeExports)freeModule.exports = punycode; else for (key in punycode)punycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]); else root.punycode = punycode }(commonjsGlobal)) }); var util = { isString: function (arg) { return typeof arg === 'string' }, isObject: function (arg) { return typeof arg === 'object' && arg !== null }, isNull: function (arg) { return arg === null }, isNullOrUndefined: function (arg) { return arg == null } }; util.isString, util.isObject, util.isNull, util.isNullOrUndefined; function hasOwnProperty$1 (obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop) } function decode (qs, sep, eq, options) { sep = sep || '&', eq = eq || '='; var obj = {}; if (typeof qs !== 'string' || qs.length === 0) return obj; var regexp = /\+/g; qs = qs.split(sep); var maxKeys = 1e3; options && typeof options.maxKeys === 'number' && (maxKeys = options.maxKeys); var len = qs.length; maxKeys > 0 && maxKeys < len && (len = maxKeys); for (var i = 0; i < len; ++i) { var kstr; var vstr; var k; var v; var x = qs[i].replace(regexp, '%20'); var idx = x.indexOf(eq); vstr = idx >= 0 ? (kstr = x.substr(0, idx), x.substr(idx + 1)) : (kstr = x, ''), k = decodeURIComponent(kstr), v = decodeURIComponent(vstr), hasOwnProperty$1(obj, k) ? Array.isArray(obj[k]) ? obj[k].push(v) : obj[k] = [obj[k], v] : obj[k] = v } return obj } function stringifyPrimitive (v) { switch (typeof v) { case 'string':return v; case 'boolean':return v ? 'true' : 'false'; case 'number':return isFinite(v) ? v : ''; default:return '' } } function encode (obj, sep, eq, name) { return sep = sep || '&', eq = eq || '=', obj === null && (obj = void 0), typeof obj === 'object' ? Object.keys(obj).map(function (k) { var ks = encodeURIComponent(stringifyPrimitive(k)) + eq; return Array.isArray(obj[k]) ? obj[k].map(function (v) { return ks + encodeURIComponent(stringifyPrimitive(v)) }).join(sep) : ks + encodeURIComponent(stringifyPrimitive(obj[k])) }).join(sep) : name ? encodeURIComponent(stringifyPrimitive(name)) + eq + encodeURIComponent(stringifyPrimitive(obj)) : '' } function resolve (source, relative) { return urlParse(source, !1, !0).resolve(relative) } function resolveObject (source, relative) { return source ? urlParse(source, !1, !0).resolveObject(relative) : relative } function format (obj) { return util.isString(obj) && (obj = urlParse(obj)), obj instanceof Url ? obj.format() : Url.prototype.format.call(obj) } var querystring = createCommonjsModule(function (module, exports) { exports.decode = exports.parse = decode, exports.encode = exports.stringify = encode }); var parse = (querystring.decode, querystring.parse, querystring.encode, querystring.stringify, urlParse); var Url_1 = Url; function Url () { this.protocol = null, this.slashes = null, this.auth = null, this.host = null, this.port = null, this.hostname = null, this.hash = null, this.search = null, this.query = null, this.pathname = null, this.path = null, this.href = null } var protocolPattern = /^([a-z0-9.+-]+:)/i; var portPattern = /:[0-9]*$/; var simplePathPattern = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/; var unwise = ['{', '}', '|', '\\', '^', '`'].concat(['<', '>', '"', '`', ' ', '\r', '\n', '\t']); var autoEscape = ["'"].concat(unwise); var nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape); var hostEndingChars = ['/', '?', '#']; var hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/; var hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/; var unsafeProtocol = { javascript: !0, 'javascript:': !0 }; var hostlessProtocol = { javascript: !0, 'javascript:': !0 }; var slashedProtocol = { http: !0, https: !0, ftp: !0, gopher: !0, file: !0, 'http:': !0, 'https:': !0, 'ftp:': !0, 'gopher:': !0, 'file:': !0 }; function urlParse (url, parseQueryString, slashesDenoteHost) { if (url && util.isObject(url) && url instanceof Url) return url; var u = new Url(); return u.parse(url, parseQueryString, slashesDenoteHost), u }Url.prototype.parse = function (url, parseQueryString, slashesDenoteHost) { if (!util.isString(url)) throw new TypeError("Parameter 'url' must be a string, not " + typeof url); var queryIndex = url.indexOf('?'); var splitter = queryIndex !== -1 && queryIndex < url.indexOf('#') ? '?' : '#'; var uSplit = url.split(splitter); uSplit[0] = uSplit[0].replace(/\\/g, '/'); var rest = url = uSplit.join(splitter); if (rest = rest.trim(), !slashesDenoteHost && url.split('#').length === 1) { var simplePath = simplePathPattern.exec(rest); if (simplePath) return this.path = rest, this.href = rest, this.pathname = simplePath[1], simplePath[2] ? (this.search = simplePath[2], this.query = parseQueryString ? querystring.parse(this.search.substr(1)) : this.search.substr(1)) : parseQueryString && (this.search = '', this.query = {}), this } var proto = protocolPattern.exec(rest); if (proto) { var lowerProto = (proto = proto[0]).toLowerCase(); this.protocol = lowerProto, rest = rest.substr(proto.length) } if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) { var slashes = rest.substr(0, 2) === '//'; !slashes || proto && hostlessProtocol[proto] || (rest = rest.substr(2), this.slashes = !0) } if (!hostlessProtocol[proto] && (slashes || proto && !slashedProtocol[proto])) { for (var auth, atSign, hostEnd = -1, i = 0; i < hostEndingChars.length; i++) { (hec = rest.indexOf(hostEndingChars[i])) !== -1 && (hostEnd === -1 || hec < hostEnd) && (hostEnd = hec) }(atSign = hostEnd === -1 ? rest.lastIndexOf('@') : rest.lastIndexOf('@', hostEnd)) !== -1 && (auth = rest.slice(0, atSign), rest = rest.slice(atSign + 1), this.auth = decodeURIComponent(auth)), hostEnd = -1; for (i = 0; i < nonHostChars.length; i++) { var hec; (hec = rest.indexOf(nonHostChars[i])) !== -1 && (hostEnd === -1 || hec < hostEnd) && (hostEnd = hec) }hostEnd === -1 && (hostEnd = rest.length), this.host = rest.slice(0, hostEnd), rest = rest.slice(hostEnd), this.parseHost(), this.hostname = this.hostname || ''; var ipv6Hostname = this.hostname[0] === '[' && this.hostname[this.hostname.length - 1] === ']'; if (!ipv6Hostname) for (var hostparts = this.hostname.split(/\./), l = (i = 0, hostparts.length); i < l; i++) { var part = hostparts[i]; if (part && !part.match(hostnamePartPattern)) { for (var newpart = '', j = 0, k = part.length; j < k; j++)part.charCodeAt(j) > 127 ? newpart += 'x' : newpart += part[j]; if (!newpart.match(hostnamePartPattern)) { var validParts = hostparts.slice(0, i); var notHost = hostparts.slice(i + 1); var bit = part.match(hostnamePartStart); bit && (validParts.push(bit[1]), notHost.unshift(bit[2])), notHost.length && (rest = '/' + notHost.join('.') + rest), this.hostname = validParts.join('.'); break } } } this.hostname.length > 255 ? this.hostname = '' : this.hostname = this.hostname.toLowerCase(), ipv6Hostname || (this.hostname = punycode.toASCII(this.hostname)); var p = this.port ? ':' + this.port : ''; var h = this.hostname || ''; this.host = h + p, this.href += this.host, ipv6Hostname && (this.hostname = this.hostname.substr(1, this.hostname.length - 2), rest[0] !== '/' && (rest = '/' + rest)) } if (!unsafeProtocol[lowerProto]) for (i = 0, l = autoEscape.length; i < l; i++) { var ae = autoEscape[i]; if (rest.indexOf(ae) !== -1) { var esc = encodeURIComponent(ae); esc === ae && (esc = escape(ae)), rest = rest.split(ae).join(esc) } } var hash = rest.indexOf('#'); hash !== -1 && (this.hash = rest.substr(hash), rest = rest.slice(0, hash)); var qm = rest.indexOf('?'); if (qm !== -1 ? (this.search = rest.substr(qm), this.query = rest.substr(qm + 1), parseQueryString && (this.query = querystring.parse(this.query)), rest = rest.slice(0, qm)) : parseQueryString && (this.search = '', this.query = {}), rest && (this.pathname = rest), slashedProtocol[lowerProto] && this.hostname && !this.pathname && (this.pathname = '/'), this.pathname || this.search) { p = this.pathname || ''; var s = this.search || ''; this.path = p + s } return this.href = this.format(), this }, Url.prototype.format = function () { var auth = this.auth || ''; auth && (auth = (auth = encodeURIComponent(auth)).replace(/%3A/i, ':'), auth += '@'); var protocol = this.protocol || ''; var pathname = this.pathname || ''; var hash = this.hash || ''; var host = !1; var query = ''; this.host ? host = auth + this.host : this.hostname && (host = auth + (this.hostname.indexOf(':') === -1 ? this.hostname : '[' + this.hostname + ']'), this.port && (host += ':' + this.port)), this.query && util.isObject(this.query) && Object.keys(this.query).length && (query = querystring.stringify(this.query)); var search = this.search || query && '?' + query || ''; return protocol && protocol.substr(-1) !== ':' && (protocol += ':'), this.slashes || (!protocol || slashedProtocol[protocol]) && !1 !== host ? (host = '//' + (host || ''), pathname && pathname.charAt(0) !== '/' && (pathname = '/' + pathname)) : host = host || '', hash && hash.charAt(0) !== '#' && (hash = '#' + hash), search && search.charAt(0) !== '?' && (search = '?' + search), protocol + host + (pathname = pathname.replace(/[?#]/g, function (match) { return encodeURIComponent(match) })) + (search = search.replace('#', '%23')) + hash }, Url.prototype.resolve = function (relative) { return this.resolveObject(urlParse(relative, !1, !0)).format() }, Url.prototype.resolveObject = function (relative) { if (util.isString(relative)) { var rel = new Url(); rel.parse(relative, !1, !0), relative = rel } for (var result = new Url(), tkeys = Object.keys(this), tk = 0; tk < tkeys.length; tk++) { var tkey = tkeys[tk]; result[tkey] = this[tkey] } if (result.hash = relative.hash, relative.href === '') return result.href = result.format(), result; if (relative.slashes && !relative.protocol) { for (var rkeys = Object.keys(relative), rk = 0; rk < rkeys.length; rk++) { var rkey = rkeys[rk]; rkey !== 'protocol' && (result[rkey] = relative[rkey]) } return slashedProtocol[result.protocol] && result.hostname && !result.pathname && (result.path = result.pathname = '/'), result.href = result.format(), result } if (relative.protocol && relative.protocol !== result.protocol) { if (!slashedProtocol[relative.protocol]) { for (var keys = Object.keys(relative), v = 0; v < keys.length; v++) { var k = keys[v]; result[k] = relative[k] } return result.href = result.format(), result } if (result.protocol = relative.protocol, relative.host || hostlessProtocol[relative.protocol])result.pathname = relative.pathname; else { for (var relPath = (relative.pathname || '').split('/'); relPath.length && !(relative.host = relPath.shift()););relative.host || (relative.host = ''), relative.hostname || (relative.hostname = ''), relPath[0] !== '' && relPath.unshift(''), relPath.length < 2 && relPath.unshift(''), result.pathname = relPath.join('/') } if (result.search = relative.search, result.query = relative.query, result.host = relative.host || '', result.auth = relative.auth, result.hostname = relative.hostname || relative.host, result.port = relative.port, result.pathname || result.search) { var p = result.pathname || ''; var s = result.search || ''; result.path = p + s } return result.slashes = result.slashes || relative.slashes, result.href = result.format(), result } var isSourceAbs = result.pathname && result.pathname.charAt(0) === '/'; var isRelAbs = relative.host || relative.pathname && relative.pathname.charAt(0) === '/'; var mustEndAbs = isRelAbs || isSourceAbs || result.host && relative.pathname; var removeAllDots = mustEndAbs; var srcPath = result.pathname && result.pathname.split('/') || []; var psychotic = (relPath = relative.pathname && relative.pathname.split('/') || [], result.protocol && !slashedProtocol[result.protocol]); if (psychotic && (result.hostname = '', result.port = null, result.host && (srcPath[0] === '' ? srcPath[0] = result.host : srcPath.unshift(result.host)), result.host = '', relative.protocol && (relative.hostname = null, relative.port = null, relative.host && (relPath[0] === '' ? relPath[0] = relative.host : relPath.unshift(relative.host)), relative.host = null), mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '')), isRelAbs)result.host = relative.host || relative.host === '' ? relative.host : result.host, result.hostname = relative.hostname || relative.hostname === '' ? relative.hostname : result.hostname, result.search = relative.search, result.query = relative.query, srcPath = relPath; else if (relPath.length)(srcPath = srcPath || []).pop(), srcPath = srcPath.concat(relPath), result.search = relative.search, result.query = relative.query; else if (!util.isNullOrUndefined(relative.search)) { if (psychotic)result.hostname = result.host = srcPath.shift(), (authInHost = !!(result.host && result.host.indexOf('@') > 0) && result.host.split('@')) && (result.auth = authInHost.shift(), result.host = result.hostname = authInHost.shift()); return result.search = relative.search, result.query = relative.query, util.isNull(result.pathname) && util.isNull(result.search) || (result.path = (result.pathname ? result.pathname : '') + (result.search ? result.search : '')), result.href = result.format(), result } if (!srcPath.length) return result.pathname = null, result.search ? result.path = '/' + result.search : result.path = null, result.href = result.format(), result; for (var last = srcPath.slice(-1)[0], hasTrailingSlash = (result.host || relative.host || srcPath.length > 1) && (last === '.' || last === '..') || last === '', up = 0, i = srcPath.length; i >= 0; i--)(last = srcPath[i]) === '.' ? srcPath.splice(i, 1) : last === '..' ? (srcPath.splice(i, 1), up++) : up && (srcPath.splice(i, 1), up--); if (!mustEndAbs && !removeAllDots) for (;up--;)srcPath.unshift('..'); !mustEndAbs || srcPath[0] === '' || srcPath[0] && srcPath[0].charAt(0) === '/' || srcPath.unshift(''), hasTrailingSlash && srcPath.join('/').substr(-1) !== '/' && srcPath.push(''); var authInHost; var isAbsolute = srcPath[0] === '' || srcPath[0] && srcPath[0].charAt(0) === '/'; psychotic && (result.hostname = result.host = isAbsolute ? '' : srcPath.length ? srcPath.shift() : '', (authInHost = !!(result.host && result.host.indexOf('@') > 0) && result.host.split('@')) && (result.auth = authInHost.shift(), result.host = result.hostname = authInHost.shift())); return (mustEndAbs = mustEndAbs || result.host && srcPath.length) && !isAbsolute && srcPath.unshift(''), srcPath.length ? result.pathname = srcPath.join('/') : (result.pathname = null, result.path = null), util.isNull(result.pathname) && util.isNull(result.search) || (result.path = (result.pathname ? result.pathname : '') + (result.search ? result.search : '')), result.auth = relative.auth || result.auth, result.slashes = result.slashes || relative.slashes, result.href = result.format(), result }, Url.prototype.parseHost = function () { var host = this.host; var port = portPattern.exec(host); port && ((port = port[0]) !== ':' && (this.port = port.substr(1)), host = host.substr(0, host.length - port.length)), host && (this.hostname = host) }; var supported; var url = { parse: parse, resolve: resolve, resolveObject: resolveObject, format: format, Url: Url_1 }; var ENV = { WEBGL_LEGACY: 0, WEBGL: 1, WEBGL2: 2 }; var RENDERER_TYPE = { UNKNOWN: 0, WEBGL: 1, CANVAS: 2 }; var BLEND_MODES = { NORMAL: 0, ADD: 1, MULTIPLY: 2, SCREEN: 3, OVERLAY: 4, DARKEN: 5, LIGHTEN: 6, COLOR_DODGE: 7, COLOR_BURN: 8, HARD_LIGHT: 9, SOFT_LIGHT: 10, DIFFERENCE: 11, EXCLUSION: 12, HUE: 13, SATURATION: 14, COLOR: 15, LUMINOSITY: 16, NORMAL_NPM: 17, ADD_NPM: 18, SCREEN_NPM: 19, NONE: 20, SRC_OVER: 0, SRC_IN: 21, SRC_OUT: 22, SRC_ATOP: 23, DST_OVER: 24, DST_IN: 25, DST_OUT: 26, DST_ATOP: 27, ERASE: 26, SUBTRACT: 28 }; var DRAW_MODES = { POINTS: 0, LINES: 1, LINE_LOOP: 2, LINE_STRIP: 3, TRIANGLES: 4, TRIANGLE_STRIP: 5, TRIANGLE_FAN: 6 }; var FORMATS = { RGBA: 6408, RGB: 6407, ALPHA: 6406, LUMINANCE: 6409, LUMINANCE_ALPHA: 6410, DEPTH_COMPONENT: 6402, DEPTH_STENCIL: 34041 }; var TARGETS = { TEXTURE_2D: 3553, TEXTURE_CUBE_MAP: 34067, TEXTURE_2D_ARRAY: 35866, TEXTURE_CUBE_MAP_POSITIVE_X: 34069, TEXTURE_CUBE_MAP_NEGATIVE_X: 34070, TEXTURE_CUBE_MAP_POSITIVE_Y: 34071, TEXTURE_CUBE_MAP_NEGATIVE_Y: 34072, TEXTURE_CUBE_MAP_POSITIVE_Z: 34073, TEXTURE_CUBE_MAP_NEGATIVE_Z: 34074 }; var TYPES = { UNSIGNED_BYTE: 5121, UNSIGNED_SHORT: 5123, UNSIGNED_SHORT_5_6_5: 33635, UNSIGNED_SHORT_4_4_4_4: 32819, UNSIGNED_SHORT_5_5_5_1: 32820, FLOAT: 5126, HALF_FLOAT: 36193 }; var SCALE_MODES = { LINEAR: 1, NEAREST: 0 }; var WRAP_MODES = { CLAMP: 33071, REPEAT: 10497, MIRRORED_REPEAT: 33648 }; var MIPMAP_MODES = { OFF: 0, POW2: 1, ON: 2 }; var GC_MODES = { AUTO: 0, MANUAL: 1 }; var PRECISION = { LOW: 'lowp', MEDIUM: 'mediump', HIGH: 'highp' }; var saidHello = !(settings.RETINA_PREFIX = /@([0-9\.]+)x/); var VERSION = '5.0.4'; function sayHello (type) { if (!saidHello) { if (navigator.userAgent.toLowerCase().indexOf('chrome') > -1) { var args = ['\n %c %c %c PixiJS ' + VERSION + ' - ✰ ' + type + ' ✰  %c  %c  http://www.pixijs.com/  %c %c ♥%c♥%c♥ \n\n', 'background: #ff66a5; padding:5px 0;', 'background: #ff66a5; padding:5px 0;', 'color: #ff66a5; background: #030307; padding:5px 0;', 'background: #ff66a5; padding:5px 0;', 'background: #ffc3dc; padding:5px 0;', 'background: #ff66a5; padding:5px 0;', 'color: #ff2424; background: #fff; padding:5px 0;', 'color: #ff2424; background: #fff; padding:5px 0;', 'color: #ff2424; background: #fff; padding:5px 0;']; window.console.log.apply(console, args) } else window.console && window.console.log('PixiJS ' + VERSION + ' - ' + type + ' - http://www.pixijs.com/'); saidHello = !0 } } function isWebGLSupported () { return void 0 === supported && (supported = (function () { var contextOptions = { stencil: !0, failIfMajorPerformanceCaveat: !0 }; try { if (!window.WebGLRenderingContext) return !1; var canvas = document.createElement('canvas'); var gl = canvas.getContext('webgl', contextOptions) || canvas.getContext('experimental-webgl', contextOptions); var success = !(!gl || !gl.getContextAttributes().stencil); if (gl) { var loseContext = gl.getExtension('WEBGL_lose_context'); loseContext && loseContext.loseContext() } return gl = null, success } catch (e) { return !1 } }())), supported } function hex2rgb (hex, out) { return (out = out || [])[0] = (hex >> 16 & 255) / 255, out[1] = (hex >> 8 & 255) / 255, out[2] = (255 & hex) / 255, out } function hex2string (hex) { return hex = hex.toString(16), '#' + (hex = '000000'.substr(0, 6 - hex.length) + hex) } function string2hex (string) { return typeof string === 'string' && string[0] === '#' && (string = string.substr(1)), parseInt(string, 16) } var premultiplyBlendMode = (function () { for (var pm = [], npm = [], i = 0; i < 32; i++)npm[pm[i] = i] = i; pm[BLEND_MODES.NORMAL_NPM] = BLEND_MODES.NORMAL, pm[BLEND_MODES.ADD_NPM] = BLEND_MODES.ADD, pm[BLEND_MODES.SCREEN_NPM] = BLEND_MODES.SCREEN, npm[BLEND_MODES.NORMAL] = BLEND_MODES.NORMAL_NPM, npm[BLEND_MODES.ADD] = BLEND_MODES.ADD_NPM, npm[BLEND_MODES.SCREEN] = BLEND_MODES.SCREEN_NPM; var array = []; return array.push(npm), array.push(pm), array }()); function correctBlendMode (blendMode, premultiplied) { return premultiplyBlendMode[premultiplied ? 1 : 0][blendMode] } function premultiplyRgba (rgb, alpha, out, premultiply) { return out = out || new Float32Array(4), premultiply || void 0 === premultiply ? (out[0] = rgb[0] * alpha, out[1] = rgb[1] * alpha, out[2] = rgb[2] * alpha) : (out[0] = rgb[0], out[1] = rgb[1], out[2] = rgb[2]), out[3] = alpha, out } function premultiplyTint (tint, alpha) { if (alpha === 1) return (255 * alpha << 24) + tint; if (alpha === 0) return 0; var R = tint >> 16 & 255; var G = tint >> 8 & 255; var B = 255 & tint; return (255 * alpha << 24) + ((R = R * alpha + 0.5 | 0) << 16) + ((G = G * alpha + 0.5 | 0) << 8) + (B = B * alpha + 0.5 | 0) } function premultiplyTintToRgba (tint, alpha, out, premultiply) { return (out = out || new Float32Array(4))[0] = (tint >> 16 & 255) / 255, out[1] = (tint >> 8 & 255) / 255, out[2] = (255 & tint) / 255, !premultiply && void 0 !== premultiply || (out[0] *= alpha, out[1] *= alpha, out[2] *= alpha), out[3] = alpha, out } function createIndicesForQuads (size) { for (var totalIndices = 6 * size, indices = new Uint16Array(totalIndices), i = 0, j = 0; i < totalIndices; i += 6, j += 4)indices[i + 0] = j + 0, indices[i + 1] = j + 1, indices[i + 2] = j + 2, indices[i + 3] = j + 0, indices[i + 4] = j + 2, indices[i + 5] = j + 3; return indices } function removeItems (arr, startIdx, removeCount) { var i; var length = arr.length; if (!(length <= startIdx || removeCount === 0)) { var len = length - (removeCount = length < startIdx + removeCount ? length - startIdx : removeCount); for (i = startIdx; i < len; ++i)arr[i] = arr[i + removeCount]; arr.length = len } } var nextUid = 0; function uid () { return ++nextUid } function sign (n) { return n === 0 ? 0 : n < 0 ? -1 : 1 } function nextPow2 (v) { return v += v === 0, --v, v |= v >>> 1, v |= v >>> 2, v |= v >>> 4, v |= v >>> 8, (v |= v >>> 16) + 1 } function isPow2 (v) { return !(v & v - 1 || !v) } function log2 (v) { var r = (v > 65535) << 4; var shift = ((v >>>= r) > 255) << 3; return r |= shift, r |= shift = ((v >>>= shift) > 15) << 2, (r |= shift = ((v >>>= shift) > 3) << 1) | (v >>>= shift) >> 1 } var ProgramCache = {}; var TextureCache = Object.create(null); var BaseTextureCache = Object.create(null); function trimCanvas (canvas) { var i; var x; var y; var width = canvas.width; var height = canvas.height; var context = canvas.getContext('2d'); var pixels = context.getImageData(0, 0, width, height).data; var len = pixels.length; var bound = { top: null, left: null, right: null, bottom: null }; var data = null; for (i = 0; i < len; i += 4)pixels[i + 3] !== 0 && (x = i / 4 % width, y = ~~(i / 4 / width), bound.top === null && (bound.top = y), bound.left === null ? bound.left = x : x < bound.left && (bound.left = x), bound.right === null ? bound.right = 1 + x : bound.right < x && (bound.right = 1 + x), bound.bottom === null ? bound.bottom = y : bound.bottom < y && (bound.bottom = y)); return bound.top !== null && (width = bound.right - bound.left, height = bound.bottom - bound.top + 1, data = context.getImageData(bound.left, bound.top, width, height)), { height: height, width: width, data: data } } var CanvasRenderTarget = function (width, height, resolution) { this.canvas = document.createElement('canvas'), this.context = this.canvas.getContext('2d'), this.resolution = resolution || settings.RESOLUTION, this.resize(width, height) }; var prototypeAccessors = { width: { configurable: !0 }, height: { configurable: !0 } }; CanvasRenderTarget.prototype.clear = function () { this.context.setTransform(1, 0, 0, 1, 0, 0), this.context.clearRect(0, 0, this.canvas.width, this.canvas.height) }, CanvasRenderTarget.prototype.resize = function (width, height) { this.canvas.width = width * this.resolution, this.canvas.height = height * this.resolution }, CanvasRenderTarget.prototype.destroy = function () { this.context = null, this.canvas = null }, prototypeAccessors.width.get = function () { return this.canvas.width }, prototypeAccessors.width.set = function (val) { this.canvas.width = val }, prototypeAccessors.height.get = function () { return this.canvas.height }, prototypeAccessors.height.set = function (val) { this.canvas.height = val }, Object.defineProperties(CanvasRenderTarget.prototype, prototypeAccessors); var tempAnchor; var DATA_URI = /^\s*data:(?:([\w-]+)\/([\w+.-]+))?(?:;charset=([\w-]+))?(?:;(base64))?,(.*)/i; function determineCrossOrigin (url$1, loc) { if (void 0 === loc && (loc = window.location), url$1.indexOf('data:') === 0) return ''; loc = loc || window.location, (tempAnchor = tempAnchor || document.createElement('a')).href = url$1; var samePort = !(url$1 = url.parse(tempAnchor.href)).port && loc.port === '' || url$1.port === loc.port; return url$1.hostname === loc.hostname && samePort && url$1.protocol === loc.protocol ? '' : 'anonymous' } function getResolutionOfUrl (url, defaultValue) { var resolution = settings.RETINA_PREFIX.exec(url); return resolution ? parseFloat(resolution[1]) : void 0 !== defaultValue ? defaultValue : 1 } var warnings = {}; function deprecation (version, message, ignoreDepth) { if (void 0 === ignoreDepth && (ignoreDepth = 3), !warnings[message]) { var stack = (new Error()).stack; void 0 === stack ? console.warn('PixiJS Deprecation Warning: ', message + '\nDeprecated since v' + version) : (stack = stack.split('\n').splice(ignoreDepth).join('\n'), console.groupCollapsed ? (console.groupCollapsed('%cPixiJS Deprecation Warning: %c%s', 'color:#614108;background:#fffbe6', 'font-weight:normal;color:#614108;background:#fffbe6', message + '\nDeprecated since v' + version), console.warn(stack), console.groupEnd()) : (console.warn('PixiJS Deprecation Warning: ', message + '\nDeprecated since v' + version), console.warn(stack))), warnings[message] = !0 } } var utils_es = { BaseTextureCache: BaseTextureCache, CanvasRenderTarget: CanvasRenderTarget, DATA_URI: DATA_URI, ProgramCache: ProgramCache, TextureCache: TextureCache, clearTextureCache: function () { var key; for (key in TextureCache) delete TextureCache[key]; for (key in BaseTextureCache) delete BaseTextureCache[key] }, correctBlendMode: correctBlendMode, createIndicesForQuads: createIndicesForQuads, decomposeDataUri: function (dataUri) { var dataUriMatch = DATA_URI.exec(dataUri); if (dataUriMatch) return { mediaType: dataUriMatch[1] ? dataUriMatch[1].toLowerCase() : void 0, subType: dataUriMatch[2] ? dataUriMatch[2].toLowerCase() : void 0, charset: dataUriMatch[3] ? dataUriMatch[3].toLowerCase() : void 0, encoding: dataUriMatch[4] ? dataUriMatch[4].toLowerCase() : void 0, data: dataUriMatch[5] } }, deprecation: deprecation, destroyTextureCache: function () { var key; for (key in TextureCache)TextureCache[key].destroy(); for (key in BaseTextureCache)BaseTextureCache[key].destroy() }, determineCrossOrigin: determineCrossOrigin, getResolutionOfUrl: getResolutionOfUrl, hex2rgb: hex2rgb, hex2string: hex2string, isPow2: isPow2, isWebGLSupported: isWebGLSupported, log2: log2, nextPow2: nextPow2, premultiplyBlendMode: premultiplyBlendMode, premultiplyRgba: premultiplyRgba, premultiplyTint: premultiplyTint, premultiplyTintToRgba: premultiplyTintToRgba, removeItems: removeItems, rgb2hex: function (rgb) { return (255 * rgb[0] << 16) + (255 * rgb[1] << 8) + (255 * rgb[2] | 0) }, sayHello: sayHello, sign: sign, skipHello: function () { saidHello = !0 }, string2hex: string2hex, trimCanvas: trimCanvas, uid: uid, isMobile: isMobile_min, EventEmitter: eventemitter3, earcut: earcut_1, url: url }; var Point = function (x, y) { void 0 === x && (x = 0), void 0 === y && (y = 0), this.x = x, this.y = y }; Point.prototype.clone = function () { return new Point(this.x, this.y) }, Point.prototype.copyFrom = function (p) { return this.set(p.x, p.y), this }, Point.prototype.copyTo = function (p) { return p.set(this.x, this.y), p }, Point.prototype.equals = function (p) { return p.x === this.x && p.y === this.y }, Point.prototype.set = function (x, y) { this.x = x || 0, this.y = y || (y !== 0 ? this.x : 0) }; var ObservablePoint = function (cb, scope, x, y) { void 0 === x && (x = 0), void 0 === y && (y = 0), this._x = x, this._y = y, this.cb = cb, this.scope = scope }; var prototypeAccessors$1 = { x: { configurable: !0 }, y: { configurable: !0 } }; ObservablePoint.prototype.clone = function (cb, scope) { void 0 === cb && (cb = null), void 0 === scope && (scope = null); var _cb = cb || this.cb; var _scope = scope || this.scope; return new ObservablePoint(_cb, _scope, this._x, this._y) }, ObservablePoint.prototype.set = function (x, y) { var _x = x || 0; var _y = y || (y !== 0 ? _x : 0); this._x === _x && this._y === _y || (this._x = _x, this._y = _y, this.cb.call(this.scope)) }, ObservablePoint.prototype.copyFrom = function (p) { return this._x === p.x && this._y === p.y || (this._x = p.x, this._y = p.y, this.cb.call(this.scope)), this }, ObservablePoint.prototype.copyTo = function (p) { return p.set(this._x, this._y), p }, ObservablePoint.prototype.equals = function (p) { return p.x === this._x && p.y === this._y }, prototypeAccessors$1.x.get = function () { return this._x }, prototypeAccessors$1.x.set = function (value) { this._x !== value && (this._x = value, this.cb.call(this.scope)) }, prototypeAccessors$1.y.get = function () { return this._y }, prototypeAccessors$1.y.set = function (value) { this._y !== value && (this._y = value, this.cb.call(this.scope)) }, Object.defineProperties(ObservablePoint.prototype, prototypeAccessors$1); var PI_2 = 2 * Math.PI; var RAD_TO_DEG = 180 / Math.PI; var DEG_TO_RAD = Math.PI / 180; var SHAPES = { POLY: 0, RECT: 1, CIRC: 2, ELIP: 3, RREC: 4 }; var Matrix = function (a, b, c, d, tx, ty) { void 0 === a && (a = 1), void 0 === b && (b = 0), void 0 === c && (c = 0), void 0 === d && (d = 1), void 0 === tx && (tx = 0), void 0 === ty && (ty = 0), this.a = a, this.b = b, this.c = c, this.d = d, this.tx = tx, this.ty = ty, this.array = null }; var staticAccessors = { IDENTITY: { configurable: !0 }, TEMP_MATRIX: { configurable: !0 } }; Matrix.prototype.fromArray = function (array) { this.a = array[0], this.b = array[1], this.c = array[3], this.d = array[4], this.tx = array[2], this.ty = array[5] }, Matrix.prototype.set = function (a, b, c, d, tx, ty) { return this.a = a, this.b = b, this.c = c, this.d = d, this.tx = tx, this.ty = ty, this }, Matrix.prototype.toArray = function (transpose, out) { this.array || (this.array = new Float32Array(9)); var array = out || this.array; return transpose ? (array[0] = this.a, array[1] = this.b, array[2] = 0, array[3] = this.c, array[4] = this.d, array[5] = 0, array[6] = this.tx, array[7] = this.ty) : (array[0] = this.a, array[1] = this.c, array[2] = this.tx, array[3] = this.b, array[4] = this.d, array[5] = this.ty, array[6] = 0, array[7] = 0), array[8] = 1, array }, Matrix.prototype.apply = function (pos, newPos) { newPos = newPos || new Point(); var x = pos.x; var y = pos.y; return newPos.x = this.a * x + this.c * y + this.tx, newPos.y = this.b * x + this.d * y + this.ty, newPos }, Matrix.prototype.applyInverse = function (pos, newPos) { newPos = newPos || new Point(); var id = 1 / (this.a * this.d + this.c * -this.b); var x = pos.x; var y = pos.y; return newPos.x = this.d * id * x + -this.c * id * y + (this.ty * this.c - this.tx * this.d) * id, newPos.y = this.a * id * y + -this.b * id * x + (-this.ty * this.a + this.tx * this.b) * id, newPos }, Matrix.prototype.translate = function (x, y) { return this.tx += x, this.ty += y, this }, Matrix.prototype.scale = function (x, y) { return this.a *= x, this.d *= y, this.c *= x, this.b *= y, this.tx *= x, this.ty *= y, this }, Matrix.prototype.rotate = function (angle) { var cos = Math.cos(angle); var sin = Math.sin(angle); var a1 = this.a; var c1 = this.c; var tx1 = this.tx; return this.a = a1 * cos - this.b * sin, this.b = a1 * sin + this.b * cos, this.c = c1 * cos - this.d * sin, this.d = c1 * sin + this.d * cos, this.tx = tx1 * cos - this.ty * sin, this.ty = tx1 * sin + this.ty * cos, this }, Matrix.prototype.append = function (matrix) { var a1 = this.a; var b1 = this.b; var c1 = this.c; var d1 = this.d; return this.a = matrix.a * a1 + matrix.b * c1, this.b = matrix.a * b1 + matrix.b * d1, this.c = matrix.c * a1 + matrix.d * c1, this.d = matrix.c * b1 + matrix.d * d1, this.tx = matrix.tx * a1 + matrix.ty * c1 + this.tx, this.ty = matrix.tx * b1 + matrix.ty * d1 + this.ty, this }, Matrix.prototype.setTransform = function (x, y, pivotX, pivotY, scaleX, scaleY, rotation, skewX, skewY) { return this.a = Math.cos(rotation + skewY) * scaleX, this.b = Math.sin(rotation + skewY) * scaleX, this.c = -Math.sin(rotation - skewX) * scaleY, this.d = Math.cos(rotation - skewX) * scaleY, this.tx = x - (pivotX * this.a + pivotY * this.c), this.ty = y - (pivotX * this.b + pivotY * this.d), this }, Matrix.prototype.prepend = function (matrix) { var tx1 = this.tx; if (matrix.a !== 1 || matrix.b !== 0 || matrix.c !== 0 || matrix.d !== 1) { var a1 = this.a; var c1 = this.c; this.a = a1 * matrix.a + this.b * matrix.c, this.b = a1 * matrix.b + this.b * matrix.d, this.c = c1 * matrix.a + this.d * matrix.c, this.d = c1 * matrix.b + this.d * matrix.d } return this.tx = tx1 * matrix.a + this.ty * matrix.c + matrix.tx, this.ty = tx1 * matrix.b + this.ty * matrix.d + matrix.ty, this }, Matrix.prototype.decompose = function (transform) { var a = this.a; var b = this.b; var c = this.c; var d = this.d; var skewX = -Math.atan2(-c, d); var skewY = Math.atan2(b, a); var delta = Math.abs(skewX + skewY); return delta < 1e-5 || Math.abs(PI_2 - delta) < 1e-5 ? (transform.rotation = skewY, transform.skew.x = transform.skew.y = 0) : (transform.rotation = 0, transform.skew.x = skewX, transform.skew.y = skewY), transform.scale.x = Math.sqrt(a * a + b * b), transform.scale.y = Math.sqrt(c * c + d * d), transform.position.x = this.tx, transform.position.y = this.ty, transform }, Matrix.prototype.invert = function () { var a1 = this.a; var b1 = this.b; var c1 = this.c; var d1 = this.d; var tx1 = this.tx; var n = a1 * d1 - b1 * c1; return this.a = d1 / n, this.b = -b1 / n, this.c = -c1 / n, this.d = a1 / n, this.tx = (c1 * this.ty - d1 * tx1) / n, this.ty = -(a1 * this.ty - b1 * tx1) / n, this }, Matrix.prototype.identity = function () { return this.a = 1, this.b = 0, this.c = 0, this.d = 1, this.tx = 0, this.ty = 0, this }, Matrix.prototype.clone = function () { var matrix = new Matrix(); return matrix.a = this.a, matrix.b = this.b, matrix.c = this.c, matrix.d = this.d, matrix.tx = this.tx, matrix.ty = this.ty, matrix }, Matrix.prototype.copyTo = function (matrix) { return matrix.a = this.a, matrix.b = this.b, matrix.c = this.c, matrix.d = this.d, matrix.tx = this.tx, matrix.ty = this.ty, matrix }, Matrix.prototype.copyFrom = function (matrix) { return this.a = matrix.a, this.b = matrix.b, this.c = matrix.c, this.d = matrix.d, this.tx = matrix.tx, this.ty = matrix.ty, this }, staticAccessors.IDENTITY.get = function () { return new Matrix() }, staticAccessors.TEMP_MATRIX.get = function () { return new Matrix() }, Object.defineProperties(Matrix, staticAccessors); var ux = [1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1, 0, 1]; var uy = [0, 1, 1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1]; var vx = [0, -1, -1, -1, 0, 1, 1, 1, 0, 1, 1, 1, 0, -1, -1, -1]; var vy = [1, 1, 0, -1, -1, -1, 0, 1, -1, -1, 0, 1, 1, 1, 0, -1]; var tempMatrices = []; var mul = []; function signum (x) { return x < 0 ? -1 : x > 0 ? 1 : 0 }!(function () { for (var i = 0; i < 16; i++) { var row = []; mul.push(row); for (var j = 0; j < 16; j++) for (var _ux = signum(ux[i] * ux[j] + vx[i] * uy[j]), _uy = signum(uy[i] * ux[j] + vy[i] * uy[j]), _vx = signum(ux[i] * vx[j] + vx[i] * vy[j]), _vy = signum(uy[i] * vx[j] + vy[i] * vy[j]), k = 0; k < 16; k++) if (ux[k] === _ux && uy[k] === _uy && vx[k] === _vx && vy[k] === _vy) { row.push(k); break } } for (var i$1 = 0; i$1 < 16; i$1++) { var mat = new Matrix(); mat.set(ux[i$1], uy[i$1], vx[i$1], vy[i$1], 0, 0), tempMatrices.push(mat) } }()); var GroupD8 = { E: 0, SE: 1, S: 2, SW: 3, W: 4, NW: 5, N: 6, NE: 7, MIRROR_VERTICAL: 8, MIRROR_HORIZONTAL: 12, uX: function (ind) { return ux[ind] }, uY: function (ind) { return uy[ind] }, vX: function (ind) { return vx[ind] }, vY: function (ind) { return vy[ind] }, inv: function (rotation) { return 8 & rotation ? 15 & rotation : 7 & -rotation }, add: function (rotationSecond, rotationFirst) { return mul[rotationSecond][rotationFirst] }, sub: function (rotationSecond, rotationFirst) { return mul[rotationSecond][GroupD8.inv(rotationFirst)] }, rotate180: function (rotation) { return 4 ^ rotation }, isVertical: function (rotation) { return (3 & rotation) == 2 }, byDirection: function (dx, dy) { return 2 * Math.abs(dx) <= Math.abs(dy) ? dy >= 0 ? GroupD8.S : GroupD8.N : 2 * Math.abs(dy) <= Math.abs(dx) ? dx > 0 ? GroupD8.E : GroupD8.W : dy > 0 ? dx > 0 ? GroupD8.SE : GroupD8.SW : dx > 0 ? GroupD8.NE : GroupD8.NW }, matrixAppendRotationInv: function (matrix, rotation, tx, ty) { void 0 === tx && (tx = 0), void 0 === ty && (ty = 0); var mat = tempMatrices[GroupD8.inv(rotation)]; mat.tx = tx, mat.ty = ty, matrix.append(mat) } }; var Transform = function () { this.worldTransform = new Matrix(), this.localTransform = new Matrix(), this.position = new ObservablePoint(this.onChange, this, 0, 0), this.scale = new ObservablePoint(this.onChange, this, 1, 1), this.pivot = new ObservablePoint(this.onChange, this, 0, 0), this.skew = new ObservablePoint(this.updateSkew, this, 0, 0), this._rotation = 0, this._cx = 1, this._sx = 0, this._cy = 0, this._sy = 1, this._localID = 0, this._currentLocalID = 0, this._worldID = 0, this._parentID = 0 }; var prototypeAccessors$1$1 = { rotation: { configurable: !0 } }; Transform.prototype.onChange = function () { this._localID++ }, Transform.prototype.updateSkew = function () { this._cx = Math.cos(this._rotation + this.skew._y), this._sx = Math.sin(this._rotation + this.skew._y), this._cy = -Math.sin(this._rotation - this.skew._x), this._sy = Math.cos(this._rotation - this.skew._x), this._localID++ }, Transform.prototype.updateLocalTransform = function () { var lt = this.localTransform; this._localID !== this._currentLocalID && (lt.a = this._cx * this.scale._x, lt.b = this._sx * this.scale._x, lt.c = this._cy * this.scale._y, lt.d = this._sy * this.scale._y, lt.tx = this.position._x - (this.pivot._x * lt.a + this.pivot._y * lt.c), lt.ty = this.position._y - (this.pivot._x * lt.b + this.pivot._y * lt.d), this._currentLocalID = this._localID, this._parentID = -1) }, Transform.prototype.updateTransform = function (parentTransform) { var lt = this.localTransform; if (this._localID !== this._currentLocalID && (lt.a = this._cx * this.scale._x, lt.b = this._sx * this.scale._x, lt.c = this._cy * this.scale._y, lt.d = this._sy * this.scale._y, lt.tx = this.position._x - (this.pivot._x * lt.a + this.pivot._y * lt.c), lt.ty = this.position._y - (this.pivot._x * lt.b + this.pivot._y * lt.d), this._currentLocalID = this._localID, this._parentID = -1), this._parentID !== parentTransform._worldID) { var pt = parentTransform.worldTransform; var wt = this.worldTransform; wt.a = lt.a * pt.a + lt.b * pt.c, wt.b = lt.a * pt.b + lt.b * pt.d, wt.c = lt.c * pt.a + lt.d * pt.c, wt.d = lt.c * pt.b + lt.d * pt.d, wt.tx = lt.tx * pt.a + lt.ty * pt.c + pt.tx, wt.ty = lt.tx * pt.b + lt.ty * pt.d + pt.ty, this._parentID = parentTransform._worldID, this._worldID++ } }, Transform.prototype.setFromMatrix = function (matrix) { matrix.decompose(this), this._localID++ }, prototypeAccessors$1$1.rotation.get = function () { return this._rotation }, prototypeAccessors$1$1.rotation.set = function (value) { this._rotation !== value && (this._rotation = value, this.updateSkew()) }, Object.defineProperties(Transform.prototype, prototypeAccessors$1$1), Transform.IDENTITY = new Transform(); var Rectangle = function (x, y, width, height) { void 0 === x && (x = 0), void 0 === y && (y = 0), void 0 === width && (width = 0), void 0 === height && (height = 0), this.x = Number(x), this.y = Number(y), this.width = Number(width), this.height = Number(height), this.type = SHAPES.RECT }; var prototypeAccessors$2 = { left: { configurable: !0 }, right: { configurable: !0 }, top: { configurable: !0 }, bottom: { configurable: !0 } }; var staticAccessors$1 = { EMPTY: { configurable: !0 } }; prototypeAccessors$2.left.get = function () { return this.x }, prototypeAccessors$2.right.get = function () { return this.x + this.width }, prototypeAccessors$2.top.get = function () { return this.y }, prototypeAccessors$2.bottom.get = function () { return this.y + this.height }, staticAccessors$1.EMPTY.get = function () { return new Rectangle(0, 0, 0, 0) }, Rectangle.prototype.clone = function () { return new Rectangle(this.x, this.y, this.width, this.height) }, Rectangle.prototype.copyFrom = function (rectangle) { return this.x = rectangle.x, this.y = rectangle.y, this.width = rectangle.width, this.height = rectangle.height, this }, Rectangle.prototype.copyTo = function (rectangle) { return rectangle.x = this.x, rectangle.y = this.y, rectangle.width = this.width, rectangle.height = this.height, rectangle }, Rectangle.prototype.contains = function (x, y) { return !(this.width <= 0 || this.height <= 0) && (x >= this.x && x < this.x + this.width && y >= this.y && y < this.y + this.height) }, Rectangle.prototype.pad = function (paddingX, paddingY) { paddingX = paddingX || 0, paddingY = paddingY || (paddingY !== 0 ? paddingX : 0), this.x -= paddingX, this.y -= paddingY, this.width += 2 * paddingX, this.height += 2 * paddingY }, Rectangle.prototype.fit = function (rectangle) { var x1 = Math.max(this.x, rectangle.x); var x2 = Math.min(this.x + this.width, rectangle.x + rectangle.width); var y1 = Math.max(this.y, rectangle.y); var y2 = Math.min(this.y + this.height, rectangle.y + rectangle.height); this.x = x1, this.width = Math.max(x2 - x1, 0), this.y = y1, this.height = Math.max(y2 - y1, 0) }, Rectangle.prototype.ceil = function (resolution, eps) { void 0 === resolution && (resolution = 1), void 0 === eps && (eps = 0.001); var x2 = Math.ceil((this.x + this.width - eps) * resolution) / resolution; var y2 = Math.ceil((this.y + this.height - eps) * resolution) / resolution; this.x = Math.floor((this.x + eps) * resolution) / resolution, this.y = Math.floor((this.y + eps) * resolution) / resolution, this.width = x2 - this.x, this.height = y2 - this.y }, Rectangle.prototype.enlarge = function (rectangle) { var x1 = Math.min(this.x, rectangle.x); var x2 = Math.max(this.x + this.width, rectangle.x + rectangle.width); var y1 = Math.min(this.y, rectangle.y); var y2 = Math.max(this.y + this.height, rectangle.y + rectangle.height); this.x = x1, this.width = x2 - x1, this.y = y1, this.height = y2 - y1 }, Object.defineProperties(Rectangle.prototype, prototypeAccessors$2), Object.defineProperties(Rectangle, staticAccessors$1); var Circle = function (x, y, radius) { void 0 === x && (x = 0), void 0 === y && (y = 0), void 0 === radius && (radius = 0), this.x = x, this.y = y, this.radius = radius, this.type = SHAPES.CIRC }; Circle.prototype.clone = function () { return new Circle(this.x, this.y, this.radius) }, Circle.prototype.contains = function (x, y) { if (this.radius <= 0) return !1; var r2 = this.radius * this.radius; var dx = this.x - x; var dy = this.y - y; return (dx *= dx) + (dy *= dy) <= r2 }, Circle.prototype.getBounds = function () { return new Rectangle(this.x - this.radius, this.y - this.radius, 2 * this.radius, 2 * this.radius) }; var Ellipse = function (x, y, halfWidth, halfHeight) { void 0 === x && (x = 0), void 0 === y && (y = 0), void 0 === halfWidth && (halfWidth = 0), void 0 === halfHeight && (halfHeight = 0), this.x = x, this.y = y, this.width = halfWidth, this.height = halfHeight, this.type = SHAPES.ELIP }; Ellipse.prototype.clone = function () { return new Ellipse(this.x, this.y, this.width, this.height) }, Ellipse.prototype.contains = function (x, y) { if (this.width <= 0 || this.height <= 0) return !1; var normx = (x - this.x) / this.width; var normy = (y - this.y) / this.height; return (normx *= normx) + (normy *= normy) <= 1 }, Ellipse.prototype.getBounds = function () { return new Rectangle(this.x - this.width, this.y - this.height, this.width, this.height) }; var Polygon = function () { for (var arguments$1 = arguments, points = [], len = arguments.length; len--;)points[len] = arguments$1[len]; if (Array.isArray(points[0]) && (points = points[0]), points[0] instanceof Point) { for (var p = [], i = 0, il = points.length; i < il; i++)p.push(points[i].x, points[i].y); points = p } this.points = points, this.type = SHAPES.POLY, this.closeStroke = !0 }; Polygon.prototype.clone = function () { var polygon = new Polygon(this.points.slice()); return polygon.closeStroke = this.closeStroke, polygon }, Polygon.prototype.contains = function (x, y) { for (var inside = !1, length = this.points.length / 2, i = 0, j = length - 1; i < length; j = i++) { var xi = this.points[2 * i]; var yi = this.points[2 * i + 1]; var xj = this.points[2 * j]; var yj = this.points[2 * j + 1]; y < yi != y < yj && x < (y - yi) / (yj - yi) * (xj - xi) + xi && (inside = !inside) } return inside }; var RoundedRectangle = function (x, y, width, height, radius) { void 0 === x && (x = 0), void 0 === y && (y = 0), void 0 === width && (width = 0), void 0 === height && (height = 0), void 0 === radius && (radius = 20), this.x = x, this.y = y, this.width = width, this.height = height, this.radius = radius, this.type = SHAPES.RREC }; RoundedRectangle.prototype.clone = function () { return new RoundedRectangle(this.x, this.y, this.width, this.height, this.radius) }, RoundedRectangle.prototype.contains = function (x, y) { if (this.width <= 0 || this.height <= 0) return !1; if (x >= this.x && x <= this.x + this.width && y >= this.y && y <= this.y + this.height) { if (y >= this.y + this.radius && y <= this.y + this.height - this.radius || x >= this.x + this.radius && x <= this.x + this.width - this.radius) return !0; var dx = x - (this.x + this.radius); var dy = y - (this.y + this.radius); var radius2 = this.radius * this.radius; if (dx * dx + dy * dy <= radius2) return !0; if ((dx = x - (this.x + this.width - this.radius)) * dx + dy * dy <= radius2) return !0; if (dx * dx + (dy = y - (this.y + this.height - this.radius)) * dy <= radius2) return !0; if ((dx = x - (this.x + this.radius)) * dx + dy * dy <= radius2) return !0 } return !1 }, settings.SORTABLE_CHILDREN = !1; var Bounds = function () { this.minX = 1 / 0, this.minY = 1 / 0, this.maxX = -1 / 0, this.maxY = -1 / 0, this.rect = null }; Bounds.prototype.isEmpty = function () { return this.minX > this.maxX || this.minY > this.maxY }, Bounds.prototype.clear = function () { this.updateID++, this.minX = 1 / 0, this.minY = 1 / 0, this.maxX = -1 / 0, this.maxY = -1 / 0 }, Bounds.prototype.getRectangle = function (rect) { return this.minX > this.maxX || this.minY > this.maxY ? Rectangle.EMPTY : ((rect = rect || new Rectangle(0, 0, 1, 1)).x = this.minX, rect.y = this.minY, rect.width = this.maxX - this.minX, rect.height = this.maxY - this.minY, rect) }, Bounds.prototype.addPoint = function (point) { this.minX = Math.min(this.minX, point.x), this.maxX = Math.max(this.maxX, point.x), this.minY = Math.min(this.minY, point.y), this.maxY = Math.max(this.maxY, point.y) }, Bounds.prototype.addQuad = function (vertices) { var minX = this.minX; var minY = this.minY; var maxX = this.maxX; var maxY = this.maxY; var x = vertices[0]; var y = vertices[1]; minX = x < minX ? x : minX, minY = y < minY ? y : minY, maxX = maxX < x ? x : maxX, maxY = maxY < y ? y : maxY, minX = (x = vertices[2]) < minX ? x : minX, minY = (y = vertices[3]) < minY ? y : minY, maxX = maxX < x ? x : maxX, maxY = maxY < y ? y : maxY, minX = (x = vertices[4]) < minX ? x : minX, minY = (y = vertices[5]) < minY ? y : minY, maxX = maxX < x ? x : maxX, maxY = maxY < y ? y : maxY, minX = (x = vertices[6]) < minX ? x : minX, minY = (y = vertices[7]) < minY ? y : minY, maxX = maxX < x ? x : maxX, maxY = maxY < y ? y : maxY, this.minX = minX, this.minY = minY, this.maxX = maxX, this.maxY = maxY }, Bounds.prototype.addFrame = function (transform, x0, y0, x1, y1) { var matrix = transform.worldTransform; var a = matrix.a; var b = matrix.b; var c = matrix.c; var d = matrix.d; var tx = matrix.tx; var ty = matrix.ty; var minX = this.minX; var minY = this.minY; var maxX = this.maxX; var maxY = this.maxY; var x = a * x0 + c * y0 + tx; var y = b * x0 + d * y0 + ty; minX = x < minX ? x : minX, minY = y < minY ? y : minY, maxX = maxX < x ? x : maxX, maxY = maxY < y ? y : maxY, minX = (x = a * x1 + c * y0 + tx) < minX ? x : minX, minY = (y = b * x1 + d * y0 + ty) < minY ? y : minY, maxX = maxX < x ? x : maxX, maxY = maxY < y ? y : maxY, minX = (x = a * x0 + c * y1 + tx) < minX ? x : minX, minY = (y = b * x0 + d * y1 + ty) < minY ? y : minY, maxX = maxX < x ? x : maxX, maxY = maxY < y ? y : maxY, minX = (x = a * x1 + c * y1 + tx) < minX ? x : minX, minY = (y = b * x1 + d * y1 + ty) < minY ? y : minY, maxX = maxX < x ? x : maxX, maxY = maxY < y ? y : maxY, this.minX = minX, this.minY = minY, this.maxX = maxX, this.maxY = maxY }, Bounds.prototype.addVertexData = function (vertexData, beginOffset, endOffset) { for (var minX = this.minX, minY = this.minY, maxX = this.maxX, maxY = this.maxY, i = beginOffset; i < endOffset; i += 2) { var x = vertexData[i]; var y = vertexData[i + 1]; minX = x < minX ? x : minX, minY = y < minY ? y : minY, maxX = maxX < x ? x : maxX, maxY = maxY < y ? y : maxY } this.minX = minX, this.minY = minY, this.maxX = maxX, this.maxY = maxY }, Bounds.prototype.addVertices = function (transform, vertices, beginOffset, endOffset) { for (var matrix = transform.worldTransform, a = matrix.a, b = matrix.b, c = matrix.c, d = matrix.d, tx = matrix.tx, ty = matrix.ty, minX = this.minX, minY = this.minY, maxX = this.maxX, maxY = this.maxY, i = beginOffset; i < endOffset; i += 2) { var rawX = vertices[i]; var rawY = vertices[i + 1]; var x = a * rawX + c * rawY + tx; var y = d * rawY + b * rawX + ty; minX = x < minX ? x : minX, minY = y < minY ? y : minY, maxX = maxX < x ? x : maxX, maxY = maxY < y ? y : maxY } this.minX = minX, this.minY = minY, this.maxX = maxX, this.maxY = maxY }, Bounds.prototype.addBounds = function (bounds) { var minX = this.minX; var minY = this.minY; var maxX = this.maxX; var maxY = this.maxY; this.minX = bounds.minX < minX ? bounds.minX : minX, this.minY = bounds.minY < minY ? bounds.minY : minY, this.maxX = bounds.maxX > maxX ? bounds.maxX : maxX, this.maxY = bounds.maxY > maxY ? bounds.maxY : maxY }, Bounds.prototype.addBoundsMask = function (bounds, mask) { var _minX = bounds.minX > mask.minX ? bounds.minX : mask.minX; var _minY = bounds.minY > mask.minY ? bounds.minY : mask.minY; var _maxX = bounds.maxX < mask.maxX ? bounds.maxX : mask.maxX; var _maxY = bounds.maxY < mask.maxY ? bounds.maxY : mask.maxY; if (_minX <= _maxX && _minY <= _maxY) { var minX = this.minX; var minY = this.minY; var maxX = this.maxX; var maxY = this.maxY; this.minX = _minX < minX ? _minX : minX, this.minY = _minY < minY ? _minY : minY, this.maxX = maxX < _maxX ? _maxX : maxX, this.maxY = maxY < _maxY ? _maxY : maxY } }, Bounds.prototype.addBoundsArea = function (bounds, area) { var _minX = bounds.minX > area.x ? bounds.minX : area.x; var _minY = bounds.minY > area.y ? bounds.minY : area.y; var _maxX = bounds.maxX < area.x + area.width ? bounds.maxX : area.x + area.width; var _maxY = bounds.maxY < area.y + area.height ? bounds.maxY : area.y + area.height; if (_minX <= _maxX && _minY <= _maxY) { var minX = this.minX; var minY = this.minY; var maxX = this.maxX; var maxY = this.maxY; this.minX = _minX < minX ? _minX : minX, this.minY = _minY < minY ? _minY : minY, this.maxX = maxX < _maxX ? _maxX : maxX, this.maxY = maxY < _maxY ? _maxY : maxY } }; var DisplayObject = (function (EventEmitter) { function DisplayObject () { EventEmitter.call(this), this.tempDisplayObjectParent = null, this.transform = new Transform(), this.alpha = 1, this.visible = !0, this.renderable = !0, this.parent = null, this.worldAlpha = 1, this._lastSortedIndex = 0, this._zIndex = 0, this.filterArea = null, this.filters = null, this._enabledFilters = null, this._bounds = new Bounds(), this._boundsID = 0, this._lastBoundsID = -1, this._boundsRect = null, this._localBoundsRect = null, this._mask = null, this._destroyed = !1, this.isSprite = !1 }EventEmitter && (DisplayObject.__proto__ = EventEmitter); var prototypeAccessors = { _tempDisplayObjectParent: { configurable: !0 }, x: { configurable: !0 }, y: { configurable: !0 }, worldTransform: { configurable: !0 }, localTransform: { configurable: !0 }, position: { configurable: !0 }, scale: { configurable: !0 }, pivot: { configurable: !0 }, skew: { configurable: !0 }, rotation: { configurable: !0 }, angle: { configurable: !0 }, zIndex: { configurable: !0 }, worldVisible: { configurable: !0 }, mask: { configurable: !0 } }; return ((DisplayObject.prototype = Object.create(EventEmitter && EventEmitter.prototype)).constructor = DisplayObject).mixin = function (source) { for (var keys = Object.keys(source), i = 0; i < keys.length; ++i) { var propertyName = keys[i]; Object.defineProperty(DisplayObject.prototype, propertyName, Object.getOwnPropertyDescriptor(source, propertyName)) } }, prototypeAccessors._tempDisplayObjectParent.get = function () { return this.tempDisplayObjectParent === null && (this.tempDisplayObjectParent = new DisplayObject()), this.tempDisplayObjectParent }, DisplayObject.prototype.updateTransform = function () { this.transform.updateTransform(this.parent.transform), this.worldAlpha = this.alpha * this.parent.worldAlpha, this._bounds.updateID++ }, DisplayObject.prototype._recursivePostUpdateTransform = function () { this.parent ? (this.parent._recursivePostUpdateTransform(), this.transform.updateTransform(this.parent.transform)) : this.transform.updateTransform(this._tempDisplayObjectParent.transform) }, DisplayObject.prototype.getBounds = function (skipUpdate, rect) { return skipUpdate || (this.parent ? (this._recursivePostUpdateTransform(), this.updateTransform()) : (this.parent = this._tempDisplayObjectParent, this.updateTransform(), this.parent = null)), this._boundsID !== this._lastBoundsID && this.calculateBounds(), rect || (this._boundsRect || (this._boundsRect = new Rectangle()), rect = this._boundsRect), this._bounds.getRectangle(rect) }, DisplayObject.prototype.getLocalBounds = function (rect) { var transformRef = this.transform; var parentRef = this.parent; this.parent = null, this.transform = this._tempDisplayObjectParent.transform, rect || (this._localBoundsRect || (this._localBoundsRect = new Rectangle()), rect = this._localBoundsRect); var bounds = this.getBounds(!1, rect); return this.parent = parentRef, this.transform = transformRef, bounds }, DisplayObject.prototype.toGlobal = function (position, point, skipUpdate) { return void 0 === skipUpdate && (skipUpdate = !1), skipUpdate || (this._recursivePostUpdateTransform(), this.parent ? this.displayObjectUpdateTransform() : (this.parent = this._tempDisplayObjectParent, this.displayObjectUpdateTransform(), this.parent = null)), this.worldTransform.apply(position, point) }, DisplayObject.prototype.toLocal = function (position, from, point, skipUpdate) { return from && (position = from.toGlobal(position, point, skipUpdate)), skipUpdate || (this._recursivePostUpdateTransform(), this.parent ? this.displayObjectUpdateTransform() : (this.parent = this._tempDisplayObjectParent, this.displayObjectUpdateTransform(), this.parent = null)), this.worldTransform.applyInverse(position, point) }, DisplayObject.prototype.render = function (renderer) {}, DisplayObject.prototype.setParent = function (container) { if (!container || !container.addChild) throw new Error('setParent: Argument must be a Container'); return container.addChild(this), container }, DisplayObject.prototype.setTransform = function (x, y, scaleX, scaleY, rotation, skewX, skewY, pivotX, pivotY) { return void 0 === x && (x = 0), void 0 === y && (y = 0), void 0 === scaleX && (scaleX = 1), void 0 === scaleY && (scaleY = 1), void 0 === rotation && (rotation = 0), void 0 === skewX && (skewX = 0), void 0 === skewY && (skewY = 0), void 0 === pivotX && (pivotX = 0), void 0 === pivotY && (pivotY = 0), this.position.x = x, this.position.y = y, this.scale.x = scaleX || 1, this.scale.y = scaleY || 1, this.rotation = rotation, this.skew.x = skewX, this.skew.y = skewY, this.pivot.x = pivotX, this.pivot.y = pivotY, this }, DisplayObject.prototype.destroy = function () { this.removeAllListeners(), this.parent && this.parent.removeChild(this), this.transform = null, this.parent = null, this._bounds = null, this._currentBounds = null, this._mask = null, this.filterArea = null, this.interactive = !1, this.interactiveChildren = !1, this._destroyed = !0 }, prototypeAccessors.x.get = function () { return this.position.x }, prototypeAccessors.x.set = function (value) { this.transform.position.x = value }, prototypeAccessors.y.get = function () { return this.position.y }, prototypeAccessors.y.set = function (value) { this.transform.position.y = value }, prototypeAccessors.worldTransform.get = function () { return this.transform.worldTransform }, prototypeAccessors.localTransform.get = function () { return this.transform.localTransform }, prototypeAccessors.position.get = function () { return this.transform.position }, prototypeAccessors.position.set = function (value) { this.transform.position.copyFrom(value) }, prototypeAccessors.scale.get = function () { return this.transform.scale }, prototypeAccessors.scale.set = function (value) { this.transform.scale.copyFrom(value) }, prototypeAccessors.pivot.get = function () { return this.transform.pivot }, prototypeAccessors.pivot.set = function (value) { this.transform.pivot.copyFrom(value) }, prototypeAccessors.skew.get = function () { return this.transform.skew }, prototypeAccessors.skew.set = function (value) { this.transform.skew.copyFrom(value) }, prototypeAccessors.rotation.get = function () { return this.transform.rotation }, prototypeAccessors.rotation.set = function (value) { this.transform.rotation = value }, prototypeAccessors.angle.get = function () { return this.transform.rotation * RAD_TO_DEG }, prototypeAccessors.angle.set = function (value) { this.transform.rotation = value * DEG_TO_RAD }, prototypeAccessors.zIndex.get = function () { return this._zIndex }, prototypeAccessors.zIndex.set = function (value) { this._zIndex = value, this.parent && (this.parent.sortDirty = !0) }, prototypeAccessors.worldVisible.get = function () { var item = this; do { if (!item.visible) return !1; item = item.parent } while (item);return !0 }, prototypeAccessors.mask.get = function () { return this._mask }, prototypeAccessors.mask.set = function (value) { this._mask && (this._mask.renderable = !0, this._mask.isMask = !1), this._mask = value, this._mask && (this._mask.renderable = !1, this._mask.isMask = !0) }, Object.defineProperties(DisplayObject.prototype, prototypeAccessors), DisplayObject }(eventemitter3)); function sortChildren (a, b) { return a.zIndex === b.zIndex ? a._lastSortedIndex - b._lastSortedIndex : a.zIndex - b.zIndex }DisplayObject.prototype.displayObjectUpdateTransform = DisplayObject.prototype.updateTransform; var Container = (function (DisplayObject) { function Container () { DisplayObject.call(this), this.children = [], this.sortableChildren = settings.SORTABLE_CHILDREN, this.sortDirty = !1 }DisplayObject && (Container.__proto__ = DisplayObject); var prototypeAccessors = { width: { configurable: !0 }, height: { configurable: !0 } }; return ((Container.prototype = Object.create(DisplayObject && DisplayObject.prototype)).constructor = Container).prototype.onChildrenChange = function () {}, Container.prototype.addChild = function (child) { var arguments$1 = arguments; var argumentsLength = arguments.length; if (argumentsLength > 1) for (var i = 0; i < argumentsLength; i++) this.addChild(arguments$1[i]); else child.parent && child.parent.removeChild(child), (child.parent = this).sortDirty = !0, child.transform._parentID = -1, this.children.push(child), this._boundsID++, this.onChildrenChange(this.children.length - 1), this.emit('childAdded', child, this, this.children.length - 1), child.emit('added', this); return child }, Container.prototype.addChildAt = function (child, index) { if (index < 0 || index > this.children.length) throw new Error(child + 'addChildAt: The index ' + index + ' supplied is out of bounds ' + this.children.length); return child.parent && child.parent.removeChild(child), (child.parent = this).sortDirty = !0, child.transform._parentID = -1, this.children.splice(index, 0, child), this._boundsID++, this.onChildrenChange(index), child.emit('added', this), this.emit('childAdded', child, this, index), child }, Container.prototype.swapChildren = function (child, child2) { if (child !== child2) { var index1 = this.getChildIndex(child); var index2 = this.getChildIndex(child2); this.children[index1] = child2, this.children[index2] = child, this.onChildrenChange(index1 < index2 ? index1 : index2) } }, Container.prototype.getChildIndex = function (child) { var index = this.children.indexOf(child); if (index === -1) throw new Error('The supplied DisplayObject must be a child of the caller'); return index }, Container.prototype.setChildIndex = function (child, index) { if (index < 0 || index >= this.children.length) throw new Error('The index ' + index + ' supplied is out of bounds ' + this.children.length); var currentIndex = this.getChildIndex(child); removeItems(this.children, currentIndex, 1), this.children.splice(index, 0, child), this.onChildrenChange(index) }, Container.prototype.getChildAt = function (index) { if (index < 0 || index >= this.children.length) throw new Error('getChildAt: Index (' + index + ') does not exist.'); return this.children[index] }, Container.prototype.removeChild = function (child) { var arguments$1 = arguments; var argumentsLength = arguments.length; if (argumentsLength > 1) for (var i = 0; i < argumentsLength; i++) this.removeChild(arguments$1[i]); else { var index = this.children.indexOf(child); if (index === -1) return null; child.parent = null, child.transform._parentID = -1, removeItems(this.children, index, 1), this._boundsID++, this.onChildrenChange(index), child.emit('removed', this), this.emit('childRemoved', child, this, index) } return child }, Container.prototype.removeChildAt = function (index) { var child = this.getChildAt(index); return child.parent = null, child.transform._parentID = -1, removeItems(this.children, index, 1), this._boundsID++, this.onChildrenChange(index), child.emit('removed', this), this.emit('childRemoved', child, this, index), child }, Container.prototype.removeChildren = function (beginIndex, endIndex) { void 0 === beginIndex && (beginIndex = 0); var removed; var begin = beginIndex; var end = typeof endIndex === 'number' ? endIndex : this.children.length; var range = end - begin; if (range > 0 && range <= end) { removed = this.children.splice(begin, range); for (var i = 0; i < removed.length; ++i)removed[i].parent = null, removed[i].transform && (removed[i].transform._parentID = -1); this._boundsID++, this.onChildrenChange(beginIndex); for (var i$1 = 0; i$1 < removed.length; ++i$1)removed[i$1].emit('removed', this), this.emit('childRemoved', removed[i$1], this, i$1); return removed } if (range == 0 && this.children.length === 0) return []; throw new RangeError('removeChildren: numeric values are outside the acceptable range.') }, Container.prototype.sortChildren = function () { for (var sortRequired = !1, i = 0, j = this.children.length; i < j; ++i) { var child = this.children[i]; child._lastSortedIndex = i, sortRequired || child.zIndex === 0 || (sortRequired = !0) }sortRequired && this.children.length > 1 && this.children.sort(sortChildren), this.sortDirty = !1 }, Container.prototype.updateTransform = function () { this.sortableChildren && this.sortDirty && this.sortChildren(), this._boundsID++, this.transform.updateTransform(this.parent.transform), this.worldAlpha = this.alpha * this.parent.worldAlpha; for (var i = 0, j = this.children.length; i < j; ++i) { var child = this.children[i]; child.visible && child.updateTransform() } }, Container.prototype.calculateBounds = function () { this._bounds.clear(), this._calculateBounds(); for (var i = 0; i < this.children.length; i++) { var child = this.children[i]; child.visible && child.renderable && (child.calculateBounds(), child._mask ? (child._mask.calculateBounds(), this._bounds.addBoundsMask(child._bounds, child._mask._bounds)) : child.filterArea ? this._bounds.addBoundsArea(child._bounds, child.filterArea) : this._bounds.addBounds(child._bounds)) } this._lastBoundsID = this._boundsID }, Container.prototype._calculateBounds = function () {}, Container.prototype.render = function (renderer) { if (this.visible && !(this.worldAlpha <= 0) && this.renderable) if (this._mask || this.filters) this.renderAdvanced(renderer); else { this._render(renderer); for (var i = 0, j = this.children.length; i < j; ++i) this.children[i].render(renderer) } }, Container.prototype.renderAdvanced = function (renderer) { renderer.batch.flush(); var filters = this.filters; var mask = this._mask; if (filters) { this._enabledFilters || (this._enabledFilters = []); for (var i = this._enabledFilters.length = 0; i < filters.length; i++)filters[i].enabled && this._enabledFilters.push(filters[i]); this._enabledFilters.length && renderer.filter.push(this, this._enabledFilters) }mask && renderer.mask.push(this, this._mask), this._render(renderer); for (var i$1 = 0, j = this.children.length; i$1 < j; i$1++) this.children[i$1].render(renderer); renderer.batch.flush(), mask && renderer.mask.pop(this, this._mask), filters && this._enabledFilters && this._enabledFilters.length && renderer.filter.pop() }, Container.prototype._render = function (renderer) {}, Container.prototype.destroy = function (options) { DisplayObject.prototype.destroy.call(this), this.sortDirty = !1; var destroyChildren = typeof options === 'boolean' ? options : options && options.children; var oldChildren = this.removeChildren(0, this.children.length); if (destroyChildren) for (var i = 0; i < oldChildren.length; ++i)oldChildren[i].destroy(options) }, prototypeAccessors.width.get = function () { return this.scale.x * this.getLocalBounds().width }, prototypeAccessors.width.set = function (value) { var width = this.getLocalBounds().width; this.scale.x = width !== 0 ? value / width : 1, this._width = value }, prototypeAccessors.height.get = function () { return this.scale.y * this.getLocalBounds().height }, prototypeAccessors.height.set = function (value) { var height = this.getLocalBounds().height; this.scale.y = height !== 0 ? value / height : 1, this._height = value }, Object.defineProperties(Container.prototype, prototypeAccessors), Container }(DisplayObject)); Container.prototype.containerUpdateTransform = Container.prototype.updateTransform; var accessibleTarget = { accessible: !1, accessibleTitle: null, accessibleHint: null, tabIndex: 0, _accessibleActive: !1, _accessibleDiv: !1 }; DisplayObject.mixin(accessibleTarget); var AccessibilityManager = function (renderer) { this._hookDiv = null, (isMobile_min.tablet || isMobile_min.phone) && this.createTouchHook(); var div = document.createElement('div'); div.style.width = '100px', div.style.height = '100px', div.style.position = 'absolute', div.style.top = '0px', div.style.left = '0px', div.style.zIndex = 2, this.div = div, this.pool = [], this.renderId = 0, this.debug = !1, this.renderer = renderer, this.children = [], this._onKeyDown = this._onKeyDown.bind(this), this._onMouseMove = this._onMouseMove.bind(this), this.isActive = !1, this.isMobileAccessibility = !1, window.addEventListener('keydown', this._onKeyDown, !1) }; AccessibilityManager.prototype.createTouchHook = function () { var this$1 = this; var hookDiv = document.createElement('button'); hookDiv.style.width = '1px', hookDiv.style.height = '1px', hookDiv.style.position = 'absolute', hookDiv.style.top = '-1000px', hookDiv.style.left = '-1000px', hookDiv.style.zIndex = 2, hookDiv.style.backgroundColor = '#FF0000', hookDiv.title = 'HOOK DIV', hookDiv.addEventListener('focus', function () { this$1.isMobileAccessibility = !0, this$1.activate(), this$1.destroyTouchHook() }), document.body.appendChild(hookDiv), this._hookDiv = hookDiv }, AccessibilityManager.prototype.destroyTouchHook = function () { this._hookDiv && (document.body.removeChild(this._hookDiv), this._hookDiv = null) }, AccessibilityManager.prototype.activate = function () { this.isActive || (this.isActive = !0, window.document.addEventListener('mousemove', this._onMouseMove, !0), window.removeEventListener('keydown', this._onKeyDown, !1), this.renderer.on('postrender', this.update, this), this.renderer.view.parentNode && this.renderer.view.parentNode.appendChild(this.div)) }, AccessibilityManager.prototype.deactivate = function () { this.isActive && !this.isMobileAccessibility && (this.isActive = !1, window.document.removeEventListener('mousemove', this._onMouseMove, !0), window.addEventListener('keydown', this._onKeyDown, !1), this.renderer.off('postrender', this.update), this.div.parentNode && this.div.parentNode.removeChild(this.div)) }, AccessibilityManager.prototype.updateAccessibleObjects = function (displayObject) { if (displayObject.visible) { displayObject.accessible && displayObject.interactive && (displayObject._accessibleActive || this.addChild(displayObject), displayObject.renderId = this.renderId); for (var children = displayObject.children, i = 0; i < children.length; i++) this.updateAccessibleObjects(children[i]) } }, AccessibilityManager.prototype.update = function () { if (this.renderer.renderingToScreen) { this.updateAccessibleObjects(this.renderer._lastObjectRendered); var rect = this.renderer.view.getBoundingClientRect(); var sx = rect.width / this.renderer.width; var sy = rect.height / this.renderer.height; var div = this.div; div.style.left = rect.left + 'px', div.style.top = rect.top + 'px', div.style.width = this.renderer.width + 'px', div.style.height = this.renderer.height + 'px'; for (var i = 0; i < this.children.length; i++) { var child = this.children[i]; if (child.renderId !== this.renderId)child._accessibleActive = !1, removeItems(this.children, i, 1), this.div.removeChild(child._accessibleDiv), this.pool.push(child._accessibleDiv), child._accessibleDiv = null, i--, this.children.length === 0 && this.deactivate(); else { div = child._accessibleDiv; var hitArea = child.hitArea; var wt = child.worldTransform; child.hitArea ? (div.style.left = (wt.tx + hitArea.x * wt.a) * sx + 'px', div.style.top = (wt.ty + hitArea.y * wt.d) * sy + 'px', div.style.width = hitArea.width * wt.a * sx + 'px', div.style.height = hitArea.height * wt.d * sy + 'px') : (hitArea = child.getBounds(), this.capHitArea(hitArea), div.style.left = hitArea.x * sx + 'px', div.style.top = hitArea.y * sy + 'px', div.style.width = hitArea.width * sx + 'px', div.style.height = hitArea.height * sy + 'px', div.title !== child.accessibleTitle && child.accessibleTitle !== null && (div.title = child.accessibleTitle), div.getAttribute('aria-label') !== child.accessibleHint && child.accessibleHint !== null && div.setAttribute('aria-label', child.accessibleHint)) } } this.renderId++ } }, AccessibilityManager.prototype.capHitArea = function (hitArea) { hitArea.x < 0 && (hitArea.width += hitArea.x, hitArea.x = 0), hitArea.y < 0 && (hitArea.height += hitArea.y, hitArea.y = 0), hitArea.x + hitArea.width > this.renderer.width && (hitArea.width = this.renderer.width - hitArea.x), hitArea.y + hitArea.height > this.renderer.height && (hitArea.height = this.renderer.height - hitArea.y) }, AccessibilityManager.prototype.addChild = function (displayObject) { var div = this.pool.pop(); div || ((div = document.createElement('button')).style.width = '100px', div.style.height = '100px', div.style.backgroundColor = this.debug ? 'rgba(255,0,0,0.5)' : 'transparent', div.style.position = 'absolute', div.style.zIndex = 2, div.style.borderStyle = 'none', navigator.userAgent.toLowerCase().indexOf('chrome') > -1 ? div.setAttribute('aria-live', 'off') : div.setAttribute('aria-live', 'polite'), navigator.userAgent.match(/rv:.*Gecko\//) ? div.setAttribute('aria-relevant', 'additions') : div.setAttribute('aria-relevant', 'text'), div.addEventListener('click', this._onClick.bind(this)), div.addEventListener('focus', this._onFocus.bind(this)), div.addEventListener('focusout', this._onFocusOut.bind(this))), displayObject.accessibleTitle && displayObject.accessibleTitle !== null ? div.title = displayObject.accessibleTitle : displayObject.accessibleHint && displayObject.accessibleHint !== null || (div.title = 'displayObject ' + displayObject.tabIndex), displayObject.accessibleHint && displayObject.accessibleHint !== null && div.setAttribute('aria-label', displayObject.accessibleHint), displayObject._accessibleActive = !0, (displayObject._accessibleDiv = div).displayObject = displayObject, this.children.push(displayObject), this.div.appendChild(displayObject._accessibleDiv), displayObject._accessibleDiv.tabIndex = displayObject.tabIndex }, AccessibilityManager.prototype._onClick = function (e) { var interactionManager = this.renderer.plugins.interaction; interactionManager.dispatchEvent(e.target.displayObject, 'click', interactionManager.eventData) }, AccessibilityManager.prototype._onFocus = function (e) { e.target.getAttribute('aria-live', 'off') || e.target.setAttribute('aria-live', 'assertive'); var interactionManager = this.renderer.plugins.interaction; interactionManager.dispatchEvent(e.target.displayObject, 'mouseover', interactionManager.eventData) }, AccessibilityManager.prototype._onFocusOut = function (e) { e.target.getAttribute('aria-live', 'off') || e.target.setAttribute('aria-live', 'polite'); var interactionManager = this.renderer.plugins.interaction; interactionManager.dispatchEvent(e.target.displayObject, 'mouseout', interactionManager.eventData) }, AccessibilityManager.prototype._onKeyDown = function (e) { e.keyCode === 9 && this.activate() }, AccessibilityManager.prototype._onMouseMove = function (e) { e.movementX === 0 && e.movementY === 0 || this.deactivate() }, AccessibilityManager.prototype.destroy = function () { this.destroyTouchHook(), this.div = null; for (var i = 0; i < this.children.length; i++) this.children[i].div = null; window.document.removeEventListener('mousemove', this._onMouseMove, !0), window.removeEventListener('keydown', this._onKeyDown), this.pool = null, this.children = null, this.renderer = null }; var accessibility_es = { AccessibilityManager: AccessibilityManager, accessibleTarget: accessibleTarget }; var Runner = function (name) { this.items = [], this._name = name }; var prototypeAccessors$3 = { empty: { configurable: !0 }, name: { configurable: !0 } }; Runner.prototype.emit = function (a0, a1, a2, a3, a4, a5, a6, a7) { if (arguments.length > 8) throw new Error('max arguments reached'); for (var name = this.name, items = this.items, i = 0, len = items.length; i < len; i++)items[i][name](a0, a1, a2, a3, a4, a5, a6, a7); return this }, Runner.prototype.add = function (item) { return item[this._name] && (this.remove(item), this.items.push(item)), this }, Runner.prototype.remove = function (item) { var index = this.items.indexOf(item); return index !== -1 && this.items.splice(index, 1), this }, Runner.prototype.contains = function (item) { return this.items.indexOf(item) !== -1 }, Runner.prototype.removeAll = function () { return this.items.length = 0, this }, Runner.prototype.destroy = function () { this.removeAll(), this.items = null, this._name = null }, prototypeAccessors$3.empty.get = function () { return this.items.length === 0 }, prototypeAccessors$3.name.get = function () { return this._name }, Object.defineProperties(Runner.prototype, prototypeAccessors$3), Runner.prototype.dispatch = Runner.prototype.emit, Runner.prototype.run = Runner.prototype.emit, settings.TARGET_FPMS = 0.06; var UPDATE_PRIORITY = { INTERACTION: 50, HIGH: 25, NORMAL: 0, LOW: -25, UTILITY: -50 }; var TickerListener = function (fn, context, priority, once) { void 0 === context && (context = null), void 0 === priority && (priority = 0), void 0 === once && (once = !1), this.fn = fn, this.context = context, this.priority = priority, this.once = once, this.next = null, this.previous = null, this._destroyed = !1 }; TickerListener.prototype.match = function (fn, context) { return context = context || null, this.fn === fn && this.context === context }, TickerListener.prototype.emit = function (deltaTime) { this.fn && (this.context ? this.fn.call(this.context, deltaTime) : this.fn(deltaTime)); var redirect = this.next; return this.once && this.destroy(!0), this._destroyed && (this.next = null), redirect }, TickerListener.prototype.connect = function (previous) { (this.previous = previous).next && (previous.next.previous = this), this.next = previous.next, previous.next = this }, TickerListener.prototype.destroy = function (hard) { void 0 === hard && (hard = !1), this._destroyed = !0, this.fn = null, this.context = null, this.previous && (this.previous.next = this.next), this.next && (this.next.previous = this.previous); var redirect = this.next; return this.next = hard ? null : redirect, this.previous = null, redirect }; var Ticker = function () { var this$1 = this; this._head = new TickerListener(null, null, 1 / 0), this._requestId = null, this._maxElapsedMS = 100, this._minElapsedMS = 0, this.autoStart = !1, this.deltaTime = 1, this.deltaMS = 1 / settings.TARGET_FPMS, this.elapsedMS = 1 / settings.TARGET_FPMS, this.lastTime = -1, this.speed = 1, this.started = !1, this._protected = !1, this._tick = function (time) { this$1._requestId = null, this$1.started && (this$1.update(time), this$1.started && this$1._requestId === null && this$1._head.next && (this$1._requestId = requestAnimationFrame(this$1._tick))) } }; var prototypeAccessors$4 = { FPS: { configurable: !0 }, minFPS: { configurable: !0 }, maxFPS: { configurable: !0 } }; var staticAccessors$2 = { shared: { configurable: !0 }, system: { configurable: !0 } }; Ticker.prototype._requestIfNeeded = function () { this._requestId === null && this._head.next && (this.lastTime = performance.now(), this._requestId = requestAnimationFrame(this._tick)) }, Ticker.prototype._cancelIfNeeded = function () { this._requestId !== null && (cancelAnimationFrame(this._requestId), this._requestId = null) }, Ticker.prototype._startIfPossible = function () { this.started ? this._requestIfNeeded() : this.autoStart && this.start() }, Ticker.prototype.add = function (fn, context, priority) { return void 0 === priority && (priority = UPDATE_PRIORITY.NORMAL), this._addListener(new TickerListener(fn, context, priority)) }, Ticker.prototype.addOnce = function (fn, context, priority) { return void 0 === priority && (priority = UPDATE_PRIORITY.NORMAL), this._addListener(new TickerListener(fn, context, priority, !0)) }, Ticker.prototype._addListener = function (listener) { var current = this._head.next; var previous = this._head; if (current) { for (;current;) { if (listener.priority > current.priority) { listener.connect(previous); break }current = (previous = current).next }listener.previous || listener.connect(previous) } else listener.connect(previous); return this._startIfPossible(), this }, Ticker.prototype.remove = function (fn, context) { for (var listener = this._head.next; listener;)listener = listener.match(fn, context) ? listener.destroy() : listener.next; return this._head.next || this._cancelIfNeeded(), this }, Ticker.prototype.start = function () { this.started || (this.started = !0, this._requestIfNeeded()) }, Ticker.prototype.stop = function () { this.started && (this.started = !1, this._cancelIfNeeded()) }, Ticker.prototype.destroy = function () { if (!this._protected) { this.stop(); for (var listener = this._head.next; listener;)listener = listener.destroy(!0); this._head.destroy(), this._head = null } }, Ticker.prototype.update = function (currentTime) { var elapsedMS; if (void 0 === currentTime && (currentTime = performance.now()), currentTime > this.lastTime) { if ((elapsedMS = this.elapsedMS = currentTime - this.lastTime) > this._maxElapsedMS && (elapsedMS = this._maxElapsedMS), elapsedMS *= this.speed, this._minElapsedMS && elapsedMS + 1 < this._minElapsedMS) return; this.deltaMS = elapsedMS, this.deltaTime = this.deltaMS * settings.TARGET_FPMS; for (var head = this._head, listener = head.next; listener;)listener = listener.emit(this.deltaTime); head.next || this._cancelIfNeeded() } else this.deltaTime = this.deltaMS = this.elapsedMS = 0; this.lastTime = currentTime }, prototypeAccessors$4.FPS.get = function () { return 1e3 / this.elapsedMS }, prototypeAccessors$4.minFPS.get = function () { return 1e3 / this._maxElapsedMS }, prototypeAccessors$4.minFPS.set = function (fps) { var minFPS = Math.min(this.maxFPS, fps); var minFPMS = Math.min(Math.max(0, minFPS) / 1e3, settings.TARGET_FPMS); this._maxElapsedMS = 1 / minFPMS }, prototypeAccessors$4.maxFPS.get = function () { return this._minElapsedMS ? 1e3 / this._minElapsedMS : 1e3 * settings.TARGET_FPMS }, prototypeAccessors$4.maxFPS.set = function (fps) { if (fps / 1e3 >= settings.TARGET_FPMS) this._minElapsedMS = 0; else { var maxFPS = Math.max(this.minFPS, fps); var maxFPMS = Math.min(Math.max(1, maxFPS) / 1e3, settings.TARGET_FPMS); this._minElapsedMS = 1 / maxFPMS } }, staticAccessors$2.shared.get = function () { if (!Ticker._shared) { var shared = Ticker._shared = new Ticker(); shared.autoStart = !0, shared._protected = !0 } return Ticker._shared }, staticAccessors$2.system.get = function () { if (!Ticker._system) { var system = Ticker._system = new Ticker(); system.autoStart = !0, system._protected = !0 } return Ticker._system }, Object.defineProperties(Ticker.prototype, prototypeAccessors$4), Object.defineProperties(Ticker, staticAccessors$2); var TickerPlugin = function () {}; TickerPlugin.init = function (options) { var this$1 = this; options = Object.assign({ autoStart: !0, sharedTicker: !1 }, options), Object.defineProperty(this, 'ticker', { set: function (ticker) { this._ticker && this._ticker.remove(this.render, this), (this._ticker = ticker) && ticker.add(this.render, this, UPDATE_PRIORITY.LOW) }, get: function () { return this._ticker } }), this.stop = function () { this$1._ticker.stop() }, this.start = function () { this$1._ticker.start() }, this._ticker = null, this.ticker = options.sharedTicker ? Ticker.shared : new Ticker(), options.autoStart && this.start() }, TickerPlugin.destroy = function () { if (this._ticker) { var oldTicker = this._ticker; this.ticker = null, oldTicker.destroy() } }; var Resource = function (width, height) { void 0 === width && (width = 0), void 0 === height && (height = 0), this._width = width, this._height = height, this.destroyed = !1, this.internal = !1, this.onResize = new Runner('setRealSize', 2), this.onUpdate = new Runner('update') }; var prototypeAccessors$5 = { valid: { configurable: !0 }, width: { configurable: !0 }, height: { configurable: !0 } }; Resource.prototype.bind = function (baseTexture) { this.onResize.add(baseTexture), this.onUpdate.add(baseTexture), (this._width || this._height) && this.onResize.run(this._width, this._height) }, Resource.prototype.unbind = function (baseTexture) { this.onResize.remove(baseTexture), this.onUpdate.remove(baseTexture) }, Resource.prototype.resize = function (width, height) { width === this._width && height === this._height || (this._width = width, this._height = height, this.onResize.run(width, height)) }, prototypeAccessors$5.valid.get = function () { return !!this._width && !!this._height }, Resource.prototype.update = function () { this.destroyed || this.onUpdate.run() }, Resource.prototype.load = function () { return Promise.resolve() }, prototypeAccessors$5.width.get = function () { return this._width }, prototypeAccessors$5.height.get = function () { return this._height }, Resource.prototype.upload = function (renderer, baseTexture, glTexture) { return !1 }, Resource.prototype.style = function (renderer, baseTexture, glTexture) { return !1 }, Resource.prototype.dispose = function () {}, Resource.prototype.destroy = function () { this.destroyed || (this.onResize.removeAll(), this.onResize = null, this.onUpdate.removeAll(), this.onUpdate = null, this.destroyed = !0, this.dispose()) }, Object.defineProperties(Resource.prototype, prototypeAccessors$5); var BaseImageResource = (function (Resource) { function BaseImageResource (source) { var width = source.naturalWidth || source.videoWidth || source.width; var height = source.naturalHeight || source.videoHeight || source.height; Resource.call(this, width, height), this.source = source } return Resource && (BaseImageResource.__proto__ = Resource), ((BaseImageResource.prototype = Object.create(Resource && Resource.prototype)).constructor = BaseImageResource).crossOrigin = function (element, url, crossorigin) { void 0 === crossorigin && url.indexOf('data:') !== 0 ? element.crossOrigin = determineCrossOrigin(url) : !1 !== crossorigin && (element.crossOrigin = typeof crossorigin === 'string' ? crossorigin : 'anonymous') }, BaseImageResource.prototype.upload = function (renderer, baseTexture, glTexture, source) { var gl = renderer.gl; var width = baseTexture.realWidth; var height = baseTexture.realHeight; return source = source || this.source, gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, baseTexture.premultiplyAlpha), baseTexture.target === gl.TEXTURE_2D && glTexture.width === width && glTexture.height === height ? gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, baseTexture.format, baseTexture.type, source) : (glTexture.width = width, glTexture.height = height, gl.texImage2D(baseTexture.target, 0, baseTexture.format, baseTexture.format, baseTexture.type, source)), !0 }, BaseImageResource.prototype.update = function () { if (!this.destroyed) { var width = this.source.naturalWidth || this.source.videoWidth || this.source.width; var height = this.source.naturalHeight || this.source.videoHeight || this.source.height; this.resize(width, height), Resource.prototype.update.call(this) } }, BaseImageResource.prototype.dispose = function () { this.source = null }, BaseImageResource }(Resource)); var ImageResource = (function (BaseImageResource) { function ImageResource (source, options) { if (options = options || {}, !(source instanceof HTMLImageElement)) { var imageElement = new Image(); BaseImageResource.crossOrigin(imageElement, source, options.crossorigin), imageElement.src = source, source = imageElement }BaseImageResource.call(this, source), this.url = source.src, this._process = null, this.preserveBitmap = !1, this.createBitmap = (void 0 !== options.createBitmap ? options.createBitmap : settings.CREATE_IMAGE_BITMAP) && !!window.createImageBitmap, this.premultiplyAlpha = !1 !== options.premultiplyAlpha, this.bitmap = null, this._load = null, !1 !== options.autoLoad && this.load() } return BaseImageResource && (ImageResource.__proto__ = BaseImageResource), ((ImageResource.prototype = Object.create(BaseImageResource && BaseImageResource.prototype)).constructor = ImageResource).prototype.load = function (createBitmap) { var this$1 = this; return void 0 !== createBitmap && (this.createBitmap = createBitmap), this._load || (this._load = new Promise(function (resolve) { this$1.url = this$1.source.src; function completed () { this$1.destroyed || (source.onload = null, source.onerror = null, this$1.resize(source.width, source.height), this$1._load = null, this$1.createBitmap ? resolve(this$1.process()) : resolve(this$1)) } var source = this$1.source; source.complete && source.src ? completed() : source.onload = completed })), this._load }, ImageResource.prototype.process = function () { var this$1 = this; return this._process !== null ? this._process : this.bitmap === null && window.createImageBitmap ? (this._process = window.createImageBitmap(this.source, 0, 0, this.source.width, this.source.height, { premultiplyAlpha: this.premultiplyAlpha ? 'premultiply' : 'none' }).then(function (bitmap) { return this$1.destroyed ? Promise.reject() : (this$1.bitmap = bitmap, this$1.update(), this$1._process = null, Promise.resolve(this$1)) }), this._process) : Promise.resolve(this) }, ImageResource.prototype.upload = function (renderer, baseTexture, glTexture) { if (baseTexture.premultiplyAlpha = this.premultiplyAlpha, !this.createBitmap) return BaseImageResource.prototype.upload.call(this, renderer, baseTexture, glTexture); if (!this.bitmap && (this.process(), !this.bitmap)) return !1; if (BaseImageResource.prototype.upload.call(this, renderer, baseTexture, glTexture, this.bitmap), !this.preserveBitmap) { var flag = !0; for (var key in baseTexture._glTextures) { var otherTex = baseTexture._glTextures[key]; if (otherTex !== glTexture && otherTex.dirtyId !== baseTexture.dirtyId) { flag = !1; break } }flag && (this.bitmap.close && this.bitmap.close(), this.bitmap = null) } return !0 }, ImageResource.prototype.dispose = function () { BaseImageResource.prototype.dispose.call(this), this.bitmap && (this.bitmap.close(), this.bitmap = null), this._process = null, this._load = null }, ImageResource }(BaseImageResource)); var INSTALLED = []; function autoDetectResource (source, options) { if (!source) return null; var extension = ''; if (typeof source === 'string') { var result = /\.(\w{3,4})(?:$|\?|#)/i.exec(source); result && (extension = result[1].toLowerCase()) } for (var i = INSTALLED.length - 1; i >= 0; --i) { var ResourcePlugin = INSTALLED[i]; if (ResourcePlugin.test && ResourcePlugin.test(source, extension)) return new ResourcePlugin(source, options) } return new ImageResource(source, options) } var BufferResource = (function (Resource) { function BufferResource (source, options) { var ref = options || {}; var width = ref.width; var height = ref.height; if (!width || !height) throw new Error('BufferResource width or height invalid'); Resource.call(this, width, height), this.data = source } return Resource && (BufferResource.__proto__ = Resource), ((BufferResource.prototype = Object.create(Resource && Resource.prototype)).constructor = BufferResource).prototype.upload = function (renderer, baseTexture, glTexture) { var gl = renderer.gl; if (gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, baseTexture.premultiplyAlpha), glTexture.width === baseTexture.width && glTexture.height === baseTexture.height)gl.texSubImage2D(baseTexture.target, 0, 0, 0, baseTexture.width, baseTexture.height, baseTexture.format, baseTexture.type, this.data); else { glTexture.width = baseTexture.width, glTexture.height = baseTexture.height; var internalFormat = baseTexture.format; renderer.context.webGLVersion === 2 && baseTexture.type === renderer.gl.FLOAT && baseTexture.format === renderer.gl.RGBA && (internalFormat = renderer.gl.RGBA32F), gl.texImage2D(baseTexture.target, 0, internalFormat, baseTexture.width, baseTexture.height, 0, baseTexture.format, baseTexture.type, this.data) } return !0 }, BufferResource.prototype.dispose = function () { this.data = null }, BufferResource.test = function (source) { return source instanceof Float32Array || source instanceof Uint8Array || source instanceof Uint32Array }, BufferResource }(Resource)); var defaultBufferOptions = { scaleMode: SCALE_MODES.NEAREST, format: FORMATS.RGBA, premultiplyAlpha: !1 }; var BaseTexture = (function (EventEmitter) { function BaseTexture (resource, options) { void 0 === resource && (resource = null), void 0 === options && (options = null), EventEmitter.call(this); var premultiplyAlpha = (options = options || {}).premultiplyAlpha; var mipmap = options.mipmap; var scaleMode = options.scaleMode; var width = options.width; var height = options.height; var wrapMode = options.wrapMode; var format = options.format; var type = options.type; var target = options.target; var resolution = options.resolution; var resourceOptions = options.resourceOptions; !resource || resource instanceof Resource || ((resource = autoDetectResource(resource, resourceOptions)).internal = !0), this.width = width || 0, this.height = height || 0, this.resolution = resolution || settings.RESOLUTION, this.mipmap = void 0 !== mipmap ? mipmap : settings.MIPMAP_TEXTURES, this.wrapMode = wrapMode || settings.WRAP_MODE, this.scaleMode = void 0 !== scaleMode ? scaleMode : settings.SCALE_MODE, this.format = format || FORMATS.RGBA, this.type = type || TYPES.UNSIGNED_BYTE, this.target = target || TARGETS.TEXTURE_2D, this.premultiplyAlpha = !1 !== premultiplyAlpha, this.uid = uid(), this.touched = 0, this.isPowerOfTwo = !1, this._refreshPOT(), this._glTextures = {}, this.dirtyId = 0, this.dirtyStyleId = 0, this.cacheId = null, this.valid = width > 0 && height > 0, this.textureCacheIds = [], this.destroyed = !1, this.resource = null, this._batchEnabled = 0, this.setResource(resource) }EventEmitter && (BaseTexture.__proto__ = EventEmitter), (BaseTexture.prototype = Object.create(EventEmitter && EventEmitter.prototype)).constructor = BaseTexture; var prototypeAccessors = { realWidth: { configurable: !0 }, realHeight: { configurable: !0 } }; return prototypeAccessors.realWidth.get = function () { return this.width * this.resolution }, prototypeAccessors.realHeight.get = function () { return this.height * this.resolution }, BaseTexture.prototype.setStyle = function (scaleMode, mipmap) { var dirty; return void 0 !== scaleMode && scaleMode !== this.scaleMode && (this.scaleMode = scaleMode, dirty = !0), void 0 !== mipmap && mipmap !== this.mipmap && (this.mipmap = mipmap, dirty = !0), dirty && this.dirtyStyleId++, this }, BaseTexture.prototype.setSize = function (width, height, resolution) { return this.resolution = resolution || this.resolution, this.width = width, this.height = height, this._refreshPOT(), this.update(), this }, BaseTexture.prototype.setRealSize = function (realWidth, realHeight, resolution) { return this.resolution = resolution || this.resolution, this.width = realWidth / this.resolution, this.height = realHeight / this.resolution, this._refreshPOT(), this.update(), this }, BaseTexture.prototype._refreshPOT = function () { this.isPowerOfTwo = isPow2(this.realWidth) && isPow2(this.realHeight) }, BaseTexture.prototype.setResolution = function (resolution) { var oldResolution = this.resolution; return oldResolution === resolution || (this.resolution = resolution, this.valid && (this.width = this.width * oldResolution / resolution, this.height = this.height * oldResolution / resolution, this.emit('update', this)), this._refreshPOT()), this }, BaseTexture.prototype.setResource = function (resource) { if (this.resource === resource) return this; if (this.resource) throw new Error('Resource can be set only once'); return resource.bind(this), this.resource = resource, this }, BaseTexture.prototype.update = function () { this.valid ? (this.dirtyId++, this.dirtyStyleId++, this.emit('update', this)) : this.width > 0 && this.height > 0 && (this.valid = !0, this.emit('loaded', this), this.emit('update', this)) }, BaseTexture.prototype.destroy = function () { this.resource && (this.resource.unbind(this), this.resource.internal && this.resource.destroy(), this.resource = null), this.cacheId && (delete BaseTextureCache[this.cacheId], delete TextureCache[this.cacheId], this.cacheId = null), this.dispose(), BaseTexture.removeFromCache(this), this.textureCacheIds = null, this.destroyed = !0 }, BaseTexture.prototype.dispose = function () { this.emit('dispose', this) }, BaseTexture.from = function (source, options) { var cacheId = null; cacheId = typeof source === 'string' ? source : (source._pixiId || (source._pixiId = 'pixiid_' + uid()), source._pixiId); var baseTexture = BaseTextureCache[cacheId]; return baseTexture || ((baseTexture = new BaseTexture(source, options)).cacheId = cacheId, BaseTexture.addToCache(baseTexture, cacheId)), baseTexture }, BaseTexture.fromBuffer = function (buffer, width, height, options) { buffer = buffer || new Float32Array(width * height * 4); var resource = new BufferResource(buffer, { width: width, height: height }); var type = buffer instanceof Float32Array ? TYPES.FLOAT : TYPES.UNSIGNED_BYTE; return new BaseTexture(resource, Object.assign(defaultBufferOptions, options || { width: width, height: height, type: type })) }, BaseTexture.addToCache = function (baseTexture, id) { id && (baseTexture.textureCacheIds.indexOf(id) === -1 && baseTexture.textureCacheIds.push(id), BaseTextureCache[id] && console.warn('BaseTexture added to the cache with an id [' + id + '] that already had an entry'), BaseTextureCache[id] = baseTexture) }, BaseTexture.removeFromCache = function (baseTexture) { if (typeof baseTexture === 'string') { var baseTextureFromCache = BaseTextureCache[baseTexture]; if (baseTextureFromCache) { var index = baseTextureFromCache.textureCacheIds.indexOf(baseTexture); return index > -1 && baseTextureFromCache.textureCacheIds.splice(index, 1), delete BaseTextureCache[baseTexture], baseTextureFromCache } } else if (baseTexture && baseTexture.textureCacheIds) { for (var i = 0; i < baseTexture.textureCacheIds.length; ++i) delete BaseTextureCache[baseTexture.textureCacheIds[i]]; return baseTexture.textureCacheIds.length = 0, baseTexture } return null }, Object.defineProperties(BaseTexture.prototype, prototypeAccessors), BaseTexture }(eventemitter3)); BaseTexture._globalBatch = 0; var ArrayResource = (function (Resource) { function ArrayResource (source, options) { var urls; options = options || {}; var length = source; Array.isArray(source) && (length = (urls = source).length), Resource.call(this, options.width, options.height), this.items = [], this.itemDirtyIds = []; for (var i = 0; i < length; i++) { var partTexture = new BaseTexture(); this.items.push(partTexture), this.itemDirtyIds.push(-1) } if (this.length = length, this._load = null, urls) for (var i$1 = 0; i$1 < length; i$1++) this.addResourceAt(autoDetectResource(urls[i$1], options), i$1) } return Resource && (ArrayResource.__proto__ = Resource), ((ArrayResource.prototype = Object.create(Resource && Resource.prototype)).constructor = ArrayResource).prototype.dispose = function () { for (var i = 0, len = this.length; i < len; i++) this.items[i].destroy(); this.items = null, this.itemDirtyIds = null, this._load = null }, ArrayResource.prototype.addResourceAt = function (resource, index) { if (!this.items[index]) throw new Error('Index ' + index + ' is out of bounds'); return resource.valid && !this.valid && this.resize(resource.width, resource.height), this.items[index].setResource(resource), this }, ArrayResource.prototype.bind = function (baseTexture) { Resource.prototype.bind.call(this, baseTexture), baseTexture.target = TARGETS.TEXTURE_2D_ARRAY; for (var i = 0; i < this.length; i++) this.items[i].on('update', baseTexture.update, baseTexture) }, ArrayResource.prototype.unbind = function (baseTexture) { Resource.prototype.unbind.call(this, baseTexture); for (var i = 0; i < this.length; i++) this.items[i].off('update', baseTexture.update, baseTexture) }, ArrayResource.prototype.load = function () { var this$1 = this; if (this._load) return this._load; var resources = this.items.map(function (item) { return item.resource }); var promises = resources.map(function (item) { return item.load() }); return this._load = Promise.all(promises).then(function () { var ref = resources[0]; var width = ref.width; var height = ref.height; return this$1.resize(width, height), Promise.resolve(this$1) }), this._load }, ArrayResource.prototype.upload = function (renderer, texture, glTexture) { var length = this.length; var itemDirtyIds = this.itemDirtyIds; var items = this.items; var gl = renderer.gl; glTexture.dirtyId < 0 && gl.texImage3D(gl.TEXTURE_2D_ARRAY, 0, texture.format, this._width, this._height, length, 0, texture.format, texture.type, null); for (var i = 0; i < length; i++) { var item = items[i]; itemDirtyIds[i] < item.dirtyId && (itemDirtyIds[i] = item.dirtyId, item.valid && gl.texSubImage3D(gl.TEXTURE_2D_ARRAY, 0, 0, 0, i, item.resource.width, item.resource.height, 1, texture.format, texture.type, item.resource.source)) } return !0 }, ArrayResource }(Resource)); var CanvasResource = (function (BaseImageResource) { function CanvasResource () { BaseImageResource.apply(this, arguments) } return BaseImageResource && (CanvasResource.__proto__ = BaseImageResource), ((CanvasResource.prototype = Object.create(BaseImageResource && BaseImageResource.prototype)).constructor = CanvasResource).test = function (source) { return source instanceof HTMLCanvasElement }, CanvasResource }(BaseImageResource)); var CubeResource = (function (ArrayResource) { function CubeResource (source, options) { if (options = options || {}, ArrayResource.call(this, source, options), this.length !== CubeResource.SIDES) throw new Error('Invalid length. Got ' + this.length + ', expected 6'); for (var i = 0; i < CubeResource.SIDES; i++) this.items[i].target = TARGETS.TEXTURE_CUBE_MAP_POSITIVE_X + i; !1 !== options.autoLoad && this.load() } return ArrayResource && (CubeResource.__proto__ = ArrayResource), ((CubeResource.prototype = Object.create(ArrayResource && ArrayResource.prototype)).constructor = CubeResource).prototype.bind = function (baseTexture) { ArrayResource.prototype.bind.call(this, baseTexture), baseTexture.target = TARGETS.TEXTURE_CUBE_MAP }, CubeResource.prototype.upload = function (renderer, baseTexture, glTexture) { for (var dirty = this.itemDirtyIds, i = 0; i < CubeResource.SIDES; i++) { var side = this.items[i]; dirty[i] < side.dirtyId && (dirty[i] = side.dirtyId, side.valid && side.resource.upload(renderer, side, glTexture)) } return !0 }, CubeResource }(ArrayResource)); CubeResource.SIDES = 6; var SVGResource = (function (BaseImageResource) { function SVGResource (source, options) { options = options || {}, BaseImageResource.call(this, document.createElement('canvas')), this.svg = source, this.scale = options.scale || 1, this._resolve = null, this._crossorigin = options.crossorigin, this._load = null, !1 !== options.autoLoad && this.load() } return BaseImageResource && (SVGResource.__proto__ = BaseImageResource), ((SVGResource.prototype = Object.create(BaseImageResource && BaseImageResource.prototype)).constructor = SVGResource).prototype.load = function () { var this$1 = this; return this._load || (this._load = new Promise(function (resolve) { if (this$1._resolve = function () { this$1.resize(this$1.source.width, this$1.source.height), resolve(this$1) }, /^\<svg/.test(this$1.svg.trim())) { if (!btoa) throw new Error("Your browser doesn't support base64 conversions."); this$1.svg = 'data:image/svg+xml;base64,' + btoa(unescape(encodeURIComponent(this$1.svg))) }this$1._loadSvg() })), this._load }, SVGResource.prototype._loadSvg = function () { var this$1 = this; var tempImage = new Image(); BaseImageResource.crossOrigin(tempImage, this.svg, this._crossorigin), tempImage.src = this.svg, tempImage.onload = function () { var svgWidth = tempImage.width; var svgHeight = tempImage.height; if (!svgWidth || !svgHeight) throw new Error('The SVG image must have width and height defined (in pixels), canvas API needs them.'); var width = Math.round(svgWidth * this$1.scale); var height = Math.round(svgHeight * this$1.scale); var canvas = this$1.source; canvas.width = width, canvas.height = height, canvas._pixiId = 'canvas_' + uid(), canvas.getContext('2d').drawImage(tempImage, 0, 0, svgWidth, svgHeight, 0, 0, width, height), this$1._resolve(), this$1._resolve = null } }, SVGResource.getSize = function (svgString) { var sizeMatch = SVGResource.SVG_SIZE.exec(svgString); var size = {}; return sizeMatch && (size[sizeMatch[1]] = Math.round(parseFloat(sizeMatch[3])), size[sizeMatch[5]] = Math.round(parseFloat(sizeMatch[7]))), size }, SVGResource.prototype.dispose = function () { BaseImageResource.prototype.dispose.call(this), this._resolve = null, this._crossorigin = null }, SVGResource.test = function (source, extension) { return extension === 'svg' || typeof source === 'string' && source.indexOf('data:image/svg+xml;base64') === 0 || typeof source === 'string' && source.indexOf('<svg') === 0 }, SVGResource }(BaseImageResource)); SVGResource.SVG_SIZE = /<svg[^>]*(?:\s(width|height)=('|")(\d*(?:\.\d+)?)(?:px)?('|"))[^>]*(?:\s(width|height)=('|")(\d*(?:\.\d+)?)(?:px)?('|"))[^>]*>/i; var VideoResource = (function (BaseImageResource) { function VideoResource (source, options) { if (options = options || {}, !(source instanceof HTMLVideoElement)) { var videoElement = document.createElement('video'); videoElement.setAttribute('webkit-playsinline', ''), videoElement.setAttribute('playsinline', ''), typeof source === 'string' && (source = [source]), BaseImageResource.crossOrigin(videoElement, source[0].src || source[0], options.crossorigin); for (var i = 0; i < source.length; ++i) { var sourceElement = document.createElement('source'); var ref = source[i]; var src = ref.src; var mime = ref.mime; var baseSrc = (src = src || source[i]).split('?').shift().toLowerCase(); var ext = baseSrc.substr(baseSrc.lastIndexOf('.') + 1); mime = mime || 'video/' + ext, sourceElement.src = src, sourceElement.type = mime, videoElement.appendChild(sourceElement) }source = videoElement }BaseImageResource.call(this, source), this._autoUpdate = !0, this._isAutoUpdating = !1, this._updateFPS = options.updateFPS || 0, this._msToNextUpdate = 0, this.autoPlay = !1 !== options.autoPlay, this._load = null, this._resolve = null, this._onCanPlay = this._onCanPlay.bind(this), !1 !== options.autoLoad && this.load() }BaseImageResource && (VideoResource.__proto__ = BaseImageResource); var prototypeAccessors = { autoUpdate: { configurable: !0 }, updateFPS: { configurable: !0 } }; return ((VideoResource.prototype = Object.create(BaseImageResource && BaseImageResource.prototype)).constructor = VideoResource).prototype.update = function (deltaTime) { if (void 0 === deltaTime && (deltaTime = 0), !this.destroyed) { var elapsedMS = Ticker.shared.elapsedMS * this.source.playbackRate; this._msToNextUpdate = Math.floor(this._msToNextUpdate - elapsedMS), (!this._updateFPS || this._msToNextUpdate <= 0) && (BaseImageResource.prototype.update.call(this, deltaTime), this._msToNextUpdate = this._updateFPS ? Math.floor(1e3 / this._updateFPS) : 0) } }, VideoResource.prototype.load = function () { var this$1 = this; if (this._load) return this._load; var source = this.source; return (source.readyState === source.HAVE_ENOUGH_DATA || source.readyState === source.HAVE_FUTURE_DATA) && source.width && source.height && (source.complete = !0), source.addEventListener('play', this._onPlayStart.bind(this)), source.addEventListener('pause', this._onPlayStop.bind(this)), this._isSourceReady() ? this._onCanPlay() : (source.addEventListener('canplay', this._onCanPlay), source.addEventListener('canplaythrough', this._onCanPlay)), this._load = new Promise(function (resolve) { this$1.valid ? resolve(this$1) : (this$1._resolve = resolve, source.load()) }), this._load }, VideoResource.prototype._isSourcePlaying = function () { var source = this.source; return source.currentTime > 0 && !1 === source.paused && !1 === source.ended && source.readyState > 2 }, VideoResource.prototype._isSourceReady = function () { return this.source.readyState === 3 || this.source.readyState === 4 }, VideoResource.prototype._onPlayStart = function () { this.valid || this._onCanPlay(), !this._isAutoUpdating && this.autoUpdate && (Ticker.shared.add(this.update, this), this._isAutoUpdating = !0) }, VideoResource.prototype._onPlayStop = function () { this._isAutoUpdating && (Ticker.shared.remove(this.update, this), this._isAutoUpdating = !1) }, VideoResource.prototype._onCanPlay = function () { var source = this.source; source.removeEventListener('canplay', this._onCanPlay), source.removeEventListener('canplaythrough', this._onCanPlay); var valid = this.valid; this.resize(source.videoWidth, source.videoHeight), !valid && this._resolve && (this._resolve(this), this._resolve = null), this._isSourcePlaying() ? this._onPlayStart() : this.autoPlay && source.play() }, VideoResource.prototype.dispose = function () { this._isAutoUpdating && Ticker.shared.remove(this.update, this), this.source && (this.source.pause(), this.source.src = '', this.source.load()), BaseImageResource.prototype.dispose.call(this) }, prototypeAccessors.autoUpdate.get = function () { return this._autoUpdate }, prototypeAccessors.autoUpdate.set = function (value) { value !== this._autoUpdate && (this._autoUpdate = value, !this._autoUpdate && this._isAutoUpdating ? (Ticker.shared.remove(this.update, this), this._isAutoUpdating = !1) : this._autoUpdate && !this._isAutoUpdating && (Ticker.shared.add(this.update, this), this._isAutoUpdating = !0)) }, prototypeAccessors.updateFPS.get = function () { return this._updateFPS }, prototypeAccessors.updateFPS.set = function (value) { value !== this._updateFPS && (this._updateFPS = value) }, VideoResource.test = function (source, extension) { return source instanceof HTMLVideoElement || VideoResource.TYPES.indexOf(extension) > -1 }, Object.defineProperties(VideoResource.prototype, prototypeAccessors), VideoResource }(BaseImageResource)); VideoResource.TYPES = ['mp4', 'm4v', 'webm', 'ogg', 'ogv', 'h264', 'avi', 'mov'], INSTALLED.push(ImageResource, CanvasResource, VideoResource, SVGResource, BufferResource, CubeResource, ArrayResource); var index = { INSTALLED: INSTALLED, autoDetectResource: autoDetectResource, ArrayResource: ArrayResource, BufferResource: BufferResource, CanvasResource: CanvasResource, CubeResource: CubeResource, ImageResource: ImageResource, SVGResource: SVGResource, VideoResource: VideoResource, Resource: Resource, BaseImageResource: BaseImageResource }; var System = function (renderer) { this.renderer = renderer, this.renderer.runners.contextChange.add(this) }; System.prototype.contextChange = function (gl) {}, System.prototype.destroy = function () { this.renderer.runners.contextChange.remove(this), this.renderer = null }; var DepthResource = (function (BufferResource) { function DepthResource () { BufferResource.apply(this, arguments) } return BufferResource && (DepthResource.__proto__ = BufferResource), ((DepthResource.prototype = Object.create(BufferResource && BufferResource.prototype)).constructor = DepthResource).prototype.upload = function (renderer, baseTexture, glTexture) { var gl = renderer.gl; return gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, baseTexture.premultiplyAlpha), glTexture.width === baseTexture.width && glTexture.height === baseTexture.height ? gl.texSubImage2D(baseTexture.target, 0, 0, 0, baseTexture.width, baseTexture.height, baseTexture.format, baseTexture.type, this.data) : (glTexture.width = baseTexture.width, glTexture.height = baseTexture.height, gl.texImage2D(baseTexture.target, 0, gl.DEPTH_COMPONENT16, baseTexture.width, baseTexture.height, 0, baseTexture.format, baseTexture.type, this.data)), !0 }, DepthResource }(BufferResource)); var Framebuffer = function (width, height) { this.width = Math.ceil(width || 100), this.height = Math.ceil(height || 100), this.stencil = !1, this.depth = !1, this.dirtyId = 0, this.dirtyFormat = 0, this.dirtySize = 0, this.depthTexture = null, this.colorTextures = [], this.glFramebuffers = {}, this.disposeRunner = new Runner('disposeFramebuffer', 2) }; var prototypeAccessors$1$2 = { colorTexture: { configurable: !0 } }; prototypeAccessors$1$2.colorTexture.get = function () { return this.colorTextures[0] }, Framebuffer.prototype.addColorTexture = function (index, texture) { return void 0 === index && (index = 0), this.colorTextures[index] = texture || new BaseTexture(null, { scaleMode: 0, resolution: 1, mipmap: !1, width: this.width, height: this.height }), this.dirtyId++, this.dirtyFormat++, this }, Framebuffer.prototype.addDepthTexture = function (texture) { return this.depthTexture = texture || new BaseTexture(new DepthResource(null, { width: this.width, height: this.height }), { scaleMode: 0, resolution: 1, width: this.width, height: this.height, mipmap: !1, format: FORMATS.DEPTH_COMPONENT, type: TYPES.UNSIGNED_SHORT }), this.dirtyId++, this.dirtyFormat++, this }, Framebuffer.prototype.enableDepth = function () { return this.depth = !0, this.dirtyId++, this.dirtyFormat++, this }, Framebuffer.prototype.enableStencil = function () { return this.stencil = !0, this.dirtyId++, this.dirtyFormat++, this }, Framebuffer.prototype.resize = function (width, height) { if (width = Math.ceil(width), height = Math.ceil(height), width !== this.width || height !== this.height) { this.width = width, this.height = height, this.dirtyId++, this.dirtySize++; for (var i = 0; i < this.colorTextures.length; i++) { var texture = this.colorTextures[i]; var resolution = texture.resolution; texture.setSize(width / resolution, height / resolution) } if (this.depthTexture) { var resolution$1 = this.depthTexture.resolution; this.depthTexture.setSize(width / resolution$1, height / resolution$1) } } }, Framebuffer.prototype.dispose = function () { this.disposeRunner.run(this, !1) }, Object.defineProperties(Framebuffer.prototype, prototypeAccessors$1$2); var BaseRenderTexture = (function (BaseTexture) { function BaseRenderTexture (options) { typeof options === 'number' && (options = { width: arguments[0], height: arguments[1], scaleMode: arguments[2], resolution: arguments[3] }); BaseTexture.call(this, null, options); var ref = options || {}; var width = ref.width; var height = ref.height; this.mipmap = !1, this.width = Math.ceil(width) || 100, this.height = Math.ceil(height) || 100, this.valid = !0, this._canvasRenderTarget = null, this.clearColor = [0, 0, 0, 0], this.framebuffer = new Framebuffer(this.width * this.resolution, this.height * this.resolution).addColorTexture(0, this).enableStencil(), this.stencilMaskStack = [], this.filterStack = [{}] } return BaseTexture && (BaseRenderTexture.__proto__ = BaseTexture), ((BaseRenderTexture.prototype = Object.create(BaseTexture && BaseTexture.prototype)).constructor = BaseRenderTexture).prototype.resize = function (width, height) { width = Math.ceil(width), height = Math.ceil(height), this.framebuffer.resize(width * this.resolution, height * this.resolution) }, BaseRenderTexture.prototype.dispose = function () { this.framebuffer.dispose(), BaseTexture.prototype.dispose.call(this) }, BaseRenderTexture.prototype.destroy = function () { BaseTexture.prototype.destroy.call(this, !0), this.framebuffer = null, this.renderer = null }, BaseRenderTexture }(BaseTexture)); var TextureUvs = function () { this.x0 = 0, this.y0 = 0, this.x1 = 1, this.y1 = 0, this.x2 = 1, this.y2 = 1, this.x3 = 0, this.y3 = 1, this.uvsFloat32 = new Float32Array(8) }; TextureUvs.prototype.set = function (frame, baseFrame, rotate) { var tw = baseFrame.width; var th = baseFrame.height; if (rotate) { var w2 = frame.width / 2 / tw; var h2 = frame.height / 2 / th; var cX = frame.x / tw + w2; var cY = frame.y / th + h2; rotate = GroupD8.add(rotate, GroupD8.NW), this.x0 = cX + w2 * GroupD8.uX(rotate), this.y0 = cY + h2 * GroupD8.uY(rotate), rotate = GroupD8.add(rotate, 2), this.x1 = cX + w2 * GroupD8.uX(rotate), this.y1 = cY + h2 * GroupD8.uY(rotate), rotate = GroupD8.add(rotate, 2), this.x2 = cX + w2 * GroupD8.uX(rotate), this.y2 = cY + h2 * GroupD8.uY(rotate), rotate = GroupD8.add(rotate, 2), this.x3 = cX + w2 * GroupD8.uX(rotate), this.y3 = cY + h2 * GroupD8.uY(rotate) } else this.x0 = frame.x / tw, this.y0 = frame.y / th, this.x1 = (frame.x + frame.width) / tw, this.y1 = frame.y / th, this.x2 = (frame.x + frame.width) / tw, this.y2 = (frame.y + frame.height) / th, this.x3 = frame.x / tw, this.y3 = (frame.y + frame.height) / th; this.uvsFloat32[0] = this.x0, this.uvsFloat32[1] = this.y0, this.uvsFloat32[2] = this.x1, this.uvsFloat32[3] = this.y1, this.uvsFloat32[4] = this.x2, this.uvsFloat32[5] = this.y2, this.uvsFloat32[6] = this.x3, this.uvsFloat32[7] = this.y3 }; var DEFAULT_UVS = new TextureUvs(); var Texture = (function (EventEmitter) { function Texture (baseTexture, frame, orig, trim, rotate, anchor) { if (EventEmitter.call(this), this.noFrame = !1, frame || (this.noFrame = !0, frame = new Rectangle(0, 0, 1, 1)), baseTexture instanceof Texture && (baseTexture = baseTexture.baseTexture), this.baseTexture = baseTexture, this._frame = frame, this.trim = trim, this.valid = !1, this.requiresUpdate = !1, this._uvs = DEFAULT_UVS, this.uvMatrix = null, this.orig = orig || frame, this._rotate = Number(rotate || 0), !0 === rotate) this._rotate = 2; else if (this._rotate % 2 != 0) throw new Error('attempt to use diamond-shaped UVs. If you are sure, set rotation manually'); this.defaultAnchor = anchor ? new Point(anchor.x, anchor.y) : new Point(0, 0), this._updateID = 0, this.textureCacheIds = [], baseTexture.valid ? this.noFrame ? baseTexture.valid && this.onBaseTextureUpdated(baseTexture) : this.frame = frame : baseTexture.once('loaded', this.onBaseTextureUpdated, this), this.noFrame && baseTexture.on('update', this.onBaseTextureUpdated, this) }EventEmitter && (Texture.__proto__ = EventEmitter); var prototypeAccessors = { frame: { configurable: !0 }, rotate: { configurable: !0 }, width: { configurable: !0 }, height: { configurable: !0 } }; return ((Texture.prototype = Object.create(EventEmitter && EventEmitter.prototype)).constructor = Texture).prototype.update = function () { this.baseTexture.resource && this.baseTexture.resource.update() }, Texture.prototype.onBaseTextureUpdated = function (baseTexture) { if (this.noFrame) { if (!this.baseTexture.valid) return; this._frame.width = baseTexture.width, this._frame.height = baseTexture.height, this.valid = !0, this.updateUvs() } else this.frame = this._frame; this.emit('update', this) }, Texture.prototype.destroy = function (destroyBase) { if (this.baseTexture) { if (destroyBase) { var resource = this.baseTexture.resource; resource && TextureCache[resource.url] && Texture.removeFromCache(resource.url), this.baseTexture.destroy() } this.baseTexture.off('update', this.onBaseTextureUpdated, this), this.baseTexture = null } this._frame = null, this._uvs = null, this.trim = null, this.orig = null, this.valid = !1, Texture.removeFromCache(this), this.textureCacheIds = null }, Texture.prototype.clone = function () { return new Texture(this.baseTexture, this.frame, this.orig, this.trim, this.rotate, this.defaultAnchor) }, Texture.prototype.updateUvs = function () { this._uvs === DEFAULT_UVS && (this._uvs = new TextureUvs()), this._uvs.set(this._frame, this.baseTexture, this.rotate), this._updateID++ }, Texture.from = function (source, options) { void 0 === options && (options = {}); var cacheId = null; cacheId = typeof source === 'string' ? source : (source._pixiId || (source._pixiId = 'pixiid_' + uid()), source._pixiId); var texture = TextureCache[cacheId]; return texture || (options.resolution || (options.resolution = getResolutionOfUrl(source)), (texture = new Texture(new BaseTexture(source, options))).baseTexture.cacheId = cacheId, BaseTexture.addToCache(texture.baseTexture, cacheId), Texture.addToCache(texture, cacheId)), texture }, Texture.fromBuffer = function (buffer, width, height, options) { return new Texture(BaseTexture.fromBuffer(buffer, width, height, options)) }, Texture.fromLoader = function (source, imageUrl, name) { var resource = new ImageResource(source); resource.url = imageUrl; var texture = new Texture(new BaseTexture(resource, { scaleMode: settings.SCALE_MODE, resolution: getResolutionOfUrl(imageUrl) })); return name = name || imageUrl, BaseTexture.addToCache(texture.baseTexture, name), Texture.addToCache(texture, name), name !== imageUrl && (BaseTexture.addToCache(texture.baseTexture, imageUrl), Texture.addToCache(texture, imageUrl)), texture }, Texture.addToCache = function (texture, id) { id && (texture.textureCacheIds.indexOf(id) === -1 && texture.textureCacheIds.push(id), TextureCache[id] && console.warn('Texture added to the cache with an id [' + id + '] that already had an entry'), TextureCache[id] = texture) }, Texture.removeFromCache = function (texture) { if (typeof texture === 'string') { var textureFromCache = TextureCache[texture]; if (textureFromCache) { var index = textureFromCache.textureCacheIds.indexOf(texture); return index > -1 && textureFromCache.textureCacheIds.splice(index, 1), delete TextureCache[texture], textureFromCache } } else if (texture && texture.textureCacheIds) { for (var i = 0; i < texture.textureCacheIds.length; ++i)TextureCache[texture.textureCacheIds[i]] === texture && delete TextureCache[texture.textureCacheIds[i]]; return texture.textureCacheIds.length = 0, texture } return null }, prototypeAccessors.frame.get = function () { return this._frame }, prototypeAccessors.frame.set = function (frame) { this._frame = frame, this.noFrame = !1; var x = frame.x; var y = frame.y; var width = frame.width; var height = frame.height; var xNotFit = x + width > this.baseTexture.width; var yNotFit = y + height > this.baseTexture.height; if (xNotFit || yNotFit) { var relationship = xNotFit && yNotFit ? 'and' : 'or'; var errorX = 'X: ' + x + ' + ' + width + ' = ' + (x + width) + ' > ' + this.baseTexture.width; var errorY = 'Y: ' + y + ' + ' + height + ' = ' + (y + height) + ' > ' + this.baseTexture.height; throw new Error('Texture Error: frame does not fit inside the base Texture dimensions: ' + errorX + ' ' + relationship + ' ' + errorY) } this.valid = width && height && this.baseTexture.valid, this.trim || this.rotate || (this.orig = frame), this.valid && this.updateUvs() }, prototypeAccessors.rotate.get = function () { return this._rotate }, prototypeAccessors.rotate.set = function (rotate) { this._rotate = rotate, this.valid && this.updateUvs() }, prototypeAccessors.width.get = function () { return this.orig.width }, prototypeAccessors.height.get = function () { return this.orig.height }, Object.defineProperties(Texture.prototype, prototypeAccessors), Texture }(eventemitter3)); function removeAllHandlers (tex) { tex.destroy = function () {}, tex.on = function () {}, tex.once = function () {}, tex.emit = function () {} }Texture.EMPTY = new Texture(new BaseTexture()), removeAllHandlers(Texture.EMPTY), removeAllHandlers(Texture.EMPTY.baseTexture), Texture.WHITE = (function () { var canvas = document.createElement('canvas'); canvas.width = 16, canvas.height = 16; var context = canvas.getContext('2d'); return context.fillStyle = 'white', context.fillRect(0, 0, 16, 16), new Texture(new BaseTexture(new CanvasResource(canvas))) }()), removeAllHandlers(Texture.WHITE), removeAllHandlers(Texture.WHITE.baseTexture); var RenderTexture = (function (Texture) { function RenderTexture (baseRenderTexture, frame) { var _legacyRenderer = null; if (!(baseRenderTexture instanceof BaseRenderTexture)) { var width = arguments[1]; var height = arguments[2]; var scaleMode = arguments[3]; var resolution = arguments[4]; console.warn('Please use RenderTexture.create(' + width + ', ' + height + ') instead of the ctor directly.'), _legacyRenderer = arguments[0], frame = null, baseRenderTexture = new BaseRenderTexture({ width: width, height: height, scaleMode: scaleMode, resolution: resolution }) }Texture.call(this, baseRenderTexture, frame), this.legacyRenderer = _legacyRenderer, this.valid = !0, this.filterFrame = null, this.filterPoolKey = null, this.updateUvs() } return Texture && (RenderTexture.__proto__ = Texture), ((RenderTexture.prototype = Object.create(Texture && Texture.prototype)).constructor = RenderTexture).prototype.resize = function (width, height, resizeBaseTexture) { void 0 === resizeBaseTexture && (resizeBaseTexture = !0), width = Math.ceil(width), height = Math.ceil(height), this.valid = width > 0 && height > 0, this._frame.width = this.orig.width = width, this._frame.height = this.orig.height = height, resizeBaseTexture && this.baseTexture.resize(width, height), this.updateUvs() }, RenderTexture.prototype.setResolution = function (resolution) { var baseTexture = this.baseTexture; baseTexture.resolution !== resolution && (baseTexture.setResolution(resolution), this.resize(baseTexture.width, baseTexture.height, !1)) }, RenderTexture.create = function (options, argument_1, argument_2, argument_3) { return typeof options === 'number' && (options = { width: options, height: argument_1, scaleMode: argument_2, resolution: argument_3 }), new RenderTexture(new BaseRenderTexture(options)) }, RenderTexture }(Texture)); var Attribute = function (buffer, size, normalized, type, stride, start, instance) { void 0 === normalized && (normalized = !1), void 0 === type && (type = 5126), this.buffer = buffer, this.size = size, this.normalized = normalized, this.type = type, this.stride = stride, this.start = start, this.instance = instance }; Attribute.prototype.destroy = function () { this.buffer = null }, Attribute.from = function (buffer, size, normalized, type, stride) { return new Attribute(buffer, size, normalized, type, stride) }; var UID = 0; var Buffer = function (data, _static, index) { void 0 === _static && (_static = !0), void 0 === index && (index = !1), this.data = data || new Float32Array(1), this._glBuffers = {}, this._updateID = 0, this.index = index, this.static = _static, this.id = UID++, this.disposeRunner = new Runner('disposeBuffer', 2) }; function getBufferType (array) { if (array.BYTES_PER_ELEMENT === 4) return array instanceof Float32Array ? 'Float32Array' : array instanceof Uint32Array ? 'Uint32Array' : 'Int32Array'; if (array.BYTES_PER_ELEMENT === 2) { if (array instanceof Uint16Array) return 'Uint16Array' } else if (array.BYTES_PER_ELEMENT === 1 && array instanceof Uint8Array) return 'Uint8Array'; return null }Buffer.prototype.update = function (data) { this.data = data || this.data, this._updateID++ }, Buffer.prototype.dispose = function () { this.disposeRunner.run(this, !1) }, Buffer.prototype.destroy = function () { this.dispose(), this.data = null }, Buffer.from = function (data) { return data instanceof Array && (data = new Float32Array(data)), new Buffer(data) }; var map = { Float32Array: Float32Array, Uint32Array: Uint32Array, Int32Array: Int32Array, Uint8Array: Uint8Array }; var byteSizeMap = { 5126: 4, 5123: 2, 5121: 1 }; var UID$1 = 0; var map$1 = { Float32Array: Float32Array, Uint32Array: Uint32Array, Int32Array: Int32Array, Uint8Array: Uint8Array, Uint16Array: Uint16Array }; var Geometry = function (buffers, attributes) { void 0 === buffers && (buffers = []), void 0 === attributes && (attributes = {}), this.buffers = buffers, this.indexBuffer = null, this.attributes = attributes, this.glVertexArrayObjects = {}, this.id = UID$1++, this.instanced = !1, this.instanceCount = 1, this._size = null, this.disposeRunner = new Runner('disposeGeometry', 2), this.refCount = 0 }; Geometry.prototype.addAttribute = function (id, buffer, size, normalized, type, stride, start, instance) { if (void 0 === normalized && (normalized = !1), void 0 === instance && (instance = !1), !buffer) throw new Error('You must pass a buffer when creating an attribute'); buffer.data || (buffer instanceof Array && (buffer = new Float32Array(buffer)), buffer = new Buffer(buffer)); var ids = id.split('|'); if (ids.length > 1) { for (var i = 0; i < ids.length; i++) this.addAttribute(ids[i], buffer, size, normalized, type); return this } var bufferIndex = this.buffers.indexOf(buffer); return bufferIndex === -1 && (this.buffers.push(buffer), bufferIndex = this.buffers.length - 1), this.attributes[id] = new Attribute(bufferIndex, size, normalized, type, stride, start, instance), this.instanced = this.instanced || instance, this }, Geometry.prototype.getAttribute = function (id) { return this.attributes[id] }, Geometry.prototype.getBuffer = function (id) { return this.buffers[this.getAttribute(id).buffer] }, Geometry.prototype.addIndex = function (buffer) { return buffer.data || (buffer instanceof Array && (buffer = new Uint16Array(buffer)), buffer = new Buffer(buffer)), buffer.index = !0, this.indexBuffer = buffer, this.buffers.indexOf(buffer) === -1 && this.buffers.push(buffer), this }, Geometry.prototype.getIndex = function () { return this.indexBuffer }, Geometry.prototype.interleave = function () { if (this.buffers.length === 1 || this.buffers.length === 2 && this.indexBuffer) return this; var i; var arrays = []; var sizes = []; var interleavedBuffer = new Buffer(); for (i in this.attributes) { var attribute = this.attributes[i]; var buffer = this.buffers[attribute.buffer]; arrays.push(buffer.data), sizes.push(attribute.size * byteSizeMap[attribute.type] / 4), attribute.buffer = 0 } for (interleavedBuffer.data = (function (arrays, sizes) { for (var outSize = 0, stride = 0, views = {}, i = 0; i < arrays.length; i++)stride += sizes[i], outSize += arrays[i].length; for (var buffer = new ArrayBuffer(4 * outSize), out = null, littleOffset = 0, i$1 = 0; i$1 < arrays.length; i$1++) { var size = sizes[i$1]; var array = arrays[i$1]; var type = getBufferType(array); views[type] || (views[type] = new map[type](buffer)), out = views[type]; for (var j = 0; j < array.length; j++) { out[(j / size | 0) * stride + littleOffset + j % size] = array[j] }littleOffset += size } return new Float32Array(buffer) }(arrays, sizes)), i = 0; i < this.buffers.length; i++) this.buffers[i] !== this.indexBuffer && this.buffers[i].destroy(); return this.buffers = [interleavedBuffer], this.indexBuffer && this.buffers.push(this.indexBuffer), this }, Geometry.prototype.getSize = function () { for (var i in this.attributes) { var attribute = this.attributes[i]; return this.buffers[attribute.buffer].data.length / (attribute.stride / 4 || attribute.size) } return 0 }, Geometry.prototype.dispose = function () { this.disposeRunner.run(this, !1) }, Geometry.prototype.destroy = function () { this.dispose(), this.buffers = null, this.indexBuffer.destroy(), this.attributes = null }, Geometry.prototype.clone = function () { for (var geometry = new Geometry(), i = 0; i < this.buffers.length; i++)geometry.buffers[i] = new Buffer(this.buffers[i].data.slice()); for (var i$1 in this.attributes) { var attrib = this.attributes[i$1]; geometry.attributes[i$1] = new Attribute(attrib.buffer, attrib.size, attrib.normalized, attrib.type, attrib.stride, attrib.start, attrib.instance) } return this.indexBuffer && (geometry.indexBuffer = geometry.buffers[this.buffers.indexOf(this.indexBuffer)], geometry.indexBuffer.index = !0), geometry }, Geometry.merge = function (geometries) { for (var geometry, geometryOut = new Geometry(), arrays = [], sizes = [], offsets = [], i = 0; i < geometries.length; i++) { geometry = geometries[i]; for (var j = 0; j < geometry.buffers.length; j++)sizes[j] = sizes[j] || 0, sizes[j] += geometry.buffers[j].data.length, offsets[j] = 0 } for (var i$1 = 0; i$1 < geometry.buffers.length; i$1++)arrays[i$1] = new (map$1[getBufferType(geometry.buffers[i$1].data)])(sizes[i$1]), geometryOut.buffers[i$1] = new Buffer(arrays[i$1]); for (var i$2 = 0; i$2 < geometries.length; i$2++) { geometry = geometries[i$2]; for (var j$1 = 0; j$1 < geometry.buffers.length; j$1++)arrays[j$1].set(geometry.buffers[j$1].data, offsets[j$1]), offsets[j$1] += geometry.buffers[j$1].data.length } if (geometryOut.attributes = geometry.attributes, geometry.indexBuffer) { geometryOut.indexBuffer = geometryOut.buffers[geometry.buffers.indexOf(geometry.indexBuffer)], geometryOut.indexBuffer.index = !0; for (var offset = 0, stride = 0, offset2 = 0, bufferIndexToCount = 0, i$3 = 0; i$3 < geometry.buffers.length; i$3++) if (geometry.buffers[i$3] !== geometry.indexBuffer) { bufferIndexToCount = i$3; break } for (var i$4 in geometry.attributes) { var attribute = geometry.attributes[i$4]; (0 | attribute.buffer) === bufferIndexToCount && (stride += attribute.size * byteSizeMap[attribute.type] / 4) } for (var i$5 = 0; i$5 < geometries.length; i$5++) { for (var indexBufferData = geometries[i$5].indexBuffer.data, j$2 = 0; j$2 < indexBufferData.length; j$2++)geometryOut.indexBuffer.data[j$2 + offset2] += offset; offset += geometry.buffers[bufferIndexToCount].data.length / stride, offset2 += indexBufferData.length } } return geometryOut }; var Quad = (function (Geometry) { function Quad () { Geometry.call(this), this.addAttribute('aVertexPosition', [0, 0, 1, 0, 1, 1, 0, 1]).addIndex([0, 1, 3, 2]) } return Geometry && (Quad.__proto__ = Geometry), (Quad.prototype = Object.create(Geometry && Geometry.prototype)).constructor = Quad }(Geometry)); var QuadUv = (function (Geometry) { function QuadUv () { Geometry.call(this), this.vertices = new Float32Array([-1, -1, 1, -1, 1, 1, -1, 1]), this.uvs = new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]), this.vertexBuffer = new Buffer(this.vertices), this.uvBuffer = new Buffer(this.uvs), this.addAttribute('aVertexPosition', this.vertexBuffer).addAttribute('aTextureCoord', this.uvBuffer).addIndex([0, 1, 2, 0, 2, 3]) } return Geometry && (QuadUv.__proto__ = Geometry), ((QuadUv.prototype = Object.create(Geometry && Geometry.prototype)).constructor = QuadUv).prototype.map = function (targetTextureFrame, destinationFrame) { var x = 0; var y = 0; return this.uvs[0] = x, this.uvs[1] = y, this.uvs[2] = x + destinationFrame.width / targetTextureFrame.width, this.uvs[3] = y, this.uvs[4] = x + destinationFrame.width / targetTextureFrame.width, this.uvs[5] = y + destinationFrame.height / targetTextureFrame.height, this.uvs[6] = x, this.uvs[7] = y + destinationFrame.height / targetTextureFrame.height, x = destinationFrame.x, y = destinationFrame.y, this.vertices[0] = x, this.vertices[1] = y, this.vertices[2] = x + destinationFrame.width, this.vertices[3] = y, this.vertices[4] = x + destinationFrame.width, this.vertices[5] = y + destinationFrame.height, this.vertices[6] = x, this.vertices[7] = y + destinationFrame.height, this.invalidate(), this }, QuadUv.prototype.invalidate = function () { return this.vertexBuffer._updateID++, this.uvBuffer._updateID++, this }, QuadUv }(Geometry)); var UID$2 = 0; var UniformGroup = function (uniforms, _static) { this.uniforms = uniforms, this.group = !0, this.syncUniforms = {}, this.dirtyId = 0, this.id = UID$2++, this.static = !!_static }; UniformGroup.prototype.update = function () { this.dirtyId++ }, UniformGroup.prototype.add = function (name, uniforms, _static) { this.uniforms[name] = new UniformGroup(uniforms, _static) }, UniformGroup.from = function (uniforms, _static) { return new UniformGroup(uniforms, _static) }; var FilterState = function () { this.renderTexture = null, this.target = null, this.legacy = !1, this.resolution = 1, this.sourceFrame = new Rectangle(), this.destinationFrame = new Rectangle(), this.filters = [] }; FilterState.prototype.clear = function () { this.target = null, this.filters = null, this.renderTexture = null }; var FilterSystem = (function (System) { function FilterSystem (renderer) { System.call(this, renderer), this.defaultFilterStack = [{}], this.texturePool = {}, this.statePool = [], this.quad = new Quad(), this.quadUv = new QuadUv(), this.tempRect = new Rectangle(), this.activeState = {}, this.globalUniforms = new UniformGroup({ outputFrame: this.tempRect, inputSize: new Float32Array(4), inputPixel: new Float32Array(4), inputClamp: new Float32Array(4), resolution: 1, filterArea: new Float32Array(4), filterClamp: new Float32Array(4) }, !0), this._pixelsWidth = renderer.view.width, this._pixelsHeight = renderer.view.height } return System && (FilterSystem.__proto__ = System), ((FilterSystem.prototype = Object.create(System && System.prototype)).constructor = FilterSystem).prototype.push = function (target, filters) { for (var renderer = this.renderer, filterStack = this.defaultFilterStack, state = this.statePool.pop() || new FilterState(), resolution = filters[0].resolution, padding = filters[0].padding, autoFit = filters[0].autoFit, legacy = filters[0].legacy, i = 1; i < filters.length; i++) { var filter = filters[i]; resolution = Math.min(resolution, filter.resolution), padding = Math.max(padding, filter.padding), autoFit = autoFit || filter.autoFit, legacy = legacy || filter.legacy }filterStack.length === 1 && (this.defaultFilterStack[0].renderTexture = renderer.renderTexture.current), filterStack.push(state), state.resolution = resolution, state.legacy = legacy, state.target = target, state.sourceFrame.copyFrom(target.filterArea || target.getBounds(!0)), state.sourceFrame.pad(padding), autoFit && state.sourceFrame.fit(this.renderer.renderTexture.sourceFrame), state.sourceFrame.ceil(resolution), state.renderTexture = this.getOptimalFilterTexture(state.sourceFrame.width, state.sourceFrame.height, resolution), state.filters = filters, state.destinationFrame.width = state.renderTexture.width, state.destinationFrame.height = state.renderTexture.height, state.renderTexture.filterFrame = state.sourceFrame, renderer.renderTexture.bind(state.renderTexture, state.sourceFrame), renderer.renderTexture.clear() }, FilterSystem.prototype.pop = function () { var filterStack = this.defaultFilterStack; var state = filterStack.pop(); var filters = state.filters; this.activeState = state; var globalUniforms = this.globalUniforms.uniforms; globalUniforms.outputFrame = state.sourceFrame, globalUniforms.resolution = state.resolution; var inputSize = globalUniforms.inputSize; var inputPixel = globalUniforms.inputPixel; var inputClamp = globalUniforms.inputClamp; if (inputSize[0] = state.destinationFrame.width, inputSize[1] = state.destinationFrame.height, inputSize[2] = 1 / inputSize[0], inputSize[3] = 1 / inputSize[1], inputPixel[0] = inputSize[0] * state.resolution, inputPixel[1] = inputSize[1] * state.resolution, inputPixel[2] = 1 / inputPixel[0], inputPixel[3] = 1 / inputPixel[1], inputClamp[0] = 0.5 * inputPixel[2], inputClamp[1] = 0.5 * inputPixel[3], inputClamp[2] = state.sourceFrame.width * inputSize[2] - 0.5 * inputPixel[2], inputClamp[3] = state.sourceFrame.height * inputSize[3] - 0.5 * inputPixel[3], state.legacy) { var filterArea = globalUniforms.filterArea; filterArea[0] = state.destinationFrame.width, filterArea[1] = state.destinationFrame.height, filterArea[2] = state.sourceFrame.x, filterArea[3] = state.sourceFrame.y, globalUniforms.filterClamp = globalUniforms.inputClamp } this.globalUniforms.update(); var lastState = filterStack[filterStack.length - 1]; if (filters.length === 1)filters[0].apply(this, state.renderTexture, lastState.renderTexture, !1, state), this.returnFilterTexture(state.renderTexture); else { var flip = state.renderTexture; var flop = this.getOptimalFilterTexture(flip.width, flip.height, state.resolution); flop.filterFrame = flip.filterFrame; var i = 0; for (i = 0; i < filters.length - 1; ++i) { filters[i].apply(this, flip, flop, !0, state); var t = flip; flip = flop, flop = t }filters[i].apply(this, flip, lastState.renderTexture, !1, state), this.returnFilterTexture(flip), this.returnFilterTexture(flop) }state.clear(), this.statePool.push(state) }, FilterSystem.prototype.applyFilter = function (filter, input, output, clear) { var renderer = this.renderer; renderer.renderTexture.bind(output, output ? output.filterFrame : null), clear && renderer.renderTexture.clear(), filter.uniforms.uSampler = input, filter.uniforms.filterGlobals = this.globalUniforms, renderer.state.setState(filter.state), renderer.shader.bind(filter), filter.legacy ? (this.quadUv.map(input._frame, input.filterFrame), renderer.geometry.bind(this.quadUv), renderer.geometry.draw(DRAW_MODES.TRIANGLES)) : (renderer.geometry.bind(this.quad), renderer.geometry.draw(DRAW_MODES.TRIANGLE_STRIP)) }, FilterSystem.prototype.calculateSpriteMatrix = function (outputMatrix, sprite) { var ref = this.activeState; var sourceFrame = ref.sourceFrame; var destinationFrame = ref.destinationFrame; var orig = sprite._texture.orig; var mappedMatrix = outputMatrix.set(destinationFrame.width, 0, 0, destinationFrame.height, sourceFrame.x, sourceFrame.y); var worldTransform = sprite.worldTransform.copyTo(Matrix.TEMP_MATRIX); return worldTransform.invert(), mappedMatrix.prepend(worldTransform), mappedMatrix.scale(1 / orig.width, 1 / orig.height), mappedMatrix.translate(sprite.anchor.x, sprite.anchor.y), mappedMatrix }, FilterSystem.prototype.destroy = function (contextLost) { void 0 === contextLost && (contextLost = !1), contextLost ? this.texturePool = {} : this.emptyPool() }, FilterSystem.prototype.getOptimalFilterTexture = function (minWidth, minHeight, resolution) { void 0 === resolution && (resolution = 1); var key = 'screen'; minHeight *= resolution, (minWidth *= resolution) === this._pixelsWidth && minHeight === this._pixelsHeight || (key = (65535 & (minWidth = nextPow2(minWidth))) << 16 | 65535 & (minHeight = nextPow2(minHeight))), this.texturePool[key] || (this.texturePool[key] = []); var renderTexture = this.texturePool[key].pop(); return (renderTexture = renderTexture || RenderTexture.create({ width: minWidth, height: minHeight })).filterPoolKey = key, renderTexture.setResolution(resolution), renderTexture }, FilterSystem.prototype.getFilterTexture = function (resolution) { var rt = this.activeState.renderTexture; var filterTexture = this.getOptimalFilterTexture(rt.width, rt.height, resolution || rt.baseTexture.resolution); return filterTexture.filterFrame = rt.filterFrame, filterTexture }, FilterSystem.prototype.returnFilterTexture = function (renderTexture) { var key = renderTexture.filterPoolKey; renderTexture.filterFrame = null, this.texturePool[key].push(renderTexture) }, FilterSystem.prototype.emptyPool = function () { for (var i in this.texturePool) { var textures = this.texturePool[i]; if (textures) for (var j = 0; j < textures.length; j++)textures[j].destroy(!0) } this.texturePool = {} }, FilterSystem.prototype.resize = function () { var textures = this.texturePool.screen; if (textures) for (var j = 0; j < textures.length; j++)textures[j].destroy(!0); this.texturePool.screen = [], this._pixelsWidth = this.renderer.view.width, this._pixelsHeight = this.renderer.view.height }, FilterSystem }(System)); var ObjectRenderer = (function (System) { function ObjectRenderer () { System.apply(this, arguments) } return System && (ObjectRenderer.__proto__ = System), ((ObjectRenderer.prototype = Object.create(System && System.prototype)).constructor = ObjectRenderer).prototype.start = function () {}, ObjectRenderer.prototype.stop = function () { this.flush() }, ObjectRenderer.prototype.flush = function () {}, ObjectRenderer.prototype.render = function (object) {}, ObjectRenderer }(System)); var BatchSystem = (function (System) { function BatchSystem (renderer) { System.call(this, renderer), this.emptyRenderer = new ObjectRenderer(renderer), this.currentRenderer = this.emptyRenderer } return System && (BatchSystem.__proto__ = System), ((BatchSystem.prototype = Object.create(System && System.prototype)).constructor = BatchSystem).prototype.setObjectRenderer = function (objectRenderer) { this.currentRenderer !== objectRenderer && (this.currentRenderer.stop(), this.currentRenderer = objectRenderer, this.currentRenderer.start()) }, BatchSystem.prototype.flush = function () { this.setObjectRenderer(this.emptyRenderer) }, BatchSystem.prototype.reset = function () { this.setObjectRenderer(this.emptyRenderer) }, BatchSystem }(System)); settings.PREFER_ENV = isMobile_min.any ? ENV.WEBGL : ENV.WEBGL2; var CONTEXT_UID = 0; var ContextSystem = (function (System) { function ContextSystem (renderer) { System.call(this, renderer), this.webGLVersion = 1, this.extensions = {}, this.handleContextLost = this.handleContextLost.bind(this), this.handleContextRestored = this.handleContextRestored.bind(this), renderer.view.addEventListener('webglcontextlost', this.handleContextLost, !1), renderer.view.addEventListener('webglcontextrestored', this.handleContextRestored, !1) }System && (ContextSystem.__proto__ = System), (ContextSystem.prototype = Object.create(System && System.prototype)).constructor = ContextSystem; var prototypeAccessors = { isLost: { configurable: !0 } }; return prototypeAccessors.isLost.get = function () { return !this.gl || this.gl.isContextLost() }, ContextSystem.prototype.contextChange = function (gl) { (this.gl = gl).isContextLost() && gl.getExtension('WEBGL_lose_context') && gl.getExtension('WEBGL_lose_context').restoreContext() }, ContextSystem.prototype.initFromContext = function (gl) { this.gl = gl, this.validateContext(gl), this.renderer.gl = gl, this.renderer.CONTEXT_UID = CONTEXT_UID++, this.renderer.runners.contextChange.run(gl) }, ContextSystem.prototype.initFromOptions = function (options) { var gl = this.createContext(this.renderer.view, options); this.initFromContext(gl) }, ContextSystem.prototype.createContext = function (canvas, options) { var gl; if (settings.PREFER_ENV >= ENV.WEBGL2 && (gl = canvas.getContext('webgl2', options)), gl) this.webGLVersion = 2; else if (this.webGLVersion = 1, !(gl = canvas.getContext('webgl', options) || canvas.getContext('experimental-webgl', options))) throw new Error('This browser does not support WebGL. Try using the canvas renderer'); return this.gl = gl, this.getExtensions(), gl }, ContextSystem.prototype.getExtensions = function () { var gl = this.gl; this.webGLVersion === 1 && Object.assign(this.extensions, { drawBuffers: gl.getExtension('WEBGL_draw_buffers'), depthTexture: gl.getExtension('WEBKIT_WEBGL_depth_texture'), floatTexture: gl.getExtension('OES_texture_float'), loseContext: gl.getExtension('WEBGL_lose_context'), vertexArrayObject: gl.getExtension('OES_vertex_array_object') || gl.getExtension('MOZ_OES_vertex_array_object') || gl.getExtension('WEBKIT_OES_vertex_array_object'), uint32ElementIndex: gl.getExtension('OES_element_index_uint') }) }, ContextSystem.prototype.handleContextLost = function (event) { event.preventDefault() }, ContextSystem.prototype.handleContextRestored = function () { this.renderer.runners.contextChange.run(this.gl) }, ContextSystem.prototype.destroy = function () { var view = this.renderer.view; view.removeEventListener('webglcontextlost', this.handleContextLost), view.removeEventListener('webglcontextrestored', this.handleContextRestored), this.gl.useProgram(null), this.extensions.loseContext && this.extensions.loseContext.loseContext() }, ContextSystem.prototype.postrender = function () { this.gl.flush() }, ContextSystem.prototype.validateContext = function (gl) { gl.getContextAttributes().stencil || console.warn('Provided WebGL context does not have a stencil buffer, masks may not render correctly') }, Object.defineProperties(ContextSystem.prototype, prototypeAccessors), ContextSystem }(System)); var FramebufferSystem = (function (System) { function FramebufferSystem (renderer) { System.call(this, renderer), this.managedFramebuffers = [], this.unknownFramebuffer = new Framebuffer(10, 10) }System && (FramebufferSystem.__proto__ = System); var prototypeAccessors = { size: { configurable: !0 } }; return ((FramebufferSystem.prototype = Object.create(System && System.prototype)).constructor = FramebufferSystem).prototype.contextChange = function () { var gl = this.gl = this.renderer.gl; if (this.CONTEXT_UID = this.renderer.CONTEXT_UID, this.current = this.unknownFramebuffer, this.viewport = new Rectangle(), this.hasMRT = !0, this.writeDepthTexture = !0, this.disposeAll(!0), this.renderer.context.webGLVersion === 1) { var nativeDrawBuffersExtension = this.renderer.context.extensions.drawBuffers; var nativeDepthTextureExtension = this.renderer.context.extensions.depthTexture; settings.PREFER_ENV === ENV.WEBGL_LEGACY && (nativeDepthTextureExtension = nativeDrawBuffersExtension = null), nativeDrawBuffersExtension ? gl.drawBuffers = function (activeTextures) { return nativeDrawBuffersExtension.drawBuffersWEBGL(activeTextures) } : (this.hasMRT = !1, gl.drawBuffers = function () {}), nativeDepthTextureExtension || (this.writeDepthTexture = !1) } }, FramebufferSystem.prototype.bind = function (framebuffer, frame) { var gl = this.gl; if (framebuffer) { var fbo = framebuffer.glFramebuffers[this.CONTEXT_UID] || this.initFramebuffer(framebuffer); this.current !== framebuffer && (this.current = framebuffer, gl.bindFramebuffer(gl.FRAMEBUFFER, fbo.framebuffer)), fbo.dirtyId !== framebuffer.dirtyId && (fbo.dirtyId = framebuffer.dirtyId, fbo.dirtyFormat !== framebuffer.dirtyFormat ? (fbo.dirtyFormat = framebuffer.dirtyFormat, this.updateFramebuffer(framebuffer)) : fbo.dirtySize !== framebuffer.dirtySize && (fbo.dirtySize = framebuffer.dirtySize, this.resizeFramebuffer(framebuffer))); for (var i = 0; i < framebuffer.colorTextures.length; i++)framebuffer.colorTextures[i].texturePart ? this.renderer.texture.unbind(framebuffer.colorTextures[i].texture) : this.renderer.texture.unbind(framebuffer.colorTextures[i]); framebuffer.depthTexture && this.renderer.texture.unbind(framebuffer.depthTexture), frame ? this.setViewport(frame.x, frame.y, frame.width, frame.height) : this.setViewport(0, 0, framebuffer.width, framebuffer.height) } else this.current && (this.current = null, gl.bindFramebuffer(gl.FRAMEBUFFER, null)), frame ? this.setViewport(frame.x, frame.y, frame.width, frame.height) : this.setViewport(0, 0, this.renderer.width, this.renderer.height) }, FramebufferSystem.prototype.setViewport = function (x, y, width, height) { var v = this.viewport; v.width === width && v.height === height && v.x === x && v.y === y || (v.x = x, v.y = y, v.width = width, v.height = height, this.gl.viewport(x, y, width, height)) }, prototypeAccessors.size.get = function () { return this.current ? { x: 0, y: 0, width: this.current.width, height: this.current.height } : { x: 0, y: 0, width: this.renderer.width, height: this.renderer.height } }, FramebufferSystem.prototype.clear = function (r, g, b, a) { var gl = this.gl; gl.clearColor(r, g, b, a), gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT) }, FramebufferSystem.prototype.initFramebuffer = function (framebuffer) { var fbo = { framebuffer: this.gl.createFramebuffer(), stencil: null, dirtyId: 0, dirtyFormat: 0, dirtySize: 0 }; return framebuffer.glFramebuffers[this.CONTEXT_UID] = fbo, this.managedFramebuffers.push(framebuffer), framebuffer.disposeRunner.add(this), fbo }, FramebufferSystem.prototype.resizeFramebuffer = function (framebuffer) { var gl = this.gl; var fbo = framebuffer.glFramebuffers[this.CONTEXT_UID]; fbo.stencil && (gl.bindRenderbuffer(gl.RENDERBUFFER, fbo.stencil), gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_STENCIL, framebuffer.width, framebuffer.height)); for (var colorTextures = framebuffer.colorTextures, i = 0; i < colorTextures.length; i++) this.renderer.texture.bind(colorTextures[i], 0); framebuffer.depthTexture && this.renderer.texture.bind(framebuffer.depthTexture, 0) }, FramebufferSystem.prototype.updateFramebuffer = function (framebuffer) { var gl = this.gl; var fbo = framebuffer.glFramebuffers[this.CONTEXT_UID]; var count = framebuffer.colorTextures.length; gl.drawBuffers || (count = Math.min(count, 1)); for (var activeTextures = [], i = 0; i < count; i++) { var texture = framebuffer.colorTextures[i]; texture.texturePart ? (this.renderer.texture.bind(texture.texture, 0), gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0 + i, gl.TEXTURE_CUBE_MAP_NEGATIVE_X + texture.side, texture.texture._glTextures[this.CONTEXT_UID].texture, 0)) : (this.renderer.texture.bind(texture, 0), gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0 + i, gl.TEXTURE_2D, texture._glTextures[this.CONTEXT_UID].texture, 0)), activeTextures.push(gl.COLOR_ATTACHMENT0 + i) } if ((activeTextures.length > 1 && gl.drawBuffers(activeTextures), framebuffer.depthTexture) && this.writeDepthTexture) { var depthTexture = framebuffer.depthTexture; this.renderer.texture.bind(depthTexture, 0), gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.TEXTURE_2D, depthTexture._glTextures[this.CONTEXT_UID].texture, 0) }fbo.stencil || !framebuffer.stencil && !framebuffer.depth || (fbo.stencil = gl.createRenderbuffer(), gl.bindRenderbuffer(gl.RENDERBUFFER, fbo.stencil), framebuffer.depthTexture || gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_STENCIL_ATTACHMENT, gl.RENDERBUFFER, fbo.stencil), gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_STENCIL, framebuffer.width, framebuffer.height)) }, FramebufferSystem.prototype.disposeFramebuffer = function (framebuffer, contextLost) { var fbo = framebuffer.glFramebuffers[this.CONTEXT_UID]; var gl = this.gl; if (fbo) { delete framebuffer.glFramebuffers[this.CONTEXT_UID]; var index = this.managedFramebuffers.indexOf(framebuffer); index >= 0 && this.managedFramebuffers.splice(index, 1), framebuffer.disposeRunner.remove(this), contextLost || (gl.deleteFramebuffer(fbo.framebuffer), fbo.stencil && gl.deleteRenderbuffer(fbo.stencil)) } }, FramebufferSystem.prototype.disposeAll = function (contextLost) { var list = this.managedFramebuffers; this.managedFramebuffers = []; for (var i = 0; i < list.count; i++) this.disposeFramebuffer(list[i], contextLost) }, FramebufferSystem.prototype.reset = function () { this.current = this.unknownFramebuffer, this.viewport = new Rectangle() }, Object.defineProperties(FramebufferSystem.prototype, prototypeAccessors), FramebufferSystem }(System)); var GLBuffer = function (buffer) { this.buffer = buffer, this.updateID = -1, this.byteLength = -1, this.refCount = 0 }; var byteSizeMap$1 = { 5126: 4, 5123: 2, 5121: 1 }; var GeometrySystem = (function (System) { function GeometrySystem (renderer) { System.call(this, renderer), this._activeGeometry = null, this._activeVao = null, this.hasVao = !0, this.hasInstance = !0, this.canUseUInt32ElementIndex = !1, this.boundBuffers = {}, this.managedGeometries = {}, this.managedBuffers = {} } return System && (GeometrySystem.__proto__ = System), ((GeometrySystem.prototype = Object.create(System && System.prototype)).constructor = GeometrySystem).prototype.contextChange = function () { this.disposeAll(!0); var gl = this.gl = this.renderer.gl; var context = this.renderer.context; if (this.CONTEXT_UID = this.renderer.CONTEXT_UID, !gl.createVertexArray) { var nativeVaoExtension = this.renderer.context.extensions.vertexArrayObject; settings.PREFER_ENV === ENV.WEBGL_LEGACY && (nativeVaoExtension = null), nativeVaoExtension ? (gl.createVertexArray = function () { return nativeVaoExtension.createVertexArrayOES() }, gl.bindVertexArray = function (vao) { return nativeVaoExtension.bindVertexArrayOES(vao) }, gl.deleteVertexArray = function (vao) { return nativeVaoExtension.deleteVertexArrayOES(vao) }) : (this.hasVao = !1, gl.createVertexArray = function () {}, gl.bindVertexArray = function () {}, gl.deleteVertexArray = function () {}) } if (!gl.vertexAttribDivisor) { var instanceExt = gl.getExtension('ANGLE_instanced_arrays'); instanceExt ? (gl.vertexAttribDivisor = function (a, b) { return instanceExt.vertexAttribDivisorANGLE(a, b) }, gl.drawElementsInstanced = function (a, b, c, d, e) { return instanceExt.drawElementsInstancedANGLE(a, b, c, d, e) }, gl.drawArraysInstanced = function (a, b, c, d) { return instanceExt.drawArraysInstancedANGLE(a, b, c, d) }) : this.hasInstance = !1 } this.canUseUInt32ElementIndex = context.webGLVersion === 2 || !!context.extensions.uint32ElementIndex }, GeometrySystem.prototype.bind = function (geometry, shader) { shader = shader || this.renderer.shader.shader; var gl = this.gl; var vaos = geometry.glVertexArrayObjects[this.CONTEXT_UID]; vaos || ((this.managedGeometries[geometry.id] = geometry).disposeRunner.add(this), geometry.glVertexArrayObjects[this.CONTEXT_UID] = vaos = {}); var vao = vaos[shader.program.id] || this.initGeometryVao(geometry, shader.program); this._activeGeometry = geometry, this._activeVao !== vao && (this._activeVao = vao, this.hasVao ? gl.bindVertexArray(vao) : this.activateVao(geometry, shader.program)), this.updateBuffers() }, GeometrySystem.prototype.reset = function () { this.unbind() }, GeometrySystem.prototype.updateBuffers = function () { for (var geometry = this._activeGeometry, gl = this.gl, i = 0; i < geometry.buffers.length; i++) { var buffer = geometry.buffers[i]; var glBuffer = buffer._glBuffers[this.CONTEXT_UID]; if (buffer._updateID !== glBuffer.updateID) { glBuffer.updateID = buffer._updateID; var type = buffer.index ? gl.ELEMENT_ARRAY_BUFFER : gl.ARRAY_BUFFER; if (gl.bindBuffer(type, glBuffer.buffer), (this._boundBuffer = glBuffer).byteLength >= buffer.data.byteLength)gl.bufferSubData(type, 0, buffer.data); else { var drawType = buffer.static ? gl.STATIC_DRAW : gl.DYNAMIC_DRAW; glBuffer.byteLength = buffer.data.byteLength, gl.bufferData(type, buffer.data, drawType) } } } }, GeometrySystem.prototype.checkCompatibility = function (geometry, program) { var geometryAttributes = geometry.attributes; var shaderAttributes = program.attributeData; for (var j in shaderAttributes) if (!geometryAttributes[j]) throw new Error('shader and geometry incompatible, geometry missing the "' + j + '" attribute') }, GeometrySystem.prototype.getSignature = function (geometry, program) { var attribs = geometry.attributes; var shaderAttributes = program.attributeData; var strings = ['g', geometry.id]; for (var i in attribs)shaderAttributes[i] && strings.push(i); return strings.join('-') }, GeometrySystem.prototype.initGeometryVao = function (geometry, program) { this.checkCompatibility(geometry, program); var gl = this.gl; var CONTEXT_UID = this.CONTEXT_UID; var signature = this.getSignature(geometry, program); var vaoObjectHash = geometry.glVertexArrayObjects[this.CONTEXT_UID]; var vao = vaoObjectHash[signature]; if (vao) return vaoObjectHash[program.id] = vao; var buffers = geometry.buffers; var attributes = geometry.attributes; var tempStride = {}; var tempStart = {}; for (var j in buffers)tempStride[j] = 0, tempStart[j] = 0; for (var j$1 in attributes)!attributes[j$1].size && program.attributeData[j$1] ? attributes[j$1].size = program.attributeData[j$1].size : attributes[j$1].size || console.warn("PIXI Geometry attribute '" + j$1 + "' size cannot be determined (likely the bound shader does not have the attribute)"), tempStride[attributes[j$1].buffer] += attributes[j$1].size * byteSizeMap$1[attributes[j$1].type]; for (var j$2 in attributes) { var attribute = attributes[j$2]; var attribSize = attribute.size; void 0 === attribute.stride && (tempStride[attribute.buffer] === attribSize * byteSizeMap$1[attribute.type] ? attribute.stride = 0 : attribute.stride = tempStride[attribute.buffer]), void 0 === attribute.start && (attribute.start = tempStart[attribute.buffer], tempStart[attribute.buffer] += attribSize * byteSizeMap$1[attribute.type]) }vao = gl.createVertexArray(), gl.bindVertexArray(vao); for (var i = 0; i < buffers.length; i++) { var buffer = buffers[i]; buffer._glBuffers[CONTEXT_UID] || (buffer._glBuffers[CONTEXT_UID] = new GLBuffer(gl.createBuffer()), (this.managedBuffers[buffer.id] = buffer).disposeRunner.add(this)), buffer._glBuffers[CONTEXT_UID].refCount++ } return this.activateVao(geometry, program), this._activeVao = vao, vaoObjectHash[program.id] = vao, vaoObjectHash[signature] = vao }, GeometrySystem.prototype.disposeBuffer = function (buffer, contextLost) { if (this.managedBuffers[buffer.id]) { delete this.managedBuffers[buffer.id]; var glBuffer = buffer._glBuffers[this.CONTEXT_UID]; var gl = this.gl; buffer.disposeRunner.remove(this), glBuffer && (contextLost || gl.deleteBuffer(glBuffer.buffer), delete buffer._glBuffers[this.CONTEXT_UID]) } }, GeometrySystem.prototype.disposeGeometry = function (geometry, contextLost) { if (this.managedGeometries[geometry.id]) { delete this.managedGeometries[geometry.id]; var vaos = geometry.glVertexArrayObjects[this.CONTEXT_UID]; var gl = this.gl; var buffers = geometry.buffers; if (geometry.disposeRunner.remove(this), vaos) { for (var i = 0; i < buffers.length; i++) { var buf = buffers[i]._glBuffers[this.CONTEXT_UID]; buf.refCount--, buf.refCount !== 0 || contextLost || this.disposeBuffer(buffers[i], contextLost) } if (!contextLost) for (var vaoId in vaos) if (vaoId[0] === 'g') { var vao = vaos[vaoId]; this._activeVao === vao && this.unbind(), gl.deleteVertexArray(vao) } delete geometry.glVertexArrayObjects[this.CONTEXT_UID] } } }, GeometrySystem.prototype.disposeAll = function (contextLost) { for (var all = Object.keys(this.managedGeometries), i = 0; i < all.length; i++) this.disposeGeometry(this.managedGeometries[all[i]], contextLost); all = Object.keys(this.managedBuffers); for (var i$1 = 0; i$1 < all.length; i$1++) this.disposeBuffer(this.managedBuffers[all[i$1]], contextLost) }, GeometrySystem.prototype.activateVao = function (geometry, program) { var gl = this.gl; var CONTEXT_UID = this.CONTEXT_UID; var buffers = geometry.buffers; var attributes = geometry.attributes; geometry.indexBuffer && gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, geometry.indexBuffer._glBuffers[CONTEXT_UID].buffer); var lastBuffer = null; for (var j in attributes) { var attribute = attributes[j]; var glBuffer = buffers[attribute.buffer]._glBuffers[CONTEXT_UID]; if (program.attributeData[j]) { lastBuffer !== glBuffer && (gl.bindBuffer(gl.ARRAY_BUFFER, glBuffer.buffer), lastBuffer = glBuffer); var location = program.attributeData[j].location; if (gl.enableVertexAttribArray(location), gl.vertexAttribPointer(location, attribute.size, attribute.type || gl.FLOAT, attribute.normalized, attribute.stride, attribute.start), attribute.instance) { if (!this.hasInstance) throw new Error('geometry error, GPU Instancing is not supported on this device'); gl.vertexAttribDivisor(location, 1) } } } }, GeometrySystem.prototype.draw = function (type, size, start, instanceCount) { var gl = this.gl; var geometry = this._activeGeometry; if (geometry.indexBuffer) { var byteSize = geometry.indexBuffer.data.BYTES_PER_ELEMENT; var glType = byteSize === 2 ? gl.UNSIGNED_SHORT : gl.UNSIGNED_INT; byteSize === 2 || byteSize === 4 && this.canUseUInt32ElementIndex ? geometry.instanced ? gl.drawElementsInstanced(type, size || geometry.indexBuffer.data.length, glType, (start || 0) * byteSize, instanceCount || 1) : gl.drawElements(type, size || geometry.indexBuffer.data.length, glType, (start || 0) * byteSize) : console.warn('unsupported index buffer type: uint32') } else geometry.instanced ? gl.drawArraysInstanced(type, start, size || geometry.getSize(), instanceCount || 1) : gl.drawArrays(type, start, size || geometry.getSize()); return this }, GeometrySystem.prototype.unbind = function () { this.gl.bindVertexArray(null), this._activeVao = null, this._activeGeometry = null }, GeometrySystem }(System)); function compileProgram (gl, vertexSrc, fragmentSrc, attributeLocations) { var glVertShader = compileShader(gl, gl.VERTEX_SHADER, vertexSrc); var glFragShader = compileShader(gl, gl.FRAGMENT_SHADER, fragmentSrc); var program = gl.createProgram(); if (gl.attachShader(program, glVertShader), gl.attachShader(program, glFragShader), attributeLocations) for (var i in attributeLocations)gl.bindAttribLocation(program, attributeLocations[i], i); return gl.linkProgram(program), gl.getProgramParameter(program, gl.LINK_STATUS) || (console.error('Pixi.js Error: Could not initialize shader.'), console.error('gl.VALIDATE_STATUS', gl.getProgramParameter(program, gl.VALIDATE_STATUS)), console.error('gl.getError()', gl.getError()), gl.getProgramInfoLog(program) !== '' && console.warn('Pixi.js Warning: gl.getProgramInfoLog()', gl.getProgramInfoLog(program)), gl.deleteProgram(program), program = null), gl.deleteShader(glVertShader), gl.deleteShader(glFragShader), program } function compileShader (gl, type, src) { var shader = gl.createShader(type); return gl.shaderSource(shader, src), gl.compileShader(shader), gl.getShaderParameter(shader, gl.COMPILE_STATUS) ? shader : (console.warn(src), console.error(gl.getShaderInfoLog(shader)), null) } function defaultValue (type, size) { switch (type) { case 'float':return 0; case 'vec2':return new Float32Array(2 * size); case 'vec3':return new Float32Array(3 * size); case 'vec4':return new Float32Array(4 * size); case 'int':case 'sampler2D':case 'sampler2DArray':return 0; case 'ivec2':return new Int32Array(2 * size); case 'ivec3':return new Int32Array(3 * size); case 'ivec4':return new Int32Array(4 * size); case 'bool':return !1; case 'bvec2':return booleanArray(2 * size); case 'bvec3':return booleanArray(3 * size); case 'bvec4':return booleanArray(4 * size); case 'mat2':return new Float32Array([1, 0, 0, 1]); case 'mat3':return new Float32Array([1, 0, 0, 0, 1, 0, 0, 0, 1]); case 'mat4':return new Float32Array([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]) } return null } function booleanArray (size) { for (var array = new Array(size), i = 0; i < array.length; i++)array[i] = !1; return array } var maxFragmentPrecision; var context = null; function getTestContext () { if (context) return context; var gl; var canvas = document.createElement('canvas'); if (settings.PREFER_ENV >= ENV.WEBGL2 && (gl = canvas.getContext('webgl2', {})), !gl) { if (!(gl = canvas.getContext('webgl', {}) || canvas.getContext('experimental-webgl', {}))) throw new Error('This browser does not support WebGL. Try using the canvas renderer'); gl.getExtension('WEBGL_draw_buffers') } return context = gl } function setPrecision (src, requestedPrecision, maxSupportedPrecision) { if (src.substring(0, 9) === 'precision') return maxSupportedPrecision !== PRECISION.HIGH && src.substring(0, 15) === 'precision highp' ? src.replace('precision highp', 'precision mediump') : src; var precision = requestedPrecision; return requestedPrecision === PRECISION.HIGH && maxSupportedPrecision !== PRECISION.HIGH && (precision = PRECISION.MEDIUM), 'precision ' + precision + ' float;\n' + src } var GLSL_TO_SIZE = { float: 1, vec2: 2, vec3: 3, vec4: 4, int: 1, ivec2: 2, ivec3: 3, ivec4: 4, bool: 1, bvec2: 2, bvec3: 3, bvec4: 4, mat2: 4, mat3: 9, mat4: 16, sampler2D: 1 }; function mapSize (type) { return GLSL_TO_SIZE[type] } var GL_TABLE = null; var GL_TO_GLSL_TYPES = { FLOAT: 'float', FLOAT_VEC2: 'vec2', FLOAT_VEC3: 'vec3', FLOAT_VEC4: 'vec4', INT: 'int', INT_VEC2: 'ivec2', INT_VEC3: 'ivec3', INT_VEC4: 'ivec4', BOOL: 'bool', BOOL_VEC2: 'bvec2', BOOL_VEC3: 'bvec3', BOOL_VEC4: 'bvec4', FLOAT_MAT2: 'mat2', FLOAT_MAT3: 'mat3', FLOAT_MAT4: 'mat4', SAMPLER_2D: 'sampler2D', SAMPLER_CUBE: 'samplerCube', SAMPLER_2D_ARRAY: 'sampler2DArray' }; function mapType (gl, type) { if (!GL_TABLE) { var typeNames = Object.keys(GL_TO_GLSL_TYPES); GL_TABLE = {}; for (var i = 0; i < typeNames.length; ++i) { var tn = typeNames[i]; GL_TABLE[gl[tn]] = GL_TO_GLSL_TYPES[tn] } } return GL_TABLE[type] } var GLSL_TO_SINGLE_SETTERS_CACHED = { float: '\n    if(cv !== v)\n    {\n        cv.v = v;\n        gl.uniform1f(location, v)\n    }', vec2: '\n    if(cv[0] !== v[0] || cv[1] !== v[1])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        gl.uniform2f(location, v[0], v[1])\n    }', vec3: '\n    if(cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n\n        gl.uniform3f(location, v[0], v[1], v[2])\n    }', vec4: 'gl.uniform4f(location, v[0], v[1], v[2], v[3])', int: 'gl.uniform1i(location, v)', ivec2: 'gl.uniform2i(location, v[0], v[1])', ivec3: 'gl.uniform3i(location, v[0], v[1], v[2])', ivec4: 'gl.uniform4i(location, v[0], v[1], v[2], v[3])', bool: 'gl.uniform1i(location, v)', bvec2: 'gl.uniform2i(location, v[0], v[1])', bvec3: 'gl.uniform3i(location, v[0], v[1], v[2])', bvec4: 'gl.uniform4i(location, v[0], v[1], v[2], v[3])', mat2: 'gl.uniformMatrix2fv(location, false, v)', mat3: 'gl.uniformMatrix3fv(location, false, v)', mat4: 'gl.uniformMatrix4fv(location, false, v)', sampler2D: 'gl.uniform1i(location, v)', samplerCube: 'gl.uniform1i(location, v)', sampler2DArray: 'gl.uniform1i(location, v)' }; var GLSL_TO_ARRAY_SETTERS = { float: 'gl.uniform1fv(location, v)', vec2: 'gl.uniform2fv(location, v)', vec3: 'gl.uniform3fv(location, v)', vec4: 'gl.uniform4fv(location, v)', mat4: 'gl.uniformMatrix4fv(location, false, v)', mat3: 'gl.uniformMatrix3fv(location, false, v)', mat2: 'gl.uniformMatrix2fv(location, false, v)', int: 'gl.uniform1iv(location, v)', ivec2: 'gl.uniform2iv(location, v)', ivec3: 'gl.uniform3iv(location, v)', ivec4: 'gl.uniform4iv(location, v)', bool: 'gl.uniform1iv(location, v)', bvec2: 'gl.uniform2iv(location, v)', bvec3: 'gl.uniform3iv(location, v)', bvec4: 'gl.uniform4iv(location, v)', sampler2D: 'gl.uniform1iv(location, v)', samplerCube: 'gl.uniform1iv(location, v)', sampler2DArray: 'gl.uniform1iv(location, v)' }; var unsafeEval; var fragTemplate = ['precision mediump float;', 'void main(void){', 'float test = 0.1;', '%forloop%', 'gl_FragColor = vec4(0.0);', '}'].join('\n'); function checkMaxIfStatementsInShader (maxIfs, gl) { if (maxIfs === 0) throw new Error('Invalid value of `0` passed to `checkMaxIfStatementsInShader`'); for (var shader = gl.createShader(gl.FRAGMENT_SHADER); ;) { var fragmentSrc = fragTemplate.replace(/%forloop%/gi, generateIfTestSrc(maxIfs)); if (gl.shaderSource(shader, fragmentSrc), gl.compileShader(shader), gl.getShaderParameter(shader, gl.COMPILE_STATUS)) break; maxIfs = maxIfs / 2 | 0 } return maxIfs } function generateIfTestSrc (maxIfs) { for (var src = '', i = 0; i < maxIfs; ++i)i > 0 && (src += '\nelse '), i < maxIfs - 1 && (src += 'if(test == ' + i + '.0){}'); return src } function Program (vertexSrc, fragmentSrc, name) { void 0 === name && (name = 'pixi-shader'), this.id = UID$3++, this.vertexSrc = vertexSrc || Program.defaultVertexSrc, this.fragmentSrc = fragmentSrc || Program.defaultFragmentSrc, this.vertexSrc = this.vertexSrc.trim(), this.fragmentSrc = this.fragmentSrc.trim(), this.vertexSrc.substring(0, 8) !== '#version' && (name = name.replace(/\s+/g, '-'), nameCache[name] ? (nameCache[name]++, name += '-' + nameCache[name]) : nameCache[name] = 1, this.vertexSrc = '#define SHADER_NAME ' + name + '\n' + this.vertexSrc, this.fragmentSrc = '#define SHADER_NAME ' + name + '\n' + this.fragmentSrc, this.vertexSrc = setPrecision(this.vertexSrc, settings.PRECISION_VERTEX, PRECISION.HIGH), this.fragmentSrc = setPrecision(this.fragmentSrc, settings.PRECISION_FRAGMENT, (function () { if (!maxFragmentPrecision) { maxFragmentPrecision = PRECISION.MEDIUM; var gl = getTestContext(); if (gl && gl.getShaderPrecisionFormat) { var shaderFragment = gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_FLOAT); maxFragmentPrecision = shaderFragment.precision ? PRECISION.HIGH : PRECISION.MEDIUM } } return maxFragmentPrecision }()))), this.extractData(this.vertexSrc, this.fragmentSrc), this.glPrograms = {}, this.syncUniforms = null } var UID$3 = 0; var nameCache = {}; var staticAccessors$3 = { defaultVertexSrc: { configurable: !0 }, defaultFragmentSrc: { configurable: !0 } }; Program.prototype.extractData = function (vertexSrc, fragmentSrc) { var gl = getTestContext(); if (gl) { var program = compileProgram(gl, vertexSrc, fragmentSrc); this.attributeData = this.getAttributeData(program, gl), this.uniformData = this.getUniformData(program, gl), gl.deleteProgram(program) } else this.uniformData = {}, this.attributeData = {} }, Program.prototype.getAttributeData = function (program, gl) { for (var attributes = {}, attributesArray = [], totalAttributes = gl.getProgramParameter(program, gl.ACTIVE_ATTRIBUTES), i = 0; i < totalAttributes; i++) { var attribData = gl.getActiveAttrib(program, i); var type = mapType(gl, attribData.type); var data = { type: type, name: attribData.name, size: mapSize(type), location: 0 }; attributes[attribData.name] = data, attributesArray.push(data) }attributesArray.sort(function (a, b) { return a.name > b.name ? 1 : -1 }); for (var i$1 = 0; i$1 < attributesArray.length; i$1++)attributesArray[i$1].location = i$1; return attributes }, Program.prototype.getUniformData = function (program, gl) { for (var uniforms = {}, totalUniforms = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS), i = 0; i < totalUniforms; i++) { var uniformData = gl.getActiveUniform(program, i); var name = uniformData.name.replace(/\[.*?\]/, ''); var isArray = uniformData.name.match(/\[.*?\]/, ''); var type = mapType(gl, uniformData.type); uniforms[name] = { type: type, size: uniformData.size, isArray: isArray, value: defaultValue(type, uniformData.size) } } return uniforms }, staticAccessors$3.defaultVertexSrc.get = function () { return 'attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void){\n   gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n   vTextureCoord = aTextureCoord;\n}\n' }, staticAccessors$3.defaultFragmentSrc.get = function () { return 'varying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\n\nvoid main(void){\n   gl_FragColor *= texture2D(uSampler, vTextureCoord);\n}' }, Program.from = function (vertexSrc, fragmentSrc, name) { var key = vertexSrc + fragmentSrc; var program = ProgramCache[key]; return program || (ProgramCache[key] = program = new Program(vertexSrc, fragmentSrc, name)), program }, Object.defineProperties(Program, staticAccessors$3); var Shader = function (program, uniforms) { for (var i in this.program = program, this.uniformGroup = uniforms ? uniforms instanceof UniformGroup ? uniforms : new UniformGroup(uniforms) : new UniformGroup({}), program.uniformData) this.uniformGroup.uniforms[i] instanceof Array && (this.uniformGroup.uniforms[i] = new Float32Array(this.uniformGroup.uniforms[i])) }; var prototypeAccessors$2$1 = { uniforms: { configurable: !0 } }; Shader.prototype.checkUniformExists = function (name, group) { if (group.uniforms[name]) return !0; for (var i in group.uniforms) { var uniform = group.uniforms[i]; if (uniform.group && this.checkUniformExists(name, uniform)) return !0 } return !1 }, Shader.prototype.destroy = function () { this.uniformGroup = null }, prototypeAccessors$2$1.uniforms.get = function () { return this.uniformGroup.uniforms }, Shader.from = function (vertexSrc, fragmentSrc, uniforms) { var program = Program.from(vertexSrc, fragmentSrc); return new Shader(program, uniforms) }, Object.defineProperties(Shader.prototype, prototypeAccessors$2$1); var State = function () { this.data = 0, this.blendMode = BLEND_MODES.NORMAL, this.polygonOffset = 0, this.blend = !0 }; var prototypeAccessors$3$1 = { blend: { configurable: !0 }, offsets: { configurable: !0 }, culling: { configurable: !0 }, depthTest: { configurable: !0 }, clockwiseFrontFace: { configurable: !0 }, blendMode: { configurable: !0 }, polygonOffset: { configurable: !0 } }; prototypeAccessors$3$1.blend.get = function () { return !!(1 & this.data) }, prototypeAccessors$3$1.blend.set = function (value) { !!(1 & this.data) !== value && (this.data ^= 1) }, prototypeAccessors$3$1.offsets.get = function () { return !!(2 & this.data) }, prototypeAccessors$3$1.offsets.set = function (value) { !!(2 & this.data) !== value && (this.data ^= 2) }, prototypeAccessors$3$1.culling.get = function () { return !!(4 & this.data) }, prototypeAccessors$3$1.culling.set = function (value) { !!(4 & this.data) !== value && (this.data ^= 4) }, prototypeAccessors$3$1.depthTest.get = function () { return !!(8 & this.data) }, prototypeAccessors$3$1.depthTest.set = function (value) { !!(8 & this.data) !== value && (this.data ^= 8) }, prototypeAccessors$3$1.clockwiseFrontFace.get = function () { return !!(16 & this.data) }, prototypeAccessors$3$1.clockwiseFrontFace.set = function (value) { !!(16 & this.data) !== value && (this.data ^= 16) }, prototypeAccessors$3$1.blendMode.get = function () { return this._blendMode }, prototypeAccessors$3$1.blendMode.set = function (value) { this.blend = value !== BLEND_MODES.NONE, this._blendMode = value }, prototypeAccessors$3$1.polygonOffset.get = function () { return this._polygonOffset }, prototypeAccessors$3$1.polygonOffset.set = function (value) { this.offsets = !!value, this._polygonOffset = value }, State.for2d = function () { var state = new State(); return state.depthTest = !1, state.blend = !0, state }, Object.defineProperties(State.prototype, prototypeAccessors$3$1); var Filter = (function (Shader) { function Filter (vertexSrc, fragmentSrc, uniforms) { var program = Program.from(vertexSrc || Filter.defaultVertexSrc, fragmentSrc || Filter.defaultFragmentSrc); Shader.call(this, program, uniforms), this.padding = 0, this.resolution = settings.FILTER_RESOLUTION, this.enabled = !0, this.autoFit = !0, this.legacy = !!this.program.attributeData.aTextureCoord, this.state = new State() }Shader && (Filter.__proto__ = Shader); var prototypeAccessors = { blendMode: { configurable: !0 } }; var staticAccessors = { defaultVertexSrc: { configurable: !0 }, defaultFragmentSrc: { configurable: !0 } }; return ((Filter.prototype = Object.create(Shader && Shader.prototype)).constructor = Filter).prototype.apply = function (filterManager, input, output, clear, currentState) { filterManager.applyFilter(this, input, output, clear, currentState) }, prototypeAccessors.blendMode.get = function () { return this.state.blendMode }, prototypeAccessors.blendMode.set = function (value) { this.state.blendMode = value }, staticAccessors.defaultVertexSrc.get = function () { return 'attribute vec2 aVertexPosition;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nuniform vec4 inputSize;\nuniform vec4 outputFrame;\n\nvec4 filterVertexPosition( void )\n{\n    vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;\n\n    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\n}\n\nvec2 filterTextureCoord( void )\n{\n    return aVertexPosition * (outputFrame.zw * inputSize.zw);\n}\n\nvoid main(void)\n{\n    gl_Position = filterVertexPosition();\n    vTextureCoord = filterTextureCoord();\n}\n' }, staticAccessors.defaultFragmentSrc.get = function () { return 'varying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\n\nvoid main(void){\n   gl_FragColor = texture2D(uSampler, vTextureCoord);\n}\n' }, Object.defineProperties(Filter.prototype, prototypeAccessors), Object.defineProperties(Filter, staticAccessors), Filter }(Shader)); Filter.SOURCE_KEY_MAP = {}; var tempMat = new Matrix(); var TextureMatrix = function (texture, clampMargin) { this._texture = texture, this.mapCoord = new Matrix(), this.uClampFrame = new Float32Array(4), this.uClampOffset = new Float32Array(2), this._updateID = -1, this.clampOffset = 0, this.clampMargin = void 0 === clampMargin ? 0.5 : clampMargin, this.isSimple = !1 }; var prototypeAccessors$4$1 = { texture: { configurable: !0 } }; prototypeAccessors$4$1.texture.get = function () { return this._texture }, prototypeAccessors$4$1.texture.set = function (value) { this._texture = value, this._updateID = -1 }, TextureMatrix.prototype.multiplyUvs = function (uvs, out) { void 0 === out && (out = uvs); for (var mat = this.mapCoord, i = 0; i < uvs.length; i += 2) { var x = uvs[i]; var y = uvs[i + 1]; out[i] = x * mat.a + y * mat.c + mat.tx, out[i + 1] = x * mat.b + y * mat.d + mat.ty } return out }, TextureMatrix.prototype.update = function (forceUpdate) { var tex = this._texture; if (!tex || !tex.valid) return !1; if (!forceUpdate && this._updateID === tex._updateID) return !1; this._updateID = tex._updateID; var uvs = tex._uvs; this.mapCoord.set(uvs.x1 - uvs.x0, uvs.y1 - uvs.y0, uvs.x3 - uvs.x0, uvs.y3 - uvs.y0, uvs.x0, uvs.y0); var orig = tex.orig; var trim = tex.trim; trim && (tempMat.set(orig.width / trim.width, 0, 0, orig.height / trim.height, -trim.x / trim.width, -trim.y / trim.height), this.mapCoord.append(tempMat)); var texBase = tex.baseTexture; var frame = this.uClampFrame; var margin = this.clampMargin / texBase.resolution; var offset = this.clampOffset; return frame[0] = (tex._frame.x + margin + offset) / texBase.width, frame[1] = (tex._frame.y + margin + offset) / texBase.height, frame[2] = (tex._frame.x + tex._frame.width - margin + offset) / texBase.width, frame[3] = (tex._frame.y + tex._frame.height - margin + offset) / texBase.height, this.uClampOffset[0] = offset / texBase.realWidth, this.uClampOffset[1] = offset / texBase.realHeight, this.isSimple = tex._frame.width === texBase.width && tex._frame.height === texBase.height && tex.rotate === 0, !0 }, Object.defineProperties(TextureMatrix.prototype, prototypeAccessors$4$1); var SpriteMaskFilter = (function (Filter) { function SpriteMaskFilter (sprite) { var maskMatrix = new Matrix(); Filter.call(this, 'attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\nuniform mat3 otherMatrix;\n\nvarying vec2 vMaskCoord;\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = aTextureCoord;\n    vMaskCoord = ( otherMatrix * vec3( aTextureCoord, 1.0)  ).xy;\n}\n', 'varying vec2 vMaskCoord;\nvarying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform sampler2D mask;\nuniform float alpha;\nuniform float npmAlpha;\nuniform vec4 maskClamp;\n\nvoid main(void)\n{\n    float clip = step(3.5,\n        step(maskClamp.x, vMaskCoord.x) +\n        step(maskClamp.y, vMaskCoord.y) +\n        step(vMaskCoord.x, maskClamp.z) +\n        step(vMaskCoord.y, maskClamp.w));\n\n    vec4 original = texture2D(uSampler, vTextureCoord);\n    vec4 masky = texture2D(mask, vMaskCoord);\n    float alphaMul = 1.0 - npmAlpha * (1.0 - masky.a);\n\n    original *= (alphaMul * masky.r * alpha * clip);\n\n    gl_FragColor = original;\n}\n'), sprite.renderable = !1, this.maskSprite = sprite, this.maskMatrix = maskMatrix } return Filter && (SpriteMaskFilter.__proto__ = Filter), ((SpriteMaskFilter.prototype = Object.create(Filter && Filter.prototype)).constructor = SpriteMaskFilter).prototype.apply = function (filterManager, input, output, clear) { var maskSprite = this.maskSprite; var tex = this.maskSprite.texture; tex.valid && (tex.transform || (tex.transform = new TextureMatrix(tex, 0)), tex.transform.update(), this.uniforms.npmAlpha = tex.baseTexture.premultiplyAlpha ? 0 : 1, this.uniforms.mask = tex, this.uniforms.otherMatrix = filterManager.calculateSpriteMatrix(this.maskMatrix, maskSprite).prepend(tex.transform.mapCoord), this.uniforms.alpha = maskSprite.worldAlpha, this.uniforms.maskClamp = tex.transform.uClampFrame, filterManager.applyFilter(this, input, output, clear)) }, SpriteMaskFilter }(Filter)); var MaskSystem = (function (System) { function MaskSystem (renderer) { System.call(this, renderer), this.scissor = !1, this.scissorData = null, this.scissorRenderTarget = null, this.enableScissor = !1, this.alphaMaskPool = [], this.alphaMaskIndex = 0 } return System && (MaskSystem.__proto__ = System), ((MaskSystem.prototype = Object.create(System && System.prototype)).constructor = MaskSystem).prototype.push = function (target, maskData) { if (maskData.isSprite) this.pushSpriteMask(target, maskData); else if (this.enableScissor && !this.scissor && this.renderer._activeRenderTarget.root && !this.renderer.stencil.stencilMaskStack.length && maskData.isFastRect()) { var matrix = maskData.worldTransform; var rot = Math.atan2(matrix.b, matrix.a); (rot = Math.round(rot * (180 / Math.PI))) % 90 ? this.pushStencilMask(maskData) : this.pushScissorMask(target, maskData) } else this.pushStencilMask(maskData) }, MaskSystem.prototype.pop = function (target, maskData) { maskData.isSprite ? this.popSpriteMask(target, maskData) : this.enableScissor && !this.renderer.stencil.stencilMaskStack.length ? this.popScissorMask(target, maskData) : this.popStencilMask(target, maskData) }, MaskSystem.prototype.pushSpriteMask = function (target, maskData) { var alphaMaskFilter = this.alphaMaskPool[this.alphaMaskIndex]; (alphaMaskFilter = alphaMaskFilter || (this.alphaMaskPool[this.alphaMaskIndex] = [new SpriteMaskFilter(maskData)]))[0].resolution = this.renderer.resolution, alphaMaskFilter[0].maskSprite = maskData; var stashFilterArea = target.filterArea; target.filterArea = maskData.getBounds(!0), this.renderer.filter.push(target, alphaMaskFilter), target.filterArea = stashFilterArea, this.alphaMaskIndex++ }, MaskSystem.prototype.popSpriteMask = function () { this.renderer.filter.pop(), this.alphaMaskIndex-- }, MaskSystem.prototype.pushStencilMask = function (maskData) { this.renderer.batch.flush(), this.renderer.stencil.pushStencil(maskData) }, MaskSystem.prototype.popStencilMask = function () { this.renderer.stencil.popStencil() }, MaskSystem.prototype.pushScissorMask = function (target, maskData) { maskData.renderable = !0; var renderTarget = this.renderer._activeRenderTarget; var bounds = maskData.getBounds(); bounds.fit(renderTarget.size), maskData.renderable = !1, this.renderer.gl.enable(this.renderer.gl.SCISSOR_TEST); var resolution = this.renderer.resolution; this.renderer.gl.scissor(bounds.x * resolution, (renderTarget.root ? renderTarget.size.height - bounds.y - bounds.height : bounds.y) * resolution, bounds.width * resolution, bounds.height * resolution), this.scissorRenderTarget = renderTarget, this.scissorData = maskData, this.scissor = !0 }, MaskSystem.prototype.popScissorMask = function () { this.scissorRenderTarget = null, this.scissorData = null, this.scissor = !1; var gl = this.renderer.gl; gl.disable(gl.SCISSOR_TEST) }, MaskSystem }(System)); var StencilSystem = (function (System) { function StencilSystem (renderer) { System.call(this, renderer), this.stencilMaskStack = [] } return System && (StencilSystem.__proto__ = System), ((StencilSystem.prototype = Object.create(System && System.prototype)).constructor = StencilSystem).prototype.setMaskStack = function (stencilMaskStack) { var gl = this.renderer.gl; stencilMaskStack.length !== this.stencilMaskStack.length && (stencilMaskStack.length === 0 ? gl.disable(gl.STENCIL_TEST) : gl.enable(gl.STENCIL_TEST)), this.stencilMaskStack = stencilMaskStack }, StencilSystem.prototype.pushStencil = function (graphics) { var gl = this.renderer.gl; var prevMaskCount = this.stencilMaskStack.length; prevMaskCount === 0 && gl.enable(gl.STENCIL_TEST), this.stencilMaskStack.push(graphics), gl.colorMask(!1, !1, !1, !1), gl.stencilFunc(gl.EQUAL, prevMaskCount, this._getBitwiseMask()), gl.stencilOp(gl.KEEP, gl.KEEP, gl.INCR), graphics.renderable = !0, graphics.render(this.renderer), this.renderer.batch.flush(), graphics.renderable = !1, this._useCurrent() }, StencilSystem.prototype.popStencil = function () { var gl = this.renderer.gl; var graphics = this.stencilMaskStack.pop(); this.stencilMaskStack.length === 0 ? (gl.disable(gl.STENCIL_TEST), gl.clear(gl.STENCIL_BUFFER_BIT), gl.clearStencil(0)) : (gl.colorMask(!1, !1, !1, !1), gl.stencilOp(gl.KEEP, gl.KEEP, gl.DECR), graphics.renderable = !0, graphics.render(this.renderer), this.renderer.batch.flush(), graphics.renderable = !1, this._useCurrent()) }, StencilSystem.prototype._useCurrent = function () { var gl = this.renderer.gl; gl.colorMask(!0, !0, !0, !0), gl.stencilFunc(gl.EQUAL, this.stencilMaskStack.length, this._getBitwiseMask()), gl.stencilOp(gl.KEEP, gl.KEEP, gl.KEEP) }, StencilSystem.prototype._getBitwiseMask = function () { return (1 << this.stencilMaskStack.length) - 1 }, StencilSystem.prototype.destroy = function () { System.prototype.destroy.call(this, this), this.stencilMaskStack = null }, StencilSystem }(System)); var ProjectionSystem = (function (System) { function ProjectionSystem (renderer) { System.call(this, renderer), this.destinationFrame = null, this.sourceFrame = null, this.defaultFrame = null, this.projectionMatrix = new Matrix(), this.transform = null } return System && (ProjectionSystem.__proto__ = System), ((ProjectionSystem.prototype = Object.create(System && System.prototype)).constructor = ProjectionSystem).prototype.update = function (destinationFrame, sourceFrame, resolution, root) { this.destinationFrame = destinationFrame || this.destinationFrame || this.defaultFrame, this.sourceFrame = sourceFrame || this.sourceFrame || destinationFrame, this.calculateProjection(this.destinationFrame, this.sourceFrame, resolution, root), this.transform && this.projectionMatrix.append(this.transform); var renderer = this.renderer; renderer.globalUniforms.uniforms.projectionMatrix = this.projectionMatrix, renderer.globalUniforms.update(), renderer.shader.shader && renderer.shader.syncUniformGroup(renderer.shader.shader.uniforms.globals) }, ProjectionSystem.prototype.calculateProjection = function (destinationFrame, sourceFrame, resolution, root) { var pm = this.projectionMatrix; root ? (pm.a = 1 / destinationFrame.width * 2 * resolution, pm.d = -1 / destinationFrame.height * 2 * resolution, pm.tx = -1 - sourceFrame.x * pm.a, pm.ty = 1 - sourceFrame.y * pm.d) : (pm.a = 1 / destinationFrame.width * 2 * resolution, pm.d = 1 / destinationFrame.height * 2 * resolution, pm.tx = -1 - sourceFrame.x * pm.a, pm.ty = -1 - sourceFrame.y * pm.d) }, ProjectionSystem.prototype.setTransform = function () {}, ProjectionSystem }(System)); var tempRect = new Rectangle(); var RenderTextureSystem = (function (System) { function RenderTextureSystem (renderer) { System.call(this, renderer), this.clearColor = renderer._backgroundColorRgba, this.defaultMaskStack = [], this.current = null, this.sourceFrame = new Rectangle(), this.destinationFrame = new Rectangle() } return System && (RenderTextureSystem.__proto__ = System), ((RenderTextureSystem.prototype = Object.create(System && System.prototype)).constructor = RenderTextureSystem).prototype.bind = function (renderTexture, sourceFrame, destinationFrame) { void 0 === renderTexture && (renderTexture = null), this.current = renderTexture; var resolution; var renderer = this.renderer; if (renderTexture) { var baseTexture = renderTexture.baseTexture; resolution = baseTexture.resolution, destinationFrame || (tempRect.width = baseTexture.realWidth, tempRect.height = baseTexture.realHeight, destinationFrame = tempRect), sourceFrame = sourceFrame || destinationFrame, this.renderer.framebuffer.bind(baseTexture.framebuffer, destinationFrame), this.renderer.projection.update(destinationFrame, sourceFrame, resolution, !1), this.renderer.stencil.setMaskStack(baseTexture.stencilMaskStack) } else resolution = this.renderer.resolution, destinationFrame || (tempRect.width = renderer.width, tempRect.height = renderer.height, destinationFrame = tempRect), sourceFrame = sourceFrame || destinationFrame, renderer.framebuffer.bind(null, destinationFrame), this.renderer.projection.update(destinationFrame, sourceFrame, resolution, !0), this.renderer.stencil.setMaskStack(this.defaultMaskStack); this.sourceFrame.copyFrom(sourceFrame), this.destinationFrame.x = destinationFrame.x / resolution, this.destinationFrame.y = destinationFrame.y / resolution, this.destinationFrame.width = destinationFrame.width / resolution, this.destinationFrame.height = destinationFrame.height / resolution, sourceFrame === destinationFrame && this.sourceFrame.copyFrom(this.destinationFrame) }, RenderTextureSystem.prototype.clear = function (clearColor) { clearColor = this.current ? clearColor || this.current.baseTexture.clearColor : clearColor || this.clearColor, this.renderer.framebuffer.clear(clearColor[0], clearColor[1], clearColor[2], clearColor[3]) }, RenderTextureSystem.prototype.resize = function () { this.bind(null) }, RenderTextureSystem.prototype.reset = function () { this.bind(null) }, RenderTextureSystem }(System)); var GLProgram = function (program, uniformData) { this.program = program, this.uniformData = uniformData, this.uniformGroups = {} }; GLProgram.prototype.destroy = function () { this.uniformData = null, this.uniformGroups = null, this.program = null }; var UID$4 = 0; var ShaderSystem = (function (System) { function ShaderSystem (renderer) { System.call(this, renderer), this.systemCheck(), this.gl = null, this.shader = null, this.program = null, this.cache = {}, this.id = UID$4++ } return System && (ShaderSystem.__proto__ = System), ((ShaderSystem.prototype = Object.create(System && System.prototype)).constructor = ShaderSystem).prototype.systemCheck = function () { if (!(function () { if (typeof unsafeEval === 'boolean') return unsafeEval; try { var func = new Function('param1', 'param2', 'param3', 'return param1[param2] === param3;'); unsafeEval = !0 === func({ a: 'b' }, 'a', 'b') } catch (e) { unsafeEval = !1 } return unsafeEval }())) throw new Error('Current environment does not allow unsafe-eval, please use @pixi/unsafe-eval module to enable support.') }, ShaderSystem.prototype.contextChange = function (gl) { this.gl = gl }, ShaderSystem.prototype.bind = function (shader, dontSync) { shader.uniforms.globals = this.renderer.globalUniforms; var program = shader.program; var glProgram = program.glPrograms[this.renderer.CONTEXT_UID] || this.generateShader(shader); return this.shader = shader, this.program !== program && (this.program = program, this.gl.useProgram(glProgram.program)), dontSync || this.syncUniformGroup(shader.uniformGroup), glProgram }, ShaderSystem.prototype.setUniforms = function (uniforms) { var shader = this.shader.program; var glProgram = shader.glPrograms[this.renderer.CONTEXT_UID]; shader.syncUniforms(glProgram.uniformData, uniforms, this.renderer) }, ShaderSystem.prototype.syncUniformGroup = function (group) { var glProgram = this.getglProgram(); group.static && group.dirtyId === glProgram.uniformGroups[group.id] || (glProgram.uniformGroups[group.id] = group.dirtyId, this.syncUniforms(group, glProgram)) }, ShaderSystem.prototype.syncUniforms = function (group, glProgram) { (group.syncUniforms[this.shader.program.id] || this.createSyncGroups(group))(glProgram.uniformData, group.uniforms, this.renderer) }, ShaderSystem.prototype.createSyncGroups = function (group) { var id = this.getSignature(group, this.shader.program.uniformData); return this.cache[id] || (this.cache[id] = (function (group, uniformData) { var textureCount = 0; var func = 'var v = null;\n    var cv = null\n    var gl = renderer.gl'; for (var i in group.uniforms) { var data = uniformData[i]; if (data) if (data.type === 'float' && data.size === 1)func += '\n            if(uv.' + i + ' !== ud.' + i + '.value)\n            {\n                ud.' + i + '.value = uv.' + i + '\n                gl.uniform1f(ud.' + i + '.location, uv.' + i + ')\n            }\n'; else if (data.type !== 'sampler2D' && data.type !== 'samplerCube' && data.type !== 'sampler2DArray' || data.size !== 1 || data.isArray) if (data.type === 'mat3' && data.size === 1) void 0 !== group.uniforms[i].a ? func += '\n                gl.uniformMatrix3fv(ud.' + i + '.location, false, uv.' + i + '.toArray(true));\n                \n' : func += '\n                gl.uniformMatrix3fv(ud.' + i + '.location, false, uv.' + i + ');\n                \n'; else if (data.type === 'vec2' && data.size === 1) void 0 !== group.uniforms[i].x ? func += '\n                cv = ud.' + i + '.value;\n                v = uv.' + i + ';\n\n                if(cv[0] !== v.x || cv[1] !== v.y)\n                {\n                    cv[0] = v.x;\n                    cv[1] = v.y;\n                    gl.uniform2f(ud.' + i + '.location, v.x, v.y);\n                }\n' : func += '\n                cv = ud.' + i + '.value;\n                v = uv.' + i + ';\n\n                if(cv[0] !== v[0] || cv[1] !== v[1])\n                {\n                    cv[0] = v[0];\n                    cv[1] = v[1];\n                    gl.uniform2f(ud.' + i + '.location, v[0], v[1]);\n                }\n                \n'; else if (data.type === 'vec4' && data.size === 1) void 0 !== group.uniforms[i].width ? func += '\n                cv = ud.' + i + '.value;\n                v = uv.' + i + ';\n\n                if(cv[0] !== v.x || cv[1] !== v.y || cv[2] !== v.width || cv[3] !== v.height)\n                {\n                    cv[0] = v.x;\n                    cv[1] = v.y;\n                    cv[2] = v.width;\n                    cv[3] = v.height;\n                    gl.uniform4f(ud.' + i + '.location, v.x, v.y, v.width, v.height)\n                }\n' : func += '\n                cv = ud.' + i + '.value;\n                v = uv.' + i + ';\n\n                if(cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])\n                {\n                    cv[0] = v[0];\n                    cv[1] = v[1];\n                    cv[2] = v[2];\n                    cv[3] = v[3];\n\n                    gl.uniform4f(ud.' + i + '.location, v[0], v[1], v[2], v[3])\n                }\n                \n'; else { func += '\n            cv = ud.' + i + '.value;\n            v = uv.' + i + ';\n            ' + (data.size === 1 ? GLSL_TO_SINGLE_SETTERS_CACHED : GLSL_TO_ARRAY_SETTERS)[data.type].replace('location', 'ud.' + i + '.location') + ';\n' } else func += '\n            renderer.texture.bind(uv.' + i + ', ' + textureCount + ');\n\n            if(ud.' + i + '.value !== ' + textureCount + ')\n            {\n                ud.' + i + '.value = ' + textureCount + ';\n                gl.uniform1i(ud.' + i + '.location, ' + textureCount + ');\n; // eslint-disable-line max-len\n            }\n', textureCount++; else group.uniforms[i].group && (func += '\n                    renderer.shader.syncUniformGroup(uv.' + i + ');\n                ') } return new Function('ud', 'uv', 'renderer', func) }(group, this.shader.program.uniformData))), group.syncUniforms[this.shader.program.id] = this.cache[id], group.syncUniforms[this.shader.program.id] }, ShaderSystem.prototype.getSignature = function (group, uniformData) { var uniforms = group.uniforms; var strings = []; for (var i in uniforms)strings.push(i), uniformData[i] && strings.push(uniformData[i].type); return strings.join('-') }, ShaderSystem.prototype.getglProgram = function () { return this.shader ? this.shader.program.glPrograms[this.renderer.CONTEXT_UID] : null }, ShaderSystem.prototype.generateShader = function (shader) { var gl = this.gl; var program = shader.program; var attribMap = {}; for (var i in program.attributeData)attribMap[i] = program.attributeData[i].location; var shaderProgram = compileProgram(gl, program.vertexSrc, program.fragmentSrc, attribMap); var uniformData = {}; for (var i$1 in program.uniformData) { var data = program.uniformData[i$1]; uniformData[i$1] = { location: gl.getUniformLocation(shaderProgram, i$1), value: defaultValue(data.type, data.size) } } var glProgram = new GLProgram(shaderProgram, uniformData); return program.glPrograms[this.renderer.CONTEXT_UID] = glProgram }, ShaderSystem.prototype.reset = function () { this.program = null, this.shader = null }, ShaderSystem.prototype.destroy = function () { this.destroyed = !0 }, ShaderSystem }(System)); var StateSystem = (function (System) { function StateSystem (renderer) { System.call(this, renderer), this.gl = null, this.stateId = 0, this.polygonOffset = 0, this.blendMode = BLEND_MODES.NONE, this._blendEq = !1, this.map = [], this.map[0] = this.setBlend, this.map[1] = this.setOffset, this.map[2] = this.setCullFace, this.map[3] = this.setDepthTest, this.map[4] = this.setFrontFace, this.checks = [], this.defaultState = new State(), this.defaultState.blend = !0, this.defaultState.depth = !0 } return System && (StateSystem.__proto__ = System), ((StateSystem.prototype = Object.create(System && System.prototype)).constructor = StateSystem).prototype.contextChange = function (gl) { this.gl = gl, this.blendModes = (function (gl, array) { return void 0 === array && (array = []), array[BLEND_MODES.NORMAL] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA], array[BLEND_MODES.ADD] = [gl.ONE, gl.ONE], array[BLEND_MODES.MULTIPLY] = [gl.DST_COLOR, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA], array[BLEND_MODES.SCREEN] = [gl.ONE, gl.ONE_MINUS_SRC_COLOR, gl.ONE, gl.ONE_MINUS_SRC_ALPHA], array[BLEND_MODES.OVERLAY] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA], array[BLEND_MODES.DARKEN] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA], array[BLEND_MODES.LIGHTEN] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA], array[BLEND_MODES.COLOR_DODGE] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA], array[BLEND_MODES.COLOR_BURN] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA], array[BLEND_MODES.HARD_LIGHT] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA], array[BLEND_MODES.SOFT_LIGHT] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA], array[BLEND_MODES.DIFFERENCE] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA], array[BLEND_MODES.EXCLUSION] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA], array[BLEND_MODES.HUE] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA], array[BLEND_MODES.SATURATION] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA], array[BLEND_MODES.COLOR] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA], array[BLEND_MODES.LUMINOSITY] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA], array[BLEND_MODES.NONE] = [0, 0], array[BLEND_MODES.NORMAL_NPM] = [gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA], array[BLEND_MODES.ADD_NPM] = [gl.SRC_ALPHA, gl.ONE, gl.ONE, gl.ONE], array[BLEND_MODES.SCREEN_NPM] = [gl.SRC_ALPHA, gl.ONE_MINUS_SRC_COLOR, gl.ONE, gl.ONE_MINUS_SRC_ALPHA], array[BLEND_MODES.SRC_IN] = [gl.DST_ALPHA, gl.ZERO], array[BLEND_MODES.SRC_OUT] = [gl.ONE_MINUS_DST_ALPHA, gl.ZERO], array[BLEND_MODES.SRC_ATOP] = [gl.DST_ALPHA, gl.ONE_MINUS_SRC_ALPHA], array[BLEND_MODES.DST_OVER] = [gl.ONE_MINUS_DST_ALPHA, gl.ONE], array[BLEND_MODES.DST_IN] = [gl.ZERO, gl.SRC_ALPHA], array[BLEND_MODES.DST_OUT] = [gl.ZERO, gl.ONE_MINUS_SRC_ALPHA], array[BLEND_MODES.DST_ATOP] = [gl.ONE_MINUS_DST_ALPHA, gl.SRC_ALPHA], array[BLEND_MODES.SUBTRACT] = [gl.ONE, gl.ONE, gl.ONE, gl.ONE, gl.FUNC_REVERSE_SUBTRACT, gl.FUNC_ADD], array }(gl)), this.setState(this.defaultState), this.reset() }, StateSystem.prototype.setState = function (state) { if (state = state || this.defaultState, this.stateId !== state.data) { for (var diff = this.stateId ^ state.data, i = 0; diff;)1 & diff && this.map[i].call(this, !!(state.data & 1 << i)), diff >>= 1, i++; this.stateId = state.data } for (var i$1 = 0; i$1 < this.checks.length; i$1++) this.checks[i$1](this, state) }, StateSystem.prototype.forceState = function (state) { state = state || this.defaultState; for (var i = 0; i < this.map.length; i++) this.map[i].call(this, !!(state.data & 1 << i)); for (var i$1 = 0; i$1 < this.checks.length; i$1++) this.checks[i$1](this, state); this.stateId = state.data }, StateSystem.prototype.setBlend = function (value) { this.updateCheck(StateSystem.checkBlendMode, value), this.gl[value ? 'enable' : 'disable'](this.gl.BLEND) }, StateSystem.prototype.setOffset = function (value) { this.updateCheck(StateSystem.checkPolygonOffset, value), this.gl[value ? 'enable' : 'disable'](this.gl.POLYGON_OFFSET_FILL) }, StateSystem.prototype.setDepthTest = function (value) { this.gl[value ? 'enable' : 'disable'](this.gl.DEPTH_TEST) }, StateSystem.prototype.setCullFace = function (value) { this.gl[value ? 'enable' : 'disable'](this.gl.CULL_FACE) }, StateSystem.prototype.setFrontFace = function (value) { this.gl.frontFace(this.gl[value ? 'CW' : 'CCW']) }, StateSystem.prototype.setBlendMode = function (value) { if (value !== this.blendMode) { this.blendMode = value; var mode = this.blendModes[value]; var gl = this.gl; mode.length === 2 ? gl.blendFunc(mode[0], mode[1]) : gl.blendFuncSeparate(mode[0], mode[1], mode[2], mode[3]), mode.length === 6 ? (this._blendEq = !0, gl.blendEquationSeparate(mode[4], mode[5])) : this._blendEq && (this._blendEq = !1, gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD)) } }, StateSystem.prototype.setPolygonOffset = function (value, scale) { this.gl.polygonOffset(value, scale) }, StateSystem.prototype.reset = function () { this.gl.pixelStorei(this.gl.UNPACK_FLIP_Y_WEBGL, !1), this.forceState(0), this._blendEq = !0, this.blendMode = -1, this.setBlendMode(0) }, StateSystem.prototype.updateCheck = function (func, value) { var index = this.checks.indexOf(func); value && index === -1 ? this.checks.push(func) : value || index === -1 || this.checks.splice(index, 1) }, StateSystem.checkBlendMode = function (system, state) { system.setBlendMode(state.blendMode) }, StateSystem.checkPolygonOffset = function (system, state) { system.setPolygonOffset(state.polygonOffset, 0) }, StateSystem }(System)); var TextureGCSystem = (function (System) { function TextureGCSystem (renderer) { System.call(this, renderer), this.count = 0, this.checkCount = 0, this.maxIdle = settings.GC_MAX_IDLE, this.checkCountMax = settings.GC_MAX_CHECK_COUNT, this.mode = settings.GC_MODE } return System && (TextureGCSystem.__proto__ = System), ((TextureGCSystem.prototype = Object.create(System && System.prototype)).constructor = TextureGCSystem).prototype.postrender = function () { this.count++, this.mode !== GC_MODES.MANUAL && (this.checkCount++, this.checkCount > this.checkCountMax && (this.checkCount = 0, this.run())) }, TextureGCSystem.prototype.run = function () { for (var tm = this.renderer.texture, managedTextures = tm.managedTextures, wasRemoved = !1, i = 0; i < managedTextures.length; i++) { var texture = managedTextures[i]; !texture.framebuffer && this.count - texture.touched > this.maxIdle && (tm.destroyTexture(texture, !0), wasRemoved = !(managedTextures[i] = null)) } if (wasRemoved) { for (var j = 0, i$1 = 0; i$1 < managedTextures.length; i$1++)managedTextures[i$1] !== null && (managedTextures[j++] = managedTextures[i$1]); managedTextures.length = j } }, TextureGCSystem.prototype.unload = function (displayObject) { var tm = this.renderer.textureSystem; displayObject._texture && displayObject._texture._glRenderTargets && tm.destroyTexture(displayObject._texture); for (var i = displayObject.children.length - 1; i >= 0; i--) this.unload(displayObject.children[i]) }, TextureGCSystem }(System)); var GLTexture = function (texture) { this.texture = texture, this.width = -1, this.height = -1, this.dirtyId = -1, this.dirtyStyleId = -1, this.mipmap = !1, this.wrapMode = 33071 }; var TextureSystem = (function (System) { function TextureSystem (renderer) { System.call(this, renderer), this.boundTextures = [], this.currentLocation = -1, this.managedTextures = [], this._unknownBoundTextures = !1, this.unknownTexture = new BaseTexture() } return System && (TextureSystem.__proto__ = System), ((TextureSystem.prototype = Object.create(System && System.prototype)).constructor = TextureSystem).prototype.contextChange = function () { var gl = this.gl = this.renderer.gl; this.CONTEXT_UID = this.renderer.CONTEXT_UID, this.webGLVersion = this.renderer.context.webGLVersion; var maxTextures = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS); this.boundTextures.length = maxTextures; for (var i = 0; i < maxTextures; i++) this.boundTextures[i] = null; this.emptyTextures = {}; var emptyTexture2D = new GLTexture(gl.createTexture()); gl.bindTexture(gl.TEXTURE_2D, emptyTexture2D.texture), gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, new Uint8Array(4)), this.emptyTextures[gl.TEXTURE_2D] = emptyTexture2D, this.emptyTextures[gl.TEXTURE_CUBE_MAP] = new GLTexture(gl.createTexture()), gl.bindTexture(gl.TEXTURE_CUBE_MAP, this.emptyTextures[gl.TEXTURE_CUBE_MAP].texture); for (var i$1 = 0; i$1 < 6; i$1++)gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + i$1, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, null); gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MAG_FILTER, gl.LINEAR), gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MIN_FILTER, gl.LINEAR); for (var i$2 = 0; i$2 < this.boundTextures.length; i$2++) this.bind(null, i$2) }, TextureSystem.prototype.bind = function (texture, location) { void 0 === location && (location = 0); var gl = this.gl; if (texture) { if ((texture = texture.baseTexture || texture).valid) { texture.touched = this.renderer.textureGC.count; var glTexture = texture._glTextures[this.CONTEXT_UID] || this.initTexture(texture); this.currentLocation !== location && (this.currentLocation = location, gl.activeTexture(gl.TEXTURE0 + location)), this.boundTextures[location] !== texture && gl.bindTexture(texture.target, glTexture.texture), glTexture.dirtyId !== texture.dirtyId && this.updateTexture(texture), this.boundTextures[location] = texture } } else this.currentLocation !== location && (this.currentLocation = location, gl.activeTexture(gl.TEXTURE0 + location)), gl.bindTexture(gl.TEXTURE_2D, this.emptyTextures[gl.TEXTURE_2D].texture), this.boundTextures[location] = null }, TextureSystem.prototype.reset = function () { this._unknownBoundTextures = !0, this.currentLocation = -1; for (var i = 0; i < this.boundTextures.length; i++) this.boundTextures[i] = this.unknownTexture }, TextureSystem.prototype.unbind = function (texture) { var gl = this.gl; var boundTextures = this.boundTextures; if (this._unknownBoundTextures) { this._unknownBoundTextures = !1; for (var i = 0; i < boundTextures.length; i++)boundTextures[i] === this.unknownTexture && this.bind(null, i) } for (var i$1 = 0; i$1 < boundTextures.length; i$1++)boundTextures[i$1] === texture && (this.currentLocation !== i$1 && (gl.activeTexture(gl.TEXTURE0 + i$1), this.currentLocation = i$1), gl.bindTexture(gl.TEXTURE_2D, this.emptyTextures[texture.target].texture), boundTextures[i$1] = null) }, TextureSystem.prototype.initTexture = function (texture) { var glTexture = new GLTexture(this.gl.createTexture()); return glTexture.dirtyId = -1, texture._glTextures[this.CONTEXT_UID] = glTexture, this.managedTextures.push(texture), texture.on('dispose', this.destroyTexture, this), glTexture }, TextureSystem.prototype.updateTexture = function (texture) { var glTexture = texture._glTextures[this.CONTEXT_UID]; var renderer = this.renderer; if (texture.resource && texture.resource.upload(renderer, texture, glTexture));else { var width = texture.realWidth; var height = texture.realHeight; var gl = renderer.gl; (glTexture.width !== width || glTexture.height !== height || glTexture.dirtyId < 0) && (glTexture.width = width, glTexture.height = height, gl.texImage2D(texture.target, 0, texture.format, width, height, 0, texture.format, texture.type, null)) }texture.dirtyStyleId !== glTexture.dirtyStyleId && this.updateTextureStyle(texture), glTexture.dirtyId = texture.dirtyId }, TextureSystem.prototype.destroyTexture = function (texture, skipRemove) { var gl = this.gl; if ((texture = texture.baseTexture || texture)._glTextures[this.CONTEXT_UID] && (this.unbind(texture), gl.deleteTexture(texture._glTextures[this.CONTEXT_UID].texture), texture.off('dispose', this.destroyTexture, this), delete texture._glTextures[this.CONTEXT_UID], !skipRemove)) { var i = this.managedTextures.indexOf(texture); i !== -1 && removeItems(this.managedTextures, i, 1) } }, TextureSystem.prototype.updateTextureStyle = function (texture) { var glTexture = texture._glTextures[this.CONTEXT_UID]; glTexture && (texture.mipmap !== MIPMAP_MODES.POW2 && this.webGLVersion === 2 || texture.isPowerOfTwo ? (glTexture.mipmap = texture.mipmap >= 1, glTexture.wrapMode = texture.wrapMode) : (glTexture.mipmap = 0, glTexture.wrapMode = WRAP_MODES.CLAMP), texture.resource && texture.resource.style(this.renderer, texture, glTexture) || this.setStyle(texture, glTexture), glTexture.dirtyStyleId = texture.dirtyStyleId) }, TextureSystem.prototype.setStyle = function (texture, glTexture) { var gl = this.gl; glTexture.mipmap && gl.generateMipmap(texture.target), gl.texParameteri(texture.target, gl.TEXTURE_WRAP_S, glTexture.wrapMode), gl.texParameteri(texture.target, gl.TEXTURE_WRAP_T, glTexture.wrapMode), glTexture.mipmap ? gl.texParameteri(texture.target, gl.TEXTURE_MIN_FILTER, texture.scaleMode ? gl.LINEAR_MIPMAP_LINEAR : gl.NEAREST_MIPMAP_NEAREST) : gl.texParameteri(texture.target, gl.TEXTURE_MIN_FILTER, texture.scaleMode ? gl.LINEAR : gl.NEAREST), gl.texParameteri(texture.target, gl.TEXTURE_MAG_FILTER, texture.scaleMode ? gl.LINEAR : gl.NEAREST) }, TextureSystem }(System)); var systems = { FilterSystem: FilterSystem, BatchSystem: BatchSystem, ContextSystem: ContextSystem, FramebufferSystem: FramebufferSystem, GeometrySystem: GeometrySystem, MaskSystem: MaskSystem, StencilSystem: StencilSystem, ProjectionSystem: ProjectionSystem, RenderTextureSystem: RenderTextureSystem, ShaderSystem: ShaderSystem, StateSystem: StateSystem, TextureGCSystem: TextureGCSystem, TextureSystem: TextureSystem }; var tempMatrix = new Matrix(); var AbstractRenderer = (function (EventEmitter) { function AbstractRenderer (system, options) { EventEmitter.call(this), (options = Object.assign({}, settings.RENDER_OPTIONS, options)).roundPixels && (settings.ROUND_PIXELS = options.roundPixels, deprecation('5.0.0', 'Renderer roundPixels option is deprecated, please use PIXI.settings.ROUND_PIXELS', 2)), this.options = options, this.type = RENDERER_TYPE.UNKNOWN, this.screen = new Rectangle(0, 0, options.width, options.height), this.view = options.view || document.createElement('canvas'), this.resolution = options.resolution || settings.RESOLUTION, this.transparent = options.transparent, this.autoDensity = options.autoDensity || options.autoResize || !1, this.preserveDrawingBuffer = options.preserveDrawingBuffer, this.clearBeforeRender = options.clearBeforeRender, this._backgroundColor = 0, this._backgroundColorRgba = [0, 0, 0, 0], this._backgroundColorString = '#000000', this.backgroundColor = options.backgroundColor || this._backgroundColor, this._tempDisplayObjectParent = new Container(), this._lastObjectRendered = this._tempDisplayObjectParent, this.plugins = {} }EventEmitter && (AbstractRenderer.__proto__ = EventEmitter); var prototypeAccessors = { width: { configurable: !0 }, height: { configurable: !0 }, backgroundColor: { configurable: !0 } }; return ((AbstractRenderer.prototype = Object.create(EventEmitter && EventEmitter.prototype)).constructor = AbstractRenderer).prototype.initPlugins = function (staticMap) { for (var o in staticMap) this.plugins[o] = new staticMap[o](this) }, prototypeAccessors.width.get = function () { return this.view.width }, prototypeAccessors.height.get = function () { return this.view.height }, AbstractRenderer.prototype.resize = function (screenWidth, screenHeight) { this.screen.width = screenWidth, this.screen.height = screenHeight, this.view.width = screenWidth * this.resolution, this.view.height = screenHeight * this.resolution, this.autoDensity && (this.view.style.width = screenWidth + 'px', this.view.style.height = screenHeight + 'px') }, AbstractRenderer.prototype.generateTexture = function (displayObject, scaleMode, resolution, region) { (region = region || displayObject.getLocalBounds()).width === 0 && (region.width = 1), region.height === 0 && (region.height = 1); var renderTexture = RenderTexture.create(0 | region.width, 0 | region.height, scaleMode, resolution); return tempMatrix.tx = -region.x, tempMatrix.ty = -region.y, this.render(displayObject, renderTexture, !1, tempMatrix, !!displayObject.parent), renderTexture }, AbstractRenderer.prototype.destroy = function (removeView) { for (var o in this.plugins) this.plugins[o].destroy(), this.plugins[o] = null; removeView && this.view.parentNode && this.view.parentNode.removeChild(this.view), this.plugins = null, this.type = RENDERER_TYPE.UNKNOWN, this.view = null, this.screen = null, this.resolution = 0, this.transparent = !1, this.autoDensity = !1, this.blendModes = null, this.options = null, this.preserveDrawingBuffer = !1, this.clearBeforeRender = !1, this._backgroundColor = 0, this._backgroundColorRgba = null, this._backgroundColorString = null, this._tempDisplayObjectParent = null, this._lastObjectRendered = null }, prototypeAccessors.backgroundColor.get = function () { return this._backgroundColor }, prototypeAccessors.backgroundColor.set = function (value) { this._backgroundColor = value, this._backgroundColorString = hex2string(value), hex2rgb(value, this._backgroundColorRgba) }, Object.defineProperties(AbstractRenderer.prototype, prototypeAccessors), AbstractRenderer }(eventemitter3)); var Renderer = (function (AbstractRenderer) { function Renderer (options) { void 0 === options && (options = {}), AbstractRenderer.call(this, 'WebGL', options), options = this.options, this.type = RENDERER_TYPE.WEBGL, this.gl = null, this.CONTEXT_UID = 0, this.runners = { destroy: new Runner('destroy'), contextChange: new Runner('contextChange', 1), reset: new Runner('reset'), update: new Runner('update'), postrender: new Runner('postrender'), prerender: new Runner('prerender'), resize: new Runner('resize', 2) }, this.globalUniforms = new UniformGroup({ projectionMatrix: new Matrix() }, !0), this.addSystem(MaskSystem, 'mask').addSystem(ContextSystem, 'context').addSystem(StateSystem, 'state').addSystem(ShaderSystem, 'shader').addSystem(TextureSystem, 'texture').addSystem(GeometrySystem, 'geometry').addSystem(FramebufferSystem, 'framebuffer').addSystem(StencilSystem, 'stencil').addSystem(ProjectionSystem, 'projection').addSystem(TextureGCSystem, 'textureGC').addSystem(FilterSystem, 'filter').addSystem(RenderTextureSystem, 'renderTexture').addSystem(BatchSystem, 'batch'), this.initPlugins(Renderer.__plugins), options.context ? this.context.initFromContext(options.context) : this.context.initFromOptions({ alpha: this.transparent, antialias: options.antialias, premultipliedAlpha: this.transparent && this.transparent !== 'notMultiplied', stencil: !0, preserveDrawingBuffer: options.preserveDrawingBuffer, powerPreference: this.options.powerPreference }), this.renderingToScreen = !0, sayHello(this.context.webGLVersion === 2 ? 'WebGL 2' : 'WebGL 1'), this.resize(this.options.width, this.options.height) } return AbstractRenderer && (Renderer.__proto__ = AbstractRenderer), ((Renderer.prototype = Object.create(AbstractRenderer && AbstractRenderer.prototype)).constructor = Renderer).create = function (options) { if (isWebGLSupported()) return new Renderer(options); throw new Error('WebGL unsupported in this browser, use "pixi.js-legacy" for fallback canvas2d support.') }, Renderer.prototype.addSystem = function (ClassRef, name) { name = name || ClassRef.name; var system = new ClassRef(this); if (this[name]) throw new Error('Whoops! The name "' + name + '" is already in use'); for (var i in this[name] = system, this.runners) this.runners[i].add(system); return this }, Renderer.prototype.render = function (displayObject, renderTexture, clear, transform, skipUpdateTransform) { if (this.renderingToScreen = !renderTexture, this.runners.prerender.run(), this.emit('prerender'), this.projection.transform = transform, !this.context.isLost) { if (renderTexture || (this._lastObjectRendered = displayObject), !skipUpdateTransform) { var cacheParent = displayObject.parent; displayObject.parent = this._tempDisplayObjectParent, displayObject.updateTransform(), displayObject.parent = cacheParent } this.renderTexture.bind(renderTexture), this.batch.currentRenderer.start(), (void 0 !== clear ? clear : this.clearBeforeRender) && this.renderTexture.clear(), displayObject.render(this), this.batch.currentRenderer.flush(), renderTexture && renderTexture.baseTexture.update(), this.runners.postrender.run(), this.projection.transform = null, this.emit('postrender') } }, Renderer.prototype.resize = function (screenWidth, screenHeight) { AbstractRenderer.prototype.resize.call(this, screenWidth, screenHeight), this.runners.resize.run(screenWidth, screenHeight) }, Renderer.prototype.reset = function () { return this.runners.reset.run(), this }, Renderer.prototype.clear = function () { this.framebuffer.bind(), this.framebuffer.clear() }, Renderer.prototype.destroy = function (removeView) { this.runners.destroy.run(), AbstractRenderer.prototype.destroy.call(this, removeView), this.gl = null }, Renderer.registerPlugin = function (pluginName, ctor) { (Renderer.__plugins = Renderer.__plugins || {})[pluginName] = ctor }, Renderer }(AbstractRenderer)); function autoDetectRenderer (options) { return Renderer.create(options) } var _default = 'attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n    vTextureCoord = aTextureCoord;\n}'; var defaultFilter = 'attribute vec2 aVertexPosition;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nuniform vec4 inputSize;\nuniform vec4 outputFrame;\n\nvec4 filterVertexPosition( void )\n{\n    vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;\n\n    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\n}\n\nvec2 filterTextureCoord( void )\n{\n    return aVertexPosition * (outputFrame.zw * inputSize.zw);\n}\n\nvoid main(void)\n{\n    gl_Position = filterVertexPosition();\n    vTextureCoord = filterTextureCoord();\n}\n'; var CubeTexture = (function (BaseTexture) { function CubeTexture () { BaseTexture.apply(this, arguments) } return BaseTexture && (CubeTexture.__proto__ = BaseTexture), ((CubeTexture.prototype = Object.create(BaseTexture && BaseTexture.prototype)).constructor = CubeTexture).from = function (resources, options) { return new CubeTexture(new CubeResource(resources, options)) }, CubeTexture }(BaseTexture)); var BatchGeometry = (function (Geometry) { function BatchGeometry (_static) { void 0 === _static && (_static = !1), Geometry.call(this), this._buffer = new Buffer(null, _static, !1), this._indexBuffer = new Buffer(null, _static, !0), this.addAttribute('aVertexPosition', this._buffer, 2, !1, TYPES.FLOAT).addAttribute('aTextureCoord', this._buffer, 2, !1, TYPES.FLOAT).addAttribute('aColor', this._buffer, 4, !0, TYPES.UNSIGNED_BYTE).addAttribute('aTextureId', this._buffer, 1, !0, TYPES.FLOAT).addIndex(this._indexBuffer) } return Geometry && (BatchGeometry.__proto__ = Geometry), (BatchGeometry.prototype = Object.create(Geometry && Geometry.prototype)).constructor = BatchGeometry }(Geometry)); var BatchDrawCall = function () { this.textures = [], this.ids = [], this.blend = 0, this.textureCount = 0, this.start = 0, this.size = 0, this.type = 4 }; var BatchBuffer = function (size) { this.vertices = new ArrayBuffer(size), this.float32View = new Float32Array(this.vertices), this.uint32View = new Uint32Array(this.vertices) }; BatchBuffer.prototype.destroy = function () { this.vertices = null, this.float32View = null, this.uint32View = null }; var fragTemplate$1 = ['varying vec2 vTextureCoord;', 'varying vec4 vColor;', 'varying float vTextureId;', 'uniform sampler2D uSamplers[%count%];', 'void main(void){', 'vec4 color;', '%forloop%', 'gl_FragColor = color * vColor;', '}'].join('\n'); var defaultGroupCache = {}; var programCache = {}; function generateMultiTextureShader (gl, maxTextures) { if (!programCache[maxTextures]) { for (var sampleValues = new Int32Array(maxTextures), i = 0; i < maxTextures; i++)sampleValues[i] = i; defaultGroupCache[maxTextures] = UniformGroup.from({ uSamplers: sampleValues }, !0); var fragmentSrc = fragTemplate$1; fragmentSrc = (fragmentSrc = fragmentSrc.replace(/%count%/gi, maxTextures)).replace(/%forloop%/gi, (function (maxTextures) { var src = ''; src += '\n', src += '\n'; for (var i = 0; i < maxTextures; i++)i > 0 && (src += '\nelse '), i < maxTextures - 1 && (src += 'if(vTextureId < ' + i + '.5)'), src += '\n{', src += '\n\tcolor = texture2D(uSamplers[' + i + '], vTextureCoord);', src += '\n}'; return src += '\n', src += '\n' }(maxTextures))), programCache[maxTextures] = new Program('precision highp float;\nattribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\nattribute vec4 aColor;\nattribute float aTextureId;\n\nuniform mat3 projectionMatrix;\nuniform mat3 translationMatrix;\nuniform vec4 tint;\n\nvarying vec2 vTextureCoord;\nvarying vec4 vColor;\nvarying float vTextureId;\n\nvoid main(void){\n    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = aTextureCoord;\n    vTextureId = aTextureId;\n    vColor = aColor * tint;\n}\n', fragmentSrc) } var uniforms = { tint: new Float32Array([1, 1, 1, 1]), translationMatrix: new Matrix(), default: defaultGroupCache[maxTextures] }; return new Shader(programCache[maxTextures], uniforms) } var BatchRenderer = (function (ObjectRenderer) { function BatchRenderer (renderer) { ObjectRenderer.call(this, renderer), this.vertSize = 6, this.vertByteSize = 4 * this.vertSize, this.size = 8e3, this.currentSize = 0, this.currentIndexSize = 0, this.attributeBuffers = {}, this.aBuffers = {}, this.iBuffers = {}, this.onlySprites = !1, this.shader = null, this.currentIndex = 0, this.groups = []; for (var k = 0; k < this.size / 4; k++) this.groups[k] = new BatchDrawCall(); this.elements = [], this.vaos = [], this.vaoMax = 2, this.vertexCount = 0, this.renderer.on('prerender', this.onPrerender, this), this.state = State.for2d() } return ObjectRenderer && (BatchRenderer.__proto__ = ObjectRenderer), ((BatchRenderer.prototype = Object.create(ObjectRenderer && ObjectRenderer.prototype)).constructor = BatchRenderer).prototype.contextChange = function () { var gl = this.renderer.gl; settings.PREFER_ENV === ENV.WEBGL_LEGACY ? this.MAX_TEXTURES = 1 : (this.MAX_TEXTURES = Math.min(gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS), settings.SPRITE_MAX_TEXTURES), this.MAX_TEXTURES = checkMaxIfStatementsInShader(this.MAX_TEXTURES, gl)), this.shader = generateMultiTextureShader(0, this.MAX_TEXTURES); for (var i = 0; i < this.vaoMax; i++) this.vaos[i] = new BatchGeometry() }, BatchRenderer.prototype.onPrerender = function () { this.vertexCount = 0 }, BatchRenderer.prototype.render = function (element) { element._texture.valid && (this.currentSize + element.vertexData.length / 2 > this.size && this.flush(), this.elements[this.currentIndex++] = element, this.currentSize += element.vertexData.length / 2, this.currentIndexSize += element.indices.length) }, BatchRenderer.prototype.getIndexBuffer = function (size) { var roundedP2 = nextPow2(Math.ceil(size / 12)); var roundedSizeIndex = log2(roundedP2); var roundedSize = 12 * roundedP2; this.iBuffers.length <= roundedSizeIndex && (this.iBuffers.length = roundedSizeIndex + 1); var buffer = this.iBuffers[roundedSizeIndex]; return buffer || (this.iBuffers[roundedSizeIndex] = buffer = new Uint16Array(roundedSize)), buffer }, BatchRenderer.prototype.getAttributeBuffer = function (size) { var roundedP2 = nextPow2(Math.ceil(size / 8)); var roundedSizeIndex = log2(roundedP2); var roundedSize = 8 * roundedP2; this.aBuffers.length <= roundedSizeIndex && (this.iBuffers.length = roundedSizeIndex + 1); var buffer = this.aBuffers[roundedSize]; return buffer || (this.aBuffers[roundedSize] = buffer = new BatchBuffer(roundedSize * this.vertByteSize)), buffer }, BatchRenderer.prototype.flush = function () { if (this.currentSize !== 0) { var nextTexture; var currentTexture; var gl = this.renderer.gl; var MAX_TEXTURES = this.MAX_TEXTURES; var buffer = this.getAttributeBuffer(this.currentSize); var indexBuffer = this.getIndexBuffer(this.currentIndexSize); var elements = this.elements; var groups = this.groups; var float32View = buffer.float32View; var uint32View = buffer.uint32View; var touch = this.renderer.textureGC.count; var index = 0; var indexCount = 0; var groupCount = 0; var textureCount = 0; var currentGroup = groups[0]; var blendMode = -1; currentGroup.textureCount = 0, currentGroup.start = 0, currentGroup.blend = blendMode; var i; var TICK = ++BaseTexture._globalBatch; for (i = 0; i < this.currentIndex; ++i) { var sprite = elements[i]; elements[i] = null, nextTexture = sprite._texture.baseTexture; var spriteBlendMode = premultiplyBlendMode[nextTexture.premultiplyAlpha ? 1 : 0][sprite.blendMode]; blendMode !== spriteBlendMode && (blendMode = spriteBlendMode, currentTexture = null, textureCount = MAX_TEXTURES, TICK++), currentTexture !== nextTexture && (currentTexture = nextTexture)._batchEnabled !== TICK && (textureCount === MAX_TEXTURES && (TICK++, textureCount = 0, currentGroup.size = indexCount - currentGroup.start, (currentGroup = groups[groupCount++]).textureCount = 0, currentGroup.blend = blendMode, currentGroup.start = indexCount), nextTexture.touched = touch, nextTexture._batchEnabled = TICK, nextTexture._id = textureCount, currentGroup.textures[currentGroup.textureCount++] = nextTexture, textureCount++), this.packGeometry(sprite, float32View, uint32View, indexBuffer, index, indexCount), index += sprite.vertexData.length / 2 * this.vertSize, indexCount += sprite.indices.length }BaseTexture._globalBatch = TICK, currentGroup.size = indexCount - currentGroup.start, settings.CAN_UPLOAD_SAME_BUFFER ? (this.vaos[this.vertexCount]._buffer.update(buffer.vertices, 0), this.vaos[this.vertexCount]._indexBuffer.update(indexBuffer, 0), this.renderer.geometry.updateBuffers()) : (this.vaoMax <= this.vertexCount && (this.vaoMax++, this.vaos[this.vertexCount] = new BatchGeometry()), this.vaos[this.vertexCount]._buffer.update(buffer.vertices, 0), this.vaos[this.vertexCount]._indexBuffer.update(indexBuffer, 0), this.renderer.geometry.bind(this.vaos[this.vertexCount]), this.renderer.geometry.updateBuffers(), this.vertexCount++); var textureSystem = this.renderer.texture; var stateSystem = this.renderer.state; for (i = 0; i < groupCount; i++) { for (var group = groups[i], groupTextureCount = group.textureCount, j = 0; j < groupTextureCount; j++)textureSystem.bind(group.textures[j], j), group.textures[j] = null; stateSystem.setBlendMode(group.blend), gl.drawElements(group.type, group.size, gl.UNSIGNED_SHORT, 2 * group.start) } this.currentIndex = 0, this.currentSize = 0, this.currentIndexSize = 0 } }, BatchRenderer.prototype.packGeometry = function (element, float32View, uint32View, indexBuffer, index, indexCount) { for (var p = index / this.vertSize, uvs = element.uvs, indicies = element.indices, vertexData = element.vertexData, textureId = element._texture.baseTexture._id, alpha = Math.min(element.worldAlpha, 1), argb = alpha < 1 && element._texture.baseTexture.premultiplyAlpha ? premultiplyTint(element._tintRGB, alpha) : element._tintRGB + (255 * alpha << 24), i = 0; i < vertexData.length; i += 2)float32View[index++] = vertexData[i], float32View[index++] = vertexData[i + 1], float32View[index++] = uvs[i], float32View[index++] = uvs[i + 1], uint32View[index++] = argb, float32View[index++] = textureId; for (var i$1 = 0; i$1 < indicies.length; i$1++)indexBuffer[indexCount++] = p + indicies[i$1] }, BatchRenderer.prototype.start = function () { this.renderer.state.setState(this.state), this.renderer.shader.bind(this.shader), settings.CAN_UPLOAD_SAME_BUFFER && this.renderer.geometry.bind(this.vaos[this.vertexCount]) }, BatchRenderer.prototype.stop = function () { this.flush() }, BatchRenderer.prototype.destroy = function () { for (var i = 0; i < this.vaoMax; i++) this.vaos[i] && this.vaos[i].destroy(); this.indexBuffer && this.indexBuffer.destroy(), this.renderer.off('prerender', this.onPrerender, this), this.shader && (this.shader.destroy(), this.shader = null), this.vaos = null, this.indexBuffer = null, this.indices = null, this.sprites = null, ObjectRenderer.prototype.destroy.call(this) }, BatchRenderer }(ObjectRenderer)); var TEMP_RECT = new Rectangle(); var Extract = function (renderer) { (this.renderer = renderer).extract = this }; Extract.prototype.image = function (target, format, quality) { var image = new Image(); return image.src = this.base64(target, format, quality), image }, Extract.prototype.base64 = function (target, format, quality) { return this.canvas(target).toDataURL(format, quality) }, Extract.prototype.canvas = function (target) { var resolution; var frame; var renderTexture; var renderer = this.renderer; var flipY = !1; var generated = !1; target && (target instanceof RenderTexture ? renderTexture = target : (renderTexture = this.renderer.generateTexture(target), generated = !0)), renderTexture ? (resolution = renderTexture.baseTexture.resolution, frame = renderTexture.frame, flipY = !1, renderer.renderTexture.bind(renderTexture)) : (resolution = this.renderer.resolution, flipY = !0, (frame = TEMP_RECT).width = this.renderer.width, frame.height = this.renderer.height, renderer.renderTexture.bind(null)); var width = frame.width * resolution; var height = frame.height * resolution; var canvasBuffer = new CanvasRenderTarget(width, height, 1); var webglPixels = new Uint8Array(4 * width * height); var gl = renderer.gl; gl.readPixels(frame.x * resolution, frame.y * resolution, width, height, gl.RGBA, gl.UNSIGNED_BYTE, webglPixels); var canvasData = canvasBuffer.context.getImageData(0, 0, width, height); return canvasData.data.set(webglPixels), canvasBuffer.context.putImageData(canvasData, 0, 0), flipY && (canvasBuffer.context.scale(1, -1), canvasBuffer.context.drawImage(canvasBuffer.canvas, 0, -height)), generated && renderTexture.destroy(!0), canvasBuffer.canvas }, Extract.prototype.pixels = function (target) { var resolution; var frame; var renderTexture; var renderer = this.renderer; var generated = !1; target && (target instanceof RenderTexture ? renderTexture = target : (renderTexture = this.renderer.generateTexture(target), generated = !0)), renderTexture ? (resolution = renderTexture.baseTexture.resolution, frame = renderTexture.frame, renderer.renderTexture.bind(renderTexture)) : (resolution = renderer.resolution, (frame = TEMP_RECT).width = renderer.width, frame.height = renderer.height, renderer.renderTexture.bind(null)); var width = frame.width * resolution; var height = frame.height * resolution; var webglPixels = new Uint8Array(4 * width * height); var gl = renderer.gl; return gl.readPixels(frame.x * resolution, frame.y * resolution, width, height, gl.RGBA, gl.UNSIGNED_BYTE, webglPixels), generated && renderTexture.destroy(!0), webglPixels }, Extract.prototype.destroy = function () { this.renderer.extract = null, this.renderer = null }; var extract_es = { Extract: Extract }; var InteractionData = function () { this.global = new Point(), this.target = null, this.originalEvent = null, this.identifier = null, this.isPrimary = !1, this.button = 0, this.buttons = 0, this.width = 0, this.height = 0, this.tiltX = 0, this.tiltY = 0, this.pointerType = null, this.pressure = 0, this.rotationAngle = 0, this.twist = 0, this.tangentialPressure = 0 }; var prototypeAccessors$6 = { pointerId: { configurable: !0 } }; prototypeAccessors$6.pointerId.get = function () { return this.identifier }, InteractionData.prototype.getLocalPosition = function (displayObject, point, globalPos) { return displayObject.worldTransform.applyInverse(globalPos || this.global, point) }, InteractionData.prototype.copyEvent = function (event) { event.isPrimary && (this.isPrimary = !0), this.button = event.button, this.buttons = Number.isInteger(event.buttons) ? event.buttons : event.which, this.width = event.width, this.height = event.height, this.tiltX = event.tiltX, this.tiltY = event.tiltY, this.pointerType = event.pointerType, this.pressure = event.pressure, this.rotationAngle = event.rotationAngle, this.twist = event.twist || 0, this.tangentialPressure = event.tangentialPressure || 0 }, InteractionData.prototype.reset = function () { this.isPrimary = !1 }, Object.defineProperties(InteractionData.prototype, prototypeAccessors$6); var InteractionEvent = function () { this.stopped = !1, this.target = null, this.currentTarget = null, this.type = null, this.data = null }; InteractionEvent.prototype.stopPropagation = function () { this.stopped = !0 }, InteractionEvent.prototype.reset = function () { this.stopped = !1, this.currentTarget = null, this.target = null }; function InteractionTrackingData (pointerId) { this._pointerId = pointerId, this._flags = InteractionTrackingData.FLAGS.NONE } var prototypeAccessors$1$3 = { pointerId: { configurable: !0 }, flags: { configurable: !0 }, none: { configurable: !0 }, over: { configurable: !0 }, rightDown: { configurable: !0 }, leftDown: { configurable: !0 } }; InteractionTrackingData.prototype._doSet = function (flag, yn) { this._flags = yn ? this._flags | flag : this._flags & ~flag }, prototypeAccessors$1$3.pointerId.get = function () { return this._pointerId }, prototypeAccessors$1$3.flags.get = function () { return this._flags }, prototypeAccessors$1$3.flags.set = function (flags) { this._flags = flags }, prototypeAccessors$1$3.none.get = function () { return this._flags === this.constructor.FLAGS.NONE }, prototypeAccessors$1$3.over.get = function () { return (this._flags & this.constructor.FLAGS.OVER) != 0 }, prototypeAccessors$1$3.over.set = function (yn) { this._doSet(this.constructor.FLAGS.OVER, yn) }, prototypeAccessors$1$3.rightDown.get = function () { return (this._flags & this.constructor.FLAGS.RIGHT_DOWN) != 0 }, prototypeAccessors$1$3.rightDown.set = function (yn) { this._doSet(this.constructor.FLAGS.RIGHT_DOWN, yn) }, prototypeAccessors$1$3.leftDown.get = function () { return (this._flags & this.constructor.FLAGS.LEFT_DOWN) != 0 }, prototypeAccessors$1$3.leftDown.set = function (yn) { this._doSet(this.constructor.FLAGS.LEFT_DOWN, yn) }, Object.defineProperties(InteractionTrackingData.prototype, prototypeAccessors$1$3), InteractionTrackingData.FLAGS = Object.freeze({ NONE: 0, OVER: 1, LEFT_DOWN: 2, RIGHT_DOWN: 4 }); var interactiveTarget = { interactive: !1, interactiveChildren: !0, hitArea: null, get buttonMode () { return this.cursor === 'pointer' }, set buttonMode (value) { value ? this.cursor = 'pointer' : this.cursor === 'pointer' && (this.cursor = null) }, cursor: null, get trackedPointers () { return void 0 === this._trackedPointers && (this._trackedPointers = {}), this._trackedPointers }, _trackedPointers: void 0 }; DisplayObject.mixin(interactiveTarget); var hitTestEvent = { target: null, data: { global: null } }; var InteractionManager = (function (EventEmitter) { function InteractionManager (renderer, options) { EventEmitter.call(this), options = options || {}, this.renderer = renderer, this.autoPreventDefault = void 0 === options.autoPreventDefault || options.autoPreventDefault, this.interactionFrequency = options.interactionFrequency || 10, this.mouse = new InteractionData(), this.mouse.identifier = 1, this.mouse.global.set(-999999), this.activeInteractionData = {}, this.activeInteractionData[1] = this.mouse, this.interactionDataPool = [], this.eventData = new InteractionEvent(), this.interactionDOMElement = null, this.moveWhenInside = !1, this.eventsAdded = !1, this.mouseOverRenderer = !1, this.supportsTouchEvents = 'ontouchstart' in window, this.supportsPointerEvents = !!window.PointerEvent, this.onPointerUp = this.onPointerUp.bind(this), this.processPointerUp = this.processPointerUp.bind(this), this.onPointerCancel = this.onPointerCancel.bind(this), this.processPointerCancel = this.processPointerCancel.bind(this), this.onPointerDown = this.onPointerDown.bind(this), this.processPointerDown = this.processPointerDown.bind(this), this.onPointerMove = this.onPointerMove.bind(this), this.processPointerMove = this.processPointerMove.bind(this), this.onPointerOut = this.onPointerOut.bind(this), this.processPointerOverOut = this.processPointerOverOut.bind(this), this.onPointerOver = this.onPointerOver.bind(this), this.cursorStyles = { default: 'inherit', pointer: 'pointer' }, this.currentCursorMode = null, this.cursor = null, this._tempPoint = new Point(), this.resolution = 1, this.setTargetElement(this.renderer.view, this.renderer.resolution) } return EventEmitter && (InteractionManager.__proto__ = EventEmitter), ((InteractionManager.prototype = Object.create(EventEmitter && EventEmitter.prototype)).constructor = InteractionManager).prototype.hitTest = function (globalPoint, root) { return hitTestEvent.target = null, hitTestEvent.data.global = globalPoint, root = root || this.renderer._lastObjectRendered, this.processInteractive(hitTestEvent, root, null, !0), hitTestEvent.target }, InteractionManager.prototype.setTargetElement = function (element, resolution) { void 0 === resolution && (resolution = 1), this.removeEvents(), this.interactionDOMElement = element, this.resolution = resolution, this.addEvents() }, InteractionManager.prototype.addEvents = function () { this.interactionDOMElement && (Ticker.system.add(this.update, this, UPDATE_PRIORITY.INTERACTION), window.navigator.msPointerEnabled ? (this.interactionDOMElement.style['-ms-content-zooming'] = 'none', this.interactionDOMElement.style['-ms-touch-action'] = 'none') : this.supportsPointerEvents && (this.interactionDOMElement.style['touch-action'] = 'none'), this.supportsPointerEvents ? (window.document.addEventListener('pointermove', this.onPointerMove, !0), this.interactionDOMElement.addEventListener('pointerdown', this.onPointerDown, !0), this.interactionDOMElement.addEventListener('pointerleave', this.onPointerOut, !0), this.interactionDOMElement.addEventListener('pointerover', this.onPointerOver, !0), window.addEventListener('pointercancel', this.onPointerCancel, !0), window.addEventListener('pointerup', this.onPointerUp, !0)) : (window.document.addEventListener('mousemove', this.onPointerMove, !0), this.interactionDOMElement.addEventListener('mousedown', this.onPointerDown, !0), this.interactionDOMElement.addEventListener('mouseout', this.onPointerOut, !0), this.interactionDOMElement.addEventListener('mouseover', this.onPointerOver, !0), window.addEventListener('mouseup', this.onPointerUp, !0)), this.supportsTouchEvents && (this.interactionDOMElement.addEventListener('touchstart', this.onPointerDown, !0), this.interactionDOMElement.addEventListener('touchcancel', this.onPointerCancel, !0), this.interactionDOMElement.addEventListener('touchend', this.onPointerUp, !0), this.interactionDOMElement.addEventListener('touchmove', this.onPointerMove, !0)), this.eventsAdded = !0) }, InteractionManager.prototype.removeEvents = function () { this.interactionDOMElement && (Ticker.system.remove(this.update, this), window.navigator.msPointerEnabled ? (this.interactionDOMElement.style['-ms-content-zooming'] = '', this.interactionDOMElement.style['-ms-touch-action'] = '') : this.supportsPointerEvents && (this.interactionDOMElement.style['touch-action'] = ''), this.supportsPointerEvents ? (window.document.removeEventListener('pointermove', this.onPointerMove, !0), this.interactionDOMElement.removeEventListener('pointerdown', this.onPointerDown, !0), this.interactionDOMElement.removeEventListener('pointerleave', this.onPointerOut, !0), this.interactionDOMElement.removeEventListener('pointerover', this.onPointerOver, !0), window.removeEventListener('pointercancel', this.onPointerCancel, !0), window.removeEventListener('pointerup', this.onPointerUp, !0)) : (window.document.removeEventListener('mousemove', this.onPointerMove, !0), this.interactionDOMElement.removeEventListener('mousedown', this.onPointerDown, !0), this.interactionDOMElement.removeEventListener('mouseout', this.onPointerOut, !0), this.interactionDOMElement.removeEventListener('mouseover', this.onPointerOver, !0), window.removeEventListener('mouseup', this.onPointerUp, !0)), this.supportsTouchEvents && (this.interactionDOMElement.removeEventListener('touchstart', this.onPointerDown, !0), this.interactionDOMElement.removeEventListener('touchcancel', this.onPointerCancel, !0), this.interactionDOMElement.removeEventListener('touchend', this.onPointerUp, !0), this.interactionDOMElement.removeEventListener('touchmove', this.onPointerMove, !0)), this.interactionDOMElement = null, this.eventsAdded = !1) }, InteractionManager.prototype.update = function (deltaTime) { if (this._deltaTime += deltaTime, !(this._deltaTime < this.interactionFrequency) && (this._deltaTime = 0, this.interactionDOMElement)) if (this.didMove) this.didMove = !1; else { for (var k in this.cursor = null, this.activeInteractionData) if (this.activeInteractionData.hasOwnProperty(k)) { var interactionData = this.activeInteractionData[k]; if (interactionData.originalEvent && interactionData.pointerType !== 'touch') { var interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, interactionData.originalEvent, interactionData); this.processInteractive(interactionEvent, this.renderer._lastObjectRendered, this.processPointerOverOut, !0) } } this.setCursorMode(this.cursor) } }, InteractionManager.prototype.setCursorMode = function (mode) { if (mode = mode || 'default', this.currentCursorMode !== mode) { this.currentCursorMode = mode; var style = this.cursorStyles[mode]; if (style) switch (typeof style) { case 'string':this.interactionDOMElement.style.cursor = style; break; case 'function':style(mode); break; case 'object':Object.assign(this.interactionDOMElement.style, style) } else typeof mode !== 'string' || Object.prototype.hasOwnProperty.call(this.cursorStyles, mode) || (this.interactionDOMElement.style.cursor = mode) } }, InteractionManager.prototype.dispatchEvent = function (displayObject, eventString, eventData) { eventData.stopped || (eventData.currentTarget = displayObject, eventData.type = eventString, displayObject.emit(eventString, eventData), displayObject[eventString] && displayObject[eventString](eventData)) }, InteractionManager.prototype.mapPositionToPoint = function (point, x, y) { var rect; rect = this.interactionDOMElement.parentElement ? this.interactionDOMElement.getBoundingClientRect() : { x: 0, y: 0, width: 0, height: 0 }; var resolutionMultiplier = 1 / this.resolution; point.x = (x - rect.left) * (this.interactionDOMElement.width / rect.width) * resolutionMultiplier, point.y = (y - rect.top) * (this.interactionDOMElement.height / rect.height) * resolutionMultiplier }, InteractionManager.prototype.processInteractive = function (interactionEvent, displayObject, func, hitTest, interactive) { if (!displayObject || !displayObject.visible) return !1; var point = interactionEvent.data.global; var hit = !1; var interactiveParent = interactive = displayObject.interactive || interactive; var hitTestChildren = !0; if (displayObject.hitArea ? (hitTest && (displayObject.worldTransform.applyInverse(point, this._tempPoint), displayObject.hitArea.contains(this._tempPoint.x, this._tempPoint.y) ? hit = !0 : hitTestChildren = hitTest = !1), interactiveParent = !1) : displayObject._mask && hitTest && (displayObject._mask.containsPoint && displayObject._mask.containsPoint(point) || (hitTest = !1)), hitTestChildren && displayObject.interactiveChildren && displayObject.children) for (var children = displayObject.children, i = children.length - 1; i >= 0; i--) { var child = children[i]; var childHit = this.processInteractive(interactionEvent, child, func, hitTest, interactiveParent); if (childHit) { if (!child.parent) continue; interactiveParent = !1, childHit && (interactionEvent.target && (hitTest = !1), hit = !0) } } return interactive && (hitTest && !interactionEvent.target && !displayObject.hitArea && displayObject.containsPoint && displayObject.containsPoint(point) && (hit = !0), displayObject.interactive && (hit && !interactionEvent.target && (interactionEvent.target = displayObject), func && func(interactionEvent, displayObject, !!hit))), hit }, InteractionManager.prototype.onPointerDown = function (originalEvent) { if (!this.supportsTouchEvents || originalEvent.pointerType !== 'touch') { var events = this.normalizeToPointerData(originalEvent); if (this.autoPreventDefault && events[0].isNormalized)(originalEvent.cancelable || !('cancelable' in originalEvent)) && originalEvent.preventDefault(); for (var eventLen = events.length, i = 0; i < eventLen; i++) { var event = events[i]; var interactionData = this.getInteractionDataForPointerId(event); var interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, event, interactionData); if (interactionEvent.data.originalEvent = originalEvent, this.processInteractive(interactionEvent, this.renderer._lastObjectRendered, this.processPointerDown, !0), this.emit('pointerdown', interactionEvent), event.pointerType === 'touch') this.emit('touchstart', interactionEvent); else if (event.pointerType === 'mouse' || event.pointerType === 'pen') { var isRightButton = event.button === 2; this.emit(isRightButton ? 'rightdown' : 'mousedown', this.eventData) } } } }, InteractionManager.prototype.processPointerDown = function (interactionEvent, displayObject, hit) { var data = interactionEvent.data; var id = interactionEvent.data.identifier; if (hit) if (displayObject.trackedPointers[id] || (displayObject.trackedPointers[id] = new InteractionTrackingData(id)), this.dispatchEvent(displayObject, 'pointerdown', interactionEvent), data.pointerType === 'touch') this.dispatchEvent(displayObject, 'touchstart', interactionEvent); else if (data.pointerType === 'mouse' || data.pointerType === 'pen') { var isRightButton = data.button === 2; isRightButton ? displayObject.trackedPointers[id].rightDown = !0 : displayObject.trackedPointers[id].leftDown = !0, this.dispatchEvent(displayObject, isRightButton ? 'rightdown' : 'mousedown', interactionEvent) } }, InteractionManager.prototype.onPointerComplete = function (originalEvent, cancelled, func) { for (var events = this.normalizeToPointerData(originalEvent), eventLen = events.length, eventAppend = originalEvent.target !== this.interactionDOMElement ? 'outside' : '', i = 0; i < eventLen; i++) { var event = events[i]; var interactionData = this.getInteractionDataForPointerId(event); var interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, event, interactionData); if (interactionEvent.data.originalEvent = originalEvent, this.processInteractive(interactionEvent, this.renderer._lastObjectRendered, func, cancelled || !eventAppend), this.emit(cancelled ? 'pointercancel' : 'pointerup' + eventAppend, interactionEvent), event.pointerType === 'mouse' || event.pointerType === 'pen') { var isRightButton = event.button === 2; this.emit(isRightButton ? 'rightup' + eventAppend : 'mouseup' + eventAppend, interactionEvent) } else event.pointerType === 'touch' && (this.emit(cancelled ? 'touchcancel' : 'touchend' + eventAppend, interactionEvent), this.releaseInteractionDataForPointerId(event.pointerId, interactionData)) } }, InteractionManager.prototype.onPointerCancel = function (event) { this.supportsTouchEvents && event.pointerType === 'touch' || this.onPointerComplete(event, !0, this.processPointerCancel) }, InteractionManager.prototype.processPointerCancel = function (interactionEvent, displayObject) { var data = interactionEvent.data; var id = interactionEvent.data.identifier; void 0 !== displayObject.trackedPointers[id] && (delete displayObject.trackedPointers[id], this.dispatchEvent(displayObject, 'pointercancel', interactionEvent), data.pointerType === 'touch' && this.dispatchEvent(displayObject, 'touchcancel', interactionEvent)) }, InteractionManager.prototype.onPointerUp = function (event) { this.supportsTouchEvents && event.pointerType === 'touch' || this.onPointerComplete(event, !1, this.processPointerUp) }, InteractionManager.prototype.processPointerUp = function (interactionEvent, displayObject, hit) { var data = interactionEvent.data; var id = interactionEvent.data.identifier; var trackingData = displayObject.trackedPointers[id]; var isTouch = data.pointerType === 'touch'; var isMouse = data.pointerType === 'mouse' || data.pointerType === 'pen'; var isMouseTap = !1; if (isMouse) { var isRightButton = data.button === 2; var flags = InteractionTrackingData.FLAGS; var test = isRightButton ? flags.RIGHT_DOWN : flags.LEFT_DOWN; var isDown = void 0 !== trackingData && trackingData.flags & test; hit ? (this.dispatchEvent(displayObject, isRightButton ? 'rightup' : 'mouseup', interactionEvent), isDown && (this.dispatchEvent(displayObject, isRightButton ? 'rightclick' : 'click', interactionEvent), isMouseTap = !0)) : isDown && this.dispatchEvent(displayObject, isRightButton ? 'rightupoutside' : 'mouseupoutside', interactionEvent), trackingData && (isRightButton ? trackingData.rightDown = !1 : trackingData.leftDown = !1) }hit ? (this.dispatchEvent(displayObject, 'pointerup', interactionEvent), isTouch && this.dispatchEvent(displayObject, 'touchend', interactionEvent), trackingData && (isMouse && !isMouseTap || this.dispatchEvent(displayObject, 'pointertap', interactionEvent), isTouch && (this.dispatchEvent(displayObject, 'tap', interactionEvent), trackingData.over = !1))) : trackingData && (this.dispatchEvent(displayObject, 'pointerupoutside', interactionEvent), isTouch && this.dispatchEvent(displayObject, 'touchendoutside', interactionEvent)), trackingData && trackingData.none && delete displayObject.trackedPointers[id] }, InteractionManager.prototype.onPointerMove = function (originalEvent) { if (!this.supportsTouchEvents || originalEvent.pointerType !== 'touch') { var events = this.normalizeToPointerData(originalEvent); events[0].pointerType !== 'mouse' && events[0].pointerType !== 'pen' || (this.didMove = !0, this.cursor = null); for (var eventLen = events.length, i = 0; i < eventLen; i++) { var event = events[i]; var interactionData = this.getInteractionDataForPointerId(event); var interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, event, interactionData); interactionEvent.data.originalEvent = originalEvent; var interactive = event.pointerType !== 'touch' || this.moveWhenInside; this.processInteractive(interactionEvent, this.renderer._lastObjectRendered, this.processPointerMove, interactive), this.emit('pointermove', interactionEvent), event.pointerType === 'touch' && this.emit('touchmove', interactionEvent), event.pointerType !== 'mouse' && event.pointerType !== 'pen' || this.emit('mousemove', interactionEvent) }events[0].pointerType === 'mouse' && this.setCursorMode(this.cursor) } }, InteractionManager.prototype.processPointerMove = function (interactionEvent, displayObject, hit) { var data = interactionEvent.data; var isTouch = data.pointerType === 'touch'; var isMouse = data.pointerType === 'mouse' || data.pointerType === 'pen'; isMouse && this.processPointerOverOut(interactionEvent, displayObject, hit), this.moveWhenInside && !hit || (this.dispatchEvent(displayObject, 'pointermove', interactionEvent), isTouch && this.dispatchEvent(displayObject, 'touchmove', interactionEvent), isMouse && this.dispatchEvent(displayObject, 'mousemove', interactionEvent)) }, InteractionManager.prototype.onPointerOut = function (originalEvent) { if (!this.supportsTouchEvents || originalEvent.pointerType !== 'touch') { var event = this.normalizeToPointerData(originalEvent)[0]; event.pointerType === 'mouse' && (this.mouseOverRenderer = !1, this.setCursorMode(null)); var interactionData = this.getInteractionDataForPointerId(event); var interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, event, interactionData); interactionEvent.data.originalEvent = event, this.processInteractive(interactionEvent, this.renderer._lastObjectRendered, this.processPointerOverOut, !1), this.emit('pointerout', interactionEvent), event.pointerType === 'mouse' || event.pointerType === 'pen' ? this.emit('mouseout', interactionEvent) : this.releaseInteractionDataForPointerId(interactionData.identifier) } }, InteractionManager.prototype.processPointerOverOut = function (interactionEvent, displayObject, hit) { var data = interactionEvent.data; var id = interactionEvent.data.identifier; var isMouse = data.pointerType === 'mouse' || data.pointerType === 'pen'; var trackingData = displayObject.trackedPointers[id]; hit && !trackingData && (trackingData = displayObject.trackedPointers[id] = new InteractionTrackingData(id)), void 0 !== trackingData && (hit && this.mouseOverRenderer ? (trackingData.over || (trackingData.over = !0, this.dispatchEvent(displayObject, 'pointerover', interactionEvent), isMouse && this.dispatchEvent(displayObject, 'mouseover', interactionEvent)), isMouse && this.cursor === null && (this.cursor = displayObject.cursor)) : trackingData.over && (trackingData.over = !1, this.dispatchEvent(displayObject, 'pointerout', this.eventData), isMouse && this.dispatchEvent(displayObject, 'mouseout', interactionEvent), trackingData.none && delete displayObject.trackedPointers[id])) }, InteractionManager.prototype.onPointerOver = function (originalEvent) { var event = this.normalizeToPointerData(originalEvent)[0]; var interactionData = this.getInteractionDataForPointerId(event); var interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, event, interactionData); (interactionEvent.data.originalEvent = event).pointerType === 'mouse' && (this.mouseOverRenderer = !0), this.emit('pointerover', interactionEvent), event.pointerType !== 'mouse' && event.pointerType !== 'pen' || this.emit('mouseover', interactionEvent) }, InteractionManager.prototype.getInteractionDataForPointerId = function (event) { var interactionData; var pointerId = event.pointerId; return pointerId === 1 || event.pointerType === 'mouse' ? interactionData = this.mouse : this.activeInteractionData[pointerId] ? interactionData = this.activeInteractionData[pointerId] : ((interactionData = this.interactionDataPool.pop() || new InteractionData()).identifier = pointerId, this.activeInteractionData[pointerId] = interactionData), interactionData.copyEvent(event), interactionData }, InteractionManager.prototype.releaseInteractionDataForPointerId = function (pointerId) { var interactionData = this.activeInteractionData[pointerId]; interactionData && (delete this.activeInteractionData[pointerId], interactionData.reset(), this.interactionDataPool.push(interactionData)) }, InteractionManager.prototype.configureInteractionEventForDOMEvent = function (interactionEvent, pointerEvent, interactionData) { return interactionEvent.data = interactionData, this.mapPositionToPoint(interactionData.global, pointerEvent.clientX, pointerEvent.clientY), pointerEvent.pointerType === 'touch' && (pointerEvent.globalX = interactionData.global.x, pointerEvent.globalY = interactionData.global.y), interactionData.originalEvent = pointerEvent, interactionEvent.reset(), interactionEvent }, InteractionManager.prototype.normalizeToPointerData = function (event) { var normalizedEvents = []; if (this.supportsTouchEvents && event instanceof TouchEvent) for (var i = 0, li = event.changedTouches.length; i < li; i++) { var touch = event.changedTouches[i]; void 0 === touch.button && (touch.button = event.touches.length ? 1 : 0), void 0 === touch.buttons && (touch.buttons = event.touches.length ? 1 : 0), void 0 === touch.isPrimary && (touch.isPrimary = event.touches.length === 1 && event.type === 'touchstart'), void 0 === touch.width && (touch.width = touch.radiusX || 1), void 0 === touch.height && (touch.height = touch.radiusY || 1), void 0 === touch.tiltX && (touch.tiltX = 0), void 0 === touch.tiltY && (touch.tiltY = 0), void 0 === touch.pointerType && (touch.pointerType = 'touch'), void 0 === touch.pointerId && (touch.pointerId = touch.identifier || 0), void 0 === touch.pressure && (touch.pressure = touch.force || 0.5), void 0 === touch.twist && (touch.twist = 0), void 0 === touch.tangentialPressure && (touch.tangentialPressure = 0), void 0 === touch.layerX && (touch.layerX = touch.offsetX = touch.clientX), void 0 === touch.layerY && (touch.layerY = touch.offsetY = touch.clientY), touch.isNormalized = !0, normalizedEvents.push(touch) } else !(event instanceof MouseEvent) || this.supportsPointerEvents && event instanceof window.PointerEvent || (void 0 === event.isPrimary && (event.isPrimary = !0), void 0 === event.width && (event.width = 1), void 0 === event.height && (event.height = 1), void 0 === event.tiltX && (event.tiltX = 0), void 0 === event.tiltY && (event.tiltY = 0), void 0 === event.pointerType && (event.pointerType = 'mouse'), void 0 === event.pointerId && (event.pointerId = 1), void 0 === event.pressure && (event.pressure = 0.5), void 0 === event.twist && (event.twist = 0), void 0 === event.tangentialPressure && (event.tangentialPressure = 0), event.isNormalized = !0), normalizedEvents.push(event); return normalizedEvents }, InteractionManager.prototype.destroy = function () { this.removeEvents(), this.removeAllListeners(), this.renderer = null, this.mouse = null, this.eventData = null, this.interactionDOMElement = null, this.onPointerDown = null, this.processPointerDown = null, this.onPointerUp = null, this.processPointerUp = null, this.onPointerCancel = null, this.processPointerCancel = null, this.onPointerMove = null, this.processPointerMove = null, this.onPointerOut = null, this.processPointerOverOut = null, this.onPointerOver = null, this._tempPoint = null }, InteractionManager }(eventemitter3)); var interaction_es = { InteractionData: InteractionData, InteractionEvent: InteractionEvent, InteractionManager: InteractionManager, InteractionTrackingData: InteractionTrackingData, interactiveTarget: interactiveTarget }; var GRAPHICS_CURVES = { adaptive: !0, maxLength: 10, minSegments: 8, maxSegments: 2048, _segmentsCount: function (length, defaultSegments) { if (void 0 === defaultSegments && (defaultSegments = 20), !this.adaptive) return defaultSegments; var result = Math.ceil(length / this.maxLength); return result < this.minSegments ? result = this.minSegments : result > this.maxSegments && (result = this.maxSegments), result } }; var FillStyle = function () { this.reset() }; FillStyle.prototype.clone = function () { var obj = new FillStyle(); return obj.color = this.color, obj.alpha = this.alpha, obj.texture = this.texture, obj.matrix = this.matrix, obj.visible = this.visible, obj }, FillStyle.prototype.reset = function () { this.color = 16777215, this.alpha = 1, this.texture = Texture.WHITE, this.matrix = null, this.visible = !1 }, FillStyle.prototype.destroy = function () { this.texture = null, this.matrix = null }; var GraphicsData = function (shape, fillStyle, lineStyle, matrix) { void 0 === fillStyle && (fillStyle = null), void 0 === lineStyle && (lineStyle = null), void 0 === matrix && (matrix = null), this.shape = shape, this.lineStyle = lineStyle, this.fillStyle = fillStyle, this.matrix = matrix, this.type = shape.type, this.points = [], this.holes = [] }; GraphicsData.prototype.clone = function () { return new GraphicsData(this.shape, this.fillStyle, this.lineStyle, this.matrix) }, GraphicsData.prototype.destroy = function () { this.shape = null, this.holes.length = 0, this.holes = null, this.points.length = 0, this.points = null, this.lineStyle = null, this.fillStyle = null }; var buildCircle = { build: function (graphicsData) { var width; var height; var circleData = graphicsData.shape; var points = graphicsData.points; var x = circleData.x; var y = circleData.y; if (points.length = 0, height = graphicsData.type === SHAPES.CIRC ? (width = circleData.radius, circleData.radius) : (width = circleData.width, circleData.height), width !== 0 && height !== 0) { var totalSegs = Math.floor(30 * Math.sqrt(circleData.radius)) || Math.floor(15 * Math.sqrt(circleData.width + circleData.height)); totalSegs /= 2.3; for (var seg = 2 * Math.PI / totalSegs, i = 0; i < totalSegs; i++)points.push(x + Math.sin(-seg * i) * width, y + Math.cos(-seg * i) * height); points.push(points[0], points[1]) } }, triangulate: function (graphicsData, graphicsGeometry) { var points = graphicsData.points; var verts = graphicsGeometry.points; var indices = graphicsGeometry.indices; var vertPos = verts.length / 2; var center = vertPos; verts.push(graphicsData.shape.x, graphicsData.shape.y); for (var i = 0; i < points.length; i += 2)verts.push(points[i], points[i + 1]), indices.push(vertPos++, center, vertPos) } }; function buildLine (graphicsData, graphicsGeometry) { graphicsData.lineStyle.native ? (function (graphicsData, graphicsGeometry) { var i = 0; var points = graphicsData.points || graphicsData.shape.points; if (points.length === 0) return; var verts = graphicsGeometry.points; var indices = graphicsGeometry.indices; var length = points.length / 2; var indexStart = verts.length / 2; for (i = 1; i < length; i++) { var p1x = points[2 * (i - 1)]; var p1y = points[2 * (i - 1) + 1]; var p2x = points[2 * i]; var p2y = points[2 * i + 1]; verts.push(p1x, p1y), verts.push(p2x, p2y), indices.push(indexStart++, indexStart++) } }(graphicsData, graphicsGeometry)) : (function (graphicsData, graphicsGeometry) { var shape = graphicsData.shape; var points = graphicsData.points || shape.points.slice(); if (points.length === 0) return; var style = graphicsData.lineStyle; var firstPoint = new Point(points[0], points[1]); var lastPoint = new Point(points[points.length - 2], points[points.length - 1]); var closedShape = shape.type !== SHAPES.POLY || shape.closeStroke; var closedPath = firstPoint.x === lastPoint.x && firstPoint.y === lastPoint.y; if (closedShape) { points = points.slice(), closedPath && (points.pop(), points.pop(), lastPoint.set(points[points.length - 2], points[points.length - 1])); var midPointX = lastPoint.x + 0.5 * (firstPoint.x - lastPoint.x); var midPointY = lastPoint.y + 0.5 * (firstPoint.y - lastPoint.y); points.unshift(midPointX, midPointY), points.push(midPointX, midPointY) } var verts = graphicsGeometry.points; var length = points.length / 2; var indexCount = points.length; var indexStart = verts.length / 2; var width = style.width / 2; var p1x = points[0]; var p1y = points[1]; var p2x = points[2]; var p2y = points[3]; var p3x = 0; var p3y = 0; var perpx = -(p1y - p2y); var perpy = p1x - p2x; var perp2x = 0; var perp2y = 0; var perp3x = 0; var perp3y = 0; var dist = Math.sqrt(perpx * perpx + perpy * perpy); perpx /= dist, perpy /= dist, perpx *= width, perpy *= width; var ratio = style.alignment; var r1 = 2 * (1 - ratio); var r2 = 2 * ratio; verts.push(p1x - perpx * r1, p1y - perpy * r1), verts.push(p1x + perpx * r2, p1y + perpy * r2); for (var i = 1; i < length - 1; ++i) { p1x = points[2 * (i - 1)], p1y = points[2 * (i - 1) + 1], p2x = points[2 * i], p2y = points[2 * i + 1], p3x = points[2 * (i + 1)], p3y = points[2 * (i + 1) + 1], perpx = -(p1y - p2y), perpy = p1x - p2x, dist = Math.sqrt(perpx * perpx + perpy * perpy), perpx /= dist, perpy /= dist, perpx *= width, perpy *= width, perp2x = -(p2y - p3y), perp2y = p2x - p3x, dist = Math.sqrt(perp2x * perp2x + perp2y * perp2y), perp2x /= dist, perp2y /= dist; var a1 = -perpy + p1y - (-perpy + p2y); var b1 = -perpx + p2x - (-perpx + p1x); var c1 = (-perpx + p1x) * (-perpy + p2y) - (-perpx + p2x) * (-perpy + p1y); var a2 = -(perp2y *= width) + p3y - (-perp2y + p2y); var b2 = -(perp2x *= width) + p2x - (-perp2x + p3x); var c2 = (-perp2x + p3x) * (-perp2y + p2y) - (-perp2x + p2x) * (-perp2y + p3y); var denom = a1 * b2 - a2 * b1; if (Math.abs(denom) < 0.1)denom += 10.1, verts.push(p2x - perpx * r1, p2y - perpy * r1), verts.push(p2x + perpx * r2, p2y + perpy * r2); else { var px = (b1 * c2 - b2 * c1) / denom; var py = (a2 * c1 - a1 * c2) / denom; 196 * width * width < (px - p2x) * (px - p2x) + (py - p2y) * (py - p2y) ? (perp3x = perpx - perp2x, perp3y = perpy - perp2y, dist = Math.sqrt(perp3x * perp3x + perp3y * perp3y), perp3x /= dist, perp3y /= dist, perp3x *= width, perp3y *= width, verts.push(p2x - perp3x * r1, p2y - perp3y * r1), verts.push(p2x + perp3x * r2, p2y + perp3y * r2), verts.push(p2x - perp3x * r2 * r1, p2y - perp3y * r1), indexCount++) : (verts.push(p2x + (px - p2x) * r1, p2y + (py - p2y) * r1), verts.push(p2x - (px - p2x) * r2, p2y - (py - p2y) * r2)) } }p1x = points[2 * (length - 2)], p1y = points[2 * (length - 2) + 1], p2x = points[2 * (length - 1)], p2y = points[2 * (length - 1) + 1], perpx = -(p1y - p2y), perpy = p1x - p2x, dist = Math.sqrt(perpx * perpx + perpy * perpy), perpx /= dist, perpy /= dist, perpx *= width, perpy *= width, verts.push(p2x - perpx * r1, p2y - perpy * r1), verts.push(p2x + perpx * r2, p2y + perpy * r2); for (var indices = graphicsGeometry.indices, i$1 = 0; i$1 < indexCount - 2; ++i$1)indices.push(indexStart, indexStart + 1, indexStart + 2), indexStart++ }(graphicsData, graphicsGeometry)) } var buildPoly = { build: function (graphicsData) { graphicsData.points = graphicsData.shape.points.slice() }, triangulate: function (graphicsData, graphicsGeometry) { var points = graphicsData.points; var holes = graphicsData.holes; var verts = graphicsGeometry.points; var indices = graphicsGeometry.indices; if (points.length >= 6) { for (var holeArray = [], i = 0; i < holes.length; i++) { var hole = holes[i]; holeArray.push(points.length / 2), points = points.concat(hole.points) } var triangles = earcut_1(points, holeArray, 2); if (!triangles) return; for (var vertPos = verts.length / 2, i$1 = 0; i$1 < triangles.length; i$1 += 3)indices.push(triangles[i$1] + vertPos), indices.push(triangles[i$1 + 1] + vertPos), indices.push(triangles[i$1 + 2] + vertPos); for (var i$2 = 0; i$2 < points.length; i$2++)verts.push(points[i$2]) } } }; var buildRoundedRectangle = { build: function (graphicsData) { var rrectData = graphicsData.shape; var points = graphicsData.points; var x = rrectData.x; var y = rrectData.y; var width = rrectData.width; var height = rrectData.height; var radius = rrectData.radius; points.length = 0, quadraticBezierCurve(x, y + radius, x, y, x + radius, y, points), quadraticBezierCurve(x + width - radius, y, x + width, y, x + width, y + radius, points), quadraticBezierCurve(x + width, y + height - radius, x + width, y + height, x + width - radius, y + height, points), quadraticBezierCurve(x + radius, y + height, x, y + height, x, y + height - radius, points) }, triangulate: function (graphicsData, graphicsGeometry) { for (var points = graphicsData.points, verts = graphicsGeometry.points, indices = graphicsGeometry.indices, vecPos = verts.length / 2, triangles = earcut_1(points, null, 2), i = 0, j = triangles.length; i < j; i += 3)indices.push(triangles[i] + vecPos), indices.push(triangles[i + 1] + vecPos), indices.push(triangles[i + 2] + vecPos); for (var i$1 = 0, j$1 = points.length; i$1 < j$1; i$1++)verts.push(points[i$1], points[++i$1]) } }; function getPt (n1, n2, perc) { return n1 + (n2 - n1) * perc } function quadraticBezierCurve (fromX, fromY, cpX, cpY, toX, toY, out) { void 0 === out && (out = []); for (var points = out, xa = 0, ya = 0, xb = 0, yb = 0, x = 0, y = 0, i = 0, j = 0; i <= 20; ++i)xa = getPt(fromX, cpX, j = i / 20), ya = getPt(fromY, cpY, j), xb = getPt(cpX, toX, j), yb = getPt(cpY, toY, j), x = getPt(xa, xb, j), y = getPt(ya, yb, j), points.push(x, y); return points } var BATCH_POOL = []; var DRAW_CALL_POOL = []; var fillCommands = {}; fillCommands[SHAPES.POLY] = buildPoly, fillCommands[SHAPES.CIRC] = buildCircle, fillCommands[SHAPES.ELIP] = buildCircle, fillCommands[SHAPES.RECT] = { build: function (graphicsData) { var rectData = graphicsData.shape; var x = rectData.x; var y = rectData.y; var width = rectData.width; var height = rectData.height; var points = graphicsData.points; points.length = 0, points.push(x, y, x + width, y, x + width, y + height, x, y + height) }, triangulate: function (graphicsData, graphicsGeometry) { var points = graphicsData.points; var verts = graphicsGeometry.points; var vertPos = verts.length / 2; verts.push(points[0], points[1], points[2], points[3], points[6], points[7], points[4], points[5]), graphicsGeometry.indices.push(vertPos, 1 + vertPos, 2 + vertPos, 1 + vertPos, 2 + vertPos, 3 + vertPos) } }, fillCommands[SHAPES.RREC] = buildRoundedRectangle; var BatchPart = function () { this.style = null, this.size = 0, this.start = 0, this.attribStart = 0, this.attribSize = 0 }; var GraphicsGeometry = (function (BatchGeometry) { function GraphicsGeometry () { BatchGeometry.call(this), this.points = [], this.colors = [], this.uvs = [], this.indices = [], this.textureIds = [], this.graphicsData = [], this.dirty = 0, this.batchDirty = -1, this.cacheDirty = -1, this.clearDirty = 0, this.drawCalls = [], this.batches = [], this.shapeIndex = 0, this._bounds = new Bounds(), this.boundsDirty = -1, this.boundsPadding = 0, this.batchable = !1, this.indicesUint16 = null, this.uvsFloat32 = null }BatchGeometry && (GraphicsGeometry.__proto__ = BatchGeometry), (GraphicsGeometry.prototype = Object.create(BatchGeometry && BatchGeometry.prototype)).constructor = GraphicsGeometry; var prototypeAccessors = { bounds: { configurable: !0 } }; return prototypeAccessors.bounds.get = function () { return this.boundsDirty !== this.dirty && (this.boundsDirty = this.dirty, this.calculateBounds()), this._bounds }, GraphicsGeometry.prototype.clear = function () { if (this.graphicsData.length > 0) { this.boundsDirty = -1, this.dirty++, this.clearDirty++, this.batchDirty++, this.graphicsData.length = 0, this.shapeIndex = 0, this.points.length = 0, this.colors.length = 0, this.uvs.length = 0, this.indices.length = 0; for (var i = this.textureIds.length = 0; i < this.drawCalls.length; i++) this.drawCalls[i].textures.length = 0, DRAW_CALL_POOL.push(this.drawCalls[i]); for (var i$1 = this.drawCalls.length = 0; i$1 < this.batches.length; i$1++) { var batch = this.batches[i$1]; batch.start = 0, batch.attribStart = 0, batch.style = null, BATCH_POOL.push(batch) } this.batches.length = 0 } return this }, GraphicsGeometry.prototype.drawShape = function (shape, fillStyle, lineStyle, matrix) { var data = new GraphicsData(shape, fillStyle, lineStyle, matrix); return this.graphicsData.push(data), this.dirty++, this }, GraphicsGeometry.prototype.drawHole = function (shape, matrix) { if (!this.graphicsData.length) return null; var data = new GraphicsData(shape, null, null, matrix); var lastShape = this.graphicsData[this.graphicsData.length - 1]; return data.lineStyle = lastShape.lineStyle, lastShape.holes.push(data), this.dirty++, data }, GraphicsGeometry.prototype.destroy = function (options) { BatchGeometry.prototype.destroy.call(this, options); for (var i = 0; i < this.graphicsData.length; ++i) this.graphicsData[i].destroy(); this.points.length = 0, this.points = null, this.colors.length = 0, this.colors = null, this.uvs.length = 0, this.uvs = null, this.indices.length = 0, this.indices = null, this.indexBuffer.destroy(), this.indexBuffer = null, this.graphicsData.length = 0, this.graphicsData = null, this.drawCalls.length = 0, this.drawCalls = null, this.batches.length = 0, this.batches = null, this._bounds = null }, GraphicsGeometry.prototype.containsPoint = function (point) { for (var graphicsData = this.graphicsData, i = 0; i < graphicsData.length; ++i) { var data = graphicsData[i]; if (data.fillStyle.visible && (data.shape && data.shape.contains(point.x, point.y))) { if (data.holes) for (var i$1 = 0; i$1 < data.holes.length; i$1++) { if (data.holes[i$1].shape.contains(point.x, point.y)) return !1 } return !0 } } return !1 }, GraphicsGeometry.prototype.updateBatches = function () { if (this.dirty !== this.cacheDirty && this.graphicsData.length !== 0) { if (this.dirty !== this.cacheDirty) for (var i = 0; i < this.graphicsData.length; i++) { var data = this.graphicsData[i]; if (data.fillStyle && !data.fillStyle.texture.baseTexture.valid) return; if (data.lineStyle && !data.lineStyle.texture.baseTexture.valid) return } this.cacheDirty = this.dirty; var uvs = this.uvs; var batchPart = this.batches.pop() || BATCH_POOL.pop() || new BatchPart(); batchPart.style = batchPart.style || this.graphicsData[0].fillStyle || this.graphicsData[0].lineStyle; var currentTexture = batchPart.style.texture.baseTexture; var currentColor = batchPart.style.color + batchPart.style.alpha; this.batches.push(batchPart); for (var i$1 = this.shapeIndex; i$1 < this.graphicsData.length; i$1++) { this.shapeIndex++; var data$1 = this.graphicsData[i$1]; var command = fillCommands[data$1.type]; var fillStyle = data$1.fillStyle; var lineStyle = data$1.lineStyle; command.build(data$1), data$1.matrix && this.transformPoints(data$1.points, data$1.matrix); for (var j = 0; j < 2; j++) { var style = j === 0 ? fillStyle : lineStyle; if (style.visible) { var nextTexture = style.texture.baseTexture; if (currentTexture !== nextTexture || style.color + style.alpha !== currentColor) { nextTexture.wrapMode = 10497, currentTexture = nextTexture, currentColor = style.color + style.alpha; var index$1 = this.indices.length; var attribIndex = this.points.length / 2; batchPart.size = index$1 - batchPart.start, batchPart.attribSize = attribIndex - batchPart.attribStart, batchPart.size > 0 && (batchPart = BATCH_POOL.pop() || new BatchPart(), this.batches.push(batchPart)), batchPart.style = style, batchPart.start = index$1, batchPart.attribStart = attribIndex } var start = this.points.length / 2; if (j === 0)data$1.holes.length ? (this.processHoles(data$1.holes), buildPoly.triangulate(data$1, this)) : command.triangulate(data$1, this); else { buildLine(data$1, this); for (var i$2 = 0; i$2 < data$1.holes.length; i$2++)buildLine(data$1.holes[i$2], this) } var size = this.points.length / 2 - start; this.addUvs(this.points, uvs, style.texture, start, size, style.matrix) } } } var index = this.indices.length; var attrib = this.points.length / 2; if (batchPart.size = index - batchPart.start, batchPart.attribSize = attrib - batchPart.attribStart, this.indicesUint16 = new Uint16Array(this.indices), this.batchable = this.isBatchable(), this.batchable) { this.batchDirty++, this.uvsFloat32 = new Float32Array(this.uvs); for (var i$3 = 0; i$3 < this.batches.length; i$3++) for (var batch = this.batches[i$3], j$1 = 0; j$1 < batch.size; j$1++) { var index$2 = batch.start + j$1; this.indicesUint16[index$2] = this.indicesUint16[index$2] - batch.attribStart } } else this.buildDrawCalls() } }, GraphicsGeometry.prototype.isBatchable = function () { for (var batches = this.batches, i = 0; i < batches.length; i++) if (batches[i].style.native) return !1; return this.points.length < 2 * GraphicsGeometry.BATCHABLE_SIZE }, GraphicsGeometry.prototype.buildDrawCalls = function () { for (var TICK = ++BaseTexture._globalBatch, i = 0; i < this.drawCalls.length; i++) this.drawCalls[i].textures.length = 0, DRAW_CALL_POOL.push(this.drawCalls[i]); this.drawCalls.length = 0; var uvs = this.uvs; var colors = this.colors; var textureIds = this.textureIds; var currentGroup = DRAW_CALL_POOL.pop() || new BatchDrawCall(); currentGroup.textureCount = 0, currentGroup.start = 0, currentGroup.size = 0, currentGroup.type = DRAW_MODES.TRIANGLES; var textureCount = 0; var currentTexture = null; var textureId = 0; var native = !1; var drawMode = DRAW_MODES.TRIANGLES; var index = 0; this.drawCalls.push(currentGroup); for (var i$1 = 0; i$1 < this.batches.length; i$1++) { var data = this.batches[i$1]; var style = data.style; var nextTexture = style.texture.baseTexture; native !== style.native && (drawMode = (native = style.native) ? DRAW_MODES.LINES : DRAW_MODES.TRIANGLES, currentTexture = null, textureCount = 8, TICK++), currentTexture !== nextTexture && (currentTexture = nextTexture)._batchEnabled !== TICK && (textureCount === 8 && (TICK++, (textureCount = 0) < currentGroup.size && (currentGroup = DRAW_CALL_POOL.pop() || new BatchDrawCall(), this.drawCalls.push(currentGroup)), currentGroup.start = index, currentGroup.size = 0, currentGroup.textureCount = 0, currentGroup.type = drawMode), nextTexture.touched = 1, nextTexture._batchEnabled = TICK, nextTexture._id = textureCount, nextTexture.wrapMode = 10497, currentGroup.textures[currentGroup.textureCount++] = nextTexture, textureCount++), currentGroup.size += data.size, index += data.size, textureId = nextTexture._id, this.addColors(colors, style.color, style.alpha, data.attribSize), this.addTextureIds(textureIds, textureId, data.attribSize) }BaseTexture._globalBatch = TICK; for (var verts = this.points, glPoints = new ArrayBuffer(3 * verts.length * 4), f32 = new Float32Array(glPoints), u32 = new Uint32Array(glPoints), p = 0, i$2 = 0; i$2 < verts.length / 2; i$2++)f32[p++] = verts[2 * i$2], f32[p++] = verts[2 * i$2 + 1], f32[p++] = uvs[2 * i$2], f32[p++] = uvs[2 * i$2 + 1], u32[p++] = colors[i$2], f32[p++] = textureIds[i$2]; this._buffer.update(glPoints), this._indexBuffer.update(this.indicesUint16) }, GraphicsGeometry.prototype.processHoles = function (holes) { for (var i = 0; i < holes.length; i++) { var hole = holes[i]; fillCommands[hole.type].build(hole), hole.matrix && this.transformPoints(hole.points, hole.matrix) } }, GraphicsGeometry.prototype.calculateBounds = function () { var minX = 1 / 0; var maxX = -1 / 0; var minY = 1 / 0; var maxY = -1 / 0; if (this.graphicsData.length) for (var shape = null, x = 0, y = 0, w = 0, h = 0, i = 0; i < this.graphicsData.length; i++) { var data = this.graphicsData[i]; var type = data.type; var lineWidth = data.lineStyle ? data.lineStyle.width : 0; if (shape = data.shape, type === SHAPES.RECT || type === SHAPES.RREC)x = shape.x - lineWidth / 2, y = shape.y - lineWidth / 2, minX = x < minX ? x : minX, maxX = maxX < x + (w = shape.width + lineWidth) ? x + w : maxX, minY = y < minY ? y : minY, maxY = maxY < y + (h = shape.height + lineWidth) ? y + h : maxY; else if (type === SHAPES.CIRC)x = shape.x, y = shape.y, minX = x - (w = shape.radius + lineWidth / 2) < minX ? x - w : minX, maxX = maxX < x + w ? x + w : maxX, minY = y - (h = shape.radius + lineWidth / 2) < minY ? y - h : minY, maxY = maxY < y + h ? y + h : maxY; else if (type === SHAPES.ELIP)x = shape.x, y = shape.y, minX = x - (w = shape.width + lineWidth / 2) < minX ? x - w : minX, maxX = maxX < x + w ? x + w : maxX, minY = y - (h = shape.height + lineWidth / 2) < minY ? y - h : minY, maxY = maxY < y + h ? y + h : maxY; else for (var points = shape.points, x2 = 0, y2 = 0, dx = 0, dy = 0, rw = 0, rh = 0, cx = 0, cy = 0, j = 0; j + 2 < points.length; j += 2)x = points[j], y = points[j + 1], x2 = points[j + 2], y2 = points[j + 3], dx = Math.abs(x2 - x), dy = Math.abs(y2 - y), h = lineWidth, (w = Math.sqrt(dx * dx + dy * dy)) < 1e-9 || (minX = (cx = (x2 + x) / 2) - (rw = (h / w * dy + dx) / 2) < minX ? cx - rw : minX, maxX = maxX < cx + rw ? cx + rw : maxX, minY = (cy = (y2 + y) / 2) - (rh = (h / w * dx + dy) / 2) < minY ? cy - rh : minY, maxY = maxY < cy + rh ? cy + rh : maxY) } else maxY = minY = maxX = minX = 0; var padding = this.boundsPadding; this._bounds.minX = minX - padding, this._bounds.maxX = maxX + padding, this._bounds.minY = minY - padding, this._bounds.maxY = maxY + padding }, GraphicsGeometry.prototype.transformPoints = function (points, matrix) { for (var i = 0; i < points.length / 2; i++) { var x = points[2 * i]; var y = points[2 * i + 1]; points[2 * i] = matrix.a * x + matrix.c * y + matrix.tx, points[2 * i + 1] = matrix.b * x + matrix.d * y + matrix.ty } }, GraphicsGeometry.prototype.addColors = function (colors, color, alpha, size) { for (var rgba = premultiplyTint((color >> 16) + (65280 & color) + ((255 & color) << 16), alpha); size-- > 0;)colors.push(rgba) }, GraphicsGeometry.prototype.addTextureIds = function (textureIds, id, size) { for (;size-- > 0;)textureIds.push(id) }, GraphicsGeometry.prototype.addUvs = function (verts, uvs, texture, start, size, matrix) { for (var index = 0, uvsStart = uvs.length, frame = texture.frame; index < size;) { var x = verts[2 * (start + index)]; var y = verts[2 * (start + index) + 1]; if (matrix) { var nx = matrix.a * x + matrix.c * y + matrix.tx; y = matrix.b * x + matrix.d * y + matrix.ty, x = nx }index++, uvs.push(x / frame.width, y / frame.height) } var baseTexture = texture.baseTexture; (frame.width < baseTexture.width || frame.height < baseTexture.height) && this.adjustUvs(uvs, texture, uvsStart, size) }, GraphicsGeometry.prototype.adjustUvs = function (uvs, texture, start, size) { for (var baseTexture = texture.baseTexture, finish = start + 2 * size, frame = texture.frame, scaleX = frame.width / baseTexture.width, scaleY = frame.height / baseTexture.height, offsetX = frame.x / frame.width, offsetY = frame.y / frame.height, minX = Math.floor(uvs[start] + 1e-6), minY = Math.floor(uvs[start + 1] + 1e-6), i = start + 2; i < finish; i += 2)minX = Math.min(minX, Math.floor(uvs[i] + 1e-6)), minY = Math.min(minY, Math.floor(uvs[i + 1] + 1e-6)); offsetX -= minX, offsetY -= minY; for (var i$1 = start; i$1 < finish; i$1 += 2)uvs[i$1] = (uvs[i$1] + offsetX) * scaleX, uvs[i$1 + 1] = (uvs[i$1 + 1] + offsetY) * scaleY }, Object.defineProperties(GraphicsGeometry.prototype, prototypeAccessors), GraphicsGeometry }(BatchGeometry)); GraphicsGeometry.BATCHABLE_SIZE = 100; var LineStyle = (function (FillStyle) { function LineStyle () { FillStyle.apply(this, arguments) } return FillStyle && (LineStyle.__proto__ = FillStyle), ((LineStyle.prototype = Object.create(FillStyle && FillStyle.prototype)).constructor = LineStyle).prototype.clone = function () { var obj = new LineStyle(); return obj.color = this.color, obj.alpha = this.alpha, obj.texture = this.texture, obj.matrix = this.matrix, obj.visible = this.visible, obj.width = this.width, obj.alignment = this.alignment, obj.native = this.native, obj }, LineStyle.prototype.reset = function () { FillStyle.prototype.reset.call(this), this.color = 0, this.width = 0, this.alignment = 0.5, this.native = !1 }, LineStyle }(FillStyle)); var BezierUtils = function () {}; BezierUtils.curveLength = function (fromX, fromY, cpX, cpY, cpX2, cpY2, toX, toY) { for (var result = 0, t = 0, t2 = 0, t3 = 0, nt = 0, nt2 = 0, nt3 = 0, x = 0, y = 0, dx = 0, dy = 0, prevX = fromX, prevY = fromY, i = 1; i <= 10; ++i)dx = prevX - (x = (nt3 = (nt2 = (nt = 1 - (t = i / 10)) * nt) * nt) * fromX + 3 * nt2 * t * cpX + 3 * nt * (t2 = t * t) * cpX2 + (t3 = t2 * t) * toX), dy = prevY - (y = nt3 * fromY + 3 * nt2 * t * cpY + 3 * nt * t2 * cpY2 + t3 * toY), prevX = x, prevY = y, result += Math.sqrt(dx * dx + dy * dy); return result }, BezierUtils.curveTo = function (cpX, cpY, cpX2, cpY2, toX, toY, points) { var fromX = points[points.length - 2]; var fromY = points[points.length - 1]; points.length -= 2; var n = GRAPHICS_CURVES._segmentsCount(BezierUtils.curveLength(fromX, fromY, cpX, cpY, cpX2, cpY2, toX, toY)); var dt = 0; var dt2 = 0; var dt3 = 0; var t2 = 0; var t3 = 0; points.push(fromX, fromY); for (var i = 1, j = 0; i <= n; ++i)dt3 = (dt2 = (dt = 1 - (j = i / n)) * dt) * dt, t3 = (t2 = j * j) * j, points.push(dt3 * fromX + 3 * dt2 * j * cpX + 3 * dt * t2 * cpX2 + t3 * toX, dt3 * fromY + 3 * dt2 * j * cpY + 3 * dt * t2 * cpY2 + t3 * toY) }; var QuadraticUtils = function () {}; QuadraticUtils.curveLength = function (fromX, fromY, cpX, cpY, toX, toY) { var ax = fromX - 2 * cpX + toX; var ay = fromY - 2 * cpY + toY; var bx = 2 * cpX - 2 * fromX; var by = 2 * cpY - 2 * fromY; var a = 4 * (ax * ax + ay * ay); var b = 4 * (ax * bx + ay * by); var c = bx * bx + by * by; var s = 2 * Math.sqrt(a + b + c); var a2 = Math.sqrt(a); var a32 = 2 * a * a2; var c2 = 2 * Math.sqrt(c); var ba = b / a2; return (a32 * s + a2 * b * (s - c2) + (4 * c * a - b * b) * Math.log((2 * a2 + ba + s) / (ba + c2))) / (4 * a32) }, QuadraticUtils.curveTo = function (cpX, cpY, toX, toY, points) { for (var fromX = points[points.length - 2], fromY = points[points.length - 1], n = GRAPHICS_CURVES._segmentsCount(QuadraticUtils.curveLength(fromX, fromY, cpX, cpY, toX, toY)), xa = 0, ya = 0, i = 1; i <= n; ++i) { var j = i / n; xa = fromX + (cpX - fromX) * j, ya = fromY + (cpY - fromY) * j, points.push(xa + (cpX + (toX - cpX) * j - xa) * j, ya + (cpY + (toY - cpY) * j - ya) * j) } }; var ArcUtils = function () {}; ArcUtils.curveTo = function (x1, y1, x2, y2, radius, points) { var fromX = points[points.length - 2]; var a1 = points[points.length - 1] - y1; var b1 = fromX - x1; var a2 = y2 - y1; var b2 = x2 - x1; var mm = Math.abs(a1 * b2 - b1 * a2); if (mm < 1e-8 || radius === 0) return points[points.length - 2] === x1 && points[points.length - 1] === y1 || points.push(x1, y1), null; var dd = a1 * a1 + b1 * b1; var cc = a2 * a2 + b2 * b2; var tt = a1 * a2 + b1 * b2; var k1 = radius * Math.sqrt(dd) / mm; var k2 = radius * Math.sqrt(cc) / mm; var j1 = k1 * tt / dd; var j2 = k2 * tt / cc; var cx = k1 * b2 + k2 * b1; var cy = k1 * a2 + k2 * a1; var px = b1 * (k2 + j1); var py = a1 * (k2 + j1); var qx = b2 * (k1 + j2); var qy = a2 * (k1 + j2); return { cx: cx + x1, cy: cy + y1, radius: radius, startAngle: Math.atan2(py - cy, px - cx), endAngle: Math.atan2(qy - cy, qx - cx), anticlockwise: b2 * a1 < b1 * a2 } }, ArcUtils.arc = function (startX, startY, cx, cy, radius, startAngle, endAngle, anticlockwise, points) { for (var sweep = endAngle - startAngle, n = GRAPHICS_CURVES._segmentsCount(Math.abs(sweep) * radius, 40 * Math.ceil(Math.abs(sweep) / PI_2)), theta = sweep / (2 * n), theta2 = 2 * theta, cTheta = Math.cos(theta), sTheta = Math.sin(theta), segMinus = n - 1, remainder = segMinus % 1 / segMinus, i = 0; i <= segMinus; ++i) { var angle = theta + startAngle + theta2 * (i + remainder * i); var c = Math.cos(angle); var s = -Math.sin(angle); points.push((cTheta * c + sTheta * s) * radius + cx, (cTheta * -s + sTheta * c) * radius + cy) } }; var Star = (function (Polygon) { function Star (x, y, points, radius, innerRadius, rotation) { innerRadius = innerRadius || radius / 2; for (var startAngle = -1 * Math.PI / 2 + rotation, len = 2 * points, delta = PI_2 / len, polygon = [], i = 0; i < len; i++) { var r = i % 2 ? innerRadius : radius; var angle = i * delta + startAngle; polygon.push(x + r * Math.cos(angle), y + r * Math.sin(angle)) }Polygon.call(this, polygon) } return Polygon && (Star.__proto__ = Polygon), (Star.prototype = Object.create(Polygon && Polygon.prototype)).constructor = Star }(Polygon)); var temp = new Float32Array(3); var defaultShader = null; var Graphics = (function (Container) { function Graphics (geometry) { void 0 === geometry && (geometry = null), Container.call(this), this.geometry = geometry || new GraphicsGeometry(), this.geometry.refCount++, this.shader = null, this.state = State.for2d(), this._fillStyle = new FillStyle(), this._lineStyle = new LineStyle(), this._matrix = null, this._holeMode = !1, this.currentPath = null, this.batches = [], this.batchTint = -1, this.vertexData = null, this._transformID = -1, this.batchDirty = -1, this.tint = 16777215, this.blendMode = BLEND_MODES.NORMAL }Container && (Graphics.__proto__ = Container); var prototypeAccessors = { blendMode: { configurable: !0 }, tint: { configurable: !0 }, fill: { configurable: !0 }, line: { configurable: !0 } }; return ((Graphics.prototype = Object.create(Container && Container.prototype)).constructor = Graphics).prototype.clone = function () { return this.finishPoly(), new Graphics(this.geometry) }, prototypeAccessors.blendMode.set = function (value) { this.state.blendMode = value }, prototypeAccessors.blendMode.get = function () { return this.state.blendMode }, prototypeAccessors.tint.get = function () { return this._tint }, prototypeAccessors.tint.set = function (value) { this._tint = value }, prototypeAccessors.fill.get = function () { return this._fillStyle }, prototypeAccessors.line.get = function () { return this._lineStyle }, Graphics.prototype.lineStyle = function (width, color, alpha, alignment, native) { return void 0 === width && (width = 0), void 0 === color && (color = 0), void 0 === alpha && (alpha = 1), void 0 === alignment && (alignment = 0.5), void 0 === native && (native = !1), this.lineTextureStyle(width, Texture.WHITE, color, alpha, null, alignment, native), this }, Graphics.prototype.lineTextureStyle = function (width, texture, color, alpha, matrix, alignment, native) { void 0 === width && (width = 0), void 0 === texture && (texture = Texture.WHITE), void 0 === color && (color = 16777215), void 0 === alpha && (alpha = 1), void 0 === matrix && (matrix = null), void 0 === alignment && (alignment = 0.5), void 0 === native && (native = !1), this.currentPath && this.startPoly(); var visible = width > 0 && alpha > 0; return visible ? (matrix && (matrix = matrix.clone()).invert(), Object.assign(this._lineStyle, { color: color, width: width, alpha: alpha, matrix: matrix, texture: texture, alignment: alignment, native: native, visible: visible })) : this._lineStyle.reset(), this }, Graphics.prototype.startPoly = function () { if (this.currentPath) { var points = this.currentPath.points; var len = this.currentPath.points.length; len > 2 && (this.drawShape(this.currentPath), this.currentPath = new Polygon(), this.currentPath.closeStroke = !1, this.currentPath.points.push(points[len - 2], points[len - 1])) } else this.currentPath = new Polygon(), this.currentPath.closeStroke = !1 }, Graphics.prototype.finishPoly = function () { this.currentPath && (this.currentPath.points.length > 2 ? (this.drawShape(this.currentPath), this.currentPath = null) : this.currentPath.points.length = 0) }, Graphics.prototype.moveTo = function (x, y) { return this.startPoly(), this.currentPath.points[0] = x, this.currentPath.points[1] = y, this }, Graphics.prototype.lineTo = function (x, y) { this.currentPath || this.moveTo(0, 0); var points = this.currentPath.points; var fromX = points[points.length - 2]; var fromY = points[points.length - 1]; return fromX === x && fromY === y || points.push(x, y), this }, Graphics.prototype._initCurve = function (x, y) { void 0 === x && (x = 0), void 0 === y && (y = 0), this.currentPath ? this.currentPath.points.length === 0 && (this.currentPath.points = [x, y]) : this.moveTo(x, y) }, Graphics.prototype.quadraticCurveTo = function (cpX, cpY, toX, toY) { this._initCurve(); var points = this.currentPath.points; return points.length === 0 && this.moveTo(0, 0), QuadraticUtils.curveTo(cpX, cpY, toX, toY, points), this }, Graphics.prototype.bezierCurveTo = function (cpX, cpY, cpX2, cpY2, toX, toY) { return this._initCurve(), BezierUtils.curveTo(cpX, cpY, cpX2, cpY2, toX, toY, this.currentPath.points), this }, Graphics.prototype.arcTo = function (x1, y1, x2, y2, radius) { this._initCurve(x1, y1); var points = this.currentPath.points; var result = ArcUtils.curveTo(x1, y1, x2, y2, radius, points); if (result) { var cx = result.cx; var cy = result.cy; var radius$1 = result.radius; var startAngle = result.startAngle; var endAngle = result.endAngle; var anticlockwise = result.anticlockwise; this.arc(cx, cy, radius$1, startAngle, endAngle, anticlockwise) } return this }, Graphics.prototype.arc = function (cx, cy, radius, startAngle, endAngle, anticlockwise) { if (void 0 === anticlockwise && (anticlockwise = !1), startAngle === endAngle) return this; if (!anticlockwise && endAngle <= startAngle ? endAngle += PI_2 : anticlockwise && startAngle <= endAngle && (startAngle += PI_2), endAngle - startAngle == 0) return this; var startX = cx + Math.cos(startAngle) * radius; var startY = cy + Math.sin(startAngle) * radius; var points = this.currentPath ? this.currentPath.points : null; if (points) { var xDiff = Math.abs(points[points.length - 2] - startX); var yDiff = Math.abs(points[points.length - 1] - startY); xDiff < 0.001 && yDiff < 0.001 || points.push(startX, startY) } else this.moveTo(startX, startY), points = this.currentPath.points; return ArcUtils.arc(startX, startY, cx, cy, radius, startAngle, endAngle, anticlockwise, points), this }, Graphics.prototype.beginFill = function (color, alpha) { return void 0 === color && (color = 0), void 0 === alpha && (alpha = 1), this.beginTextureFill(Texture.WHITE, color, alpha) }, Graphics.prototype.beginTextureFill = function (texture, color, alpha, matrix) { void 0 === texture && (texture = Texture.WHITE), void 0 === color && (color = 16777215), void 0 === alpha && (alpha = 1), void 0 === matrix && (matrix = null), this.currentPath && this.startPoly(); var visible = alpha > 0; return visible ? (matrix && (matrix = matrix.clone()).invert(), Object.assign(this._fillStyle, { color: color, alpha: alpha, texture: texture, matrix: matrix, visible: visible })) : this._fillStyle.reset(), this }, Graphics.prototype.endFill = function () { return this.finishPoly(), this._fillStyle.reset(), this }, Graphics.prototype.drawRect = function (x, y, width, height) { return this.drawShape(new Rectangle(x, y, width, height)) }, Graphics.prototype.drawRoundedRect = function (x, y, width, height, radius) { return this.drawShape(new RoundedRectangle(x, y, width, height, radius)) }, Graphics.prototype.drawCircle = function (x, y, radius) { return this.drawShape(new Circle(x, y, radius)) }, Graphics.prototype.drawEllipse = function (x, y, width, height) { return this.drawShape(new Ellipse(x, y, width, height)) }, Graphics.prototype.drawPolygon = function (path) { var arguments$1 = arguments; var points = path; var closeStroke = !0; if (points.points && (closeStroke = points.closeStroke, points = points.points), !Array.isArray(points)) { points = new Array(arguments.length); for (var i = 0; i < points.length; ++i)points[i] = arguments$1[i] } var shape = new Polygon(points); return shape.closeStroke = closeStroke, this.drawShape(shape), this }, Graphics.prototype.drawShape = function (shape) { return this._holeMode ? this.geometry.drawHole(shape, this._matrix) : this.geometry.drawShape(shape, this._fillStyle.clone(), this._lineStyle.clone(), this._matrix), this }, Graphics.prototype.drawStar = function (x, y, points, radius, innerRadius, rotation) { return void 0 === rotation && (rotation = 0), this.drawPolygon(new Star(x, y, points, radius, innerRadius, rotation)) }, Graphics.prototype.clear = function () { return this.geometry.clear(), this._matrix = null, this._holeMode = !1, this.currentPath = null, this._spriteRect = null, this }, Graphics.prototype.isFastRect = function () { return !1 }, Graphics.prototype._render = function (renderer) { this.finishPoly(); var geometry = this.geometry; if (geometry.updateBatches(), geometry.batchable) { if (this.batchDirty !== geometry.batchDirty) { this.batches = [], this.batchTint = -1, this._transformID = -1, this.batchDirty = geometry.batchDirty, this.vertexData = new Float32Array(geometry.points); for (var blendMode = this.blendMode, i = 0; i < geometry.batches.length; i++) { var gI = geometry.batches[i]; var color = gI.style.color; var vertexData = new Float32Array(this.vertexData.buffer, 4 * gI.attribStart * 2, 2 * gI.attribSize); var uvs = new Float32Array(geometry.uvsFloat32.buffer, 4 * gI.attribStart * 2, 2 * gI.attribSize); var batch = { vertexData: vertexData, blendMode: blendMode, indices: new Uint16Array(geometry.indicesUint16.buffer, 2 * gI.start, gI.size), uvs: uvs, _batchRGB: hex2rgb(color), _tintRGB: color, _texture: gI.style.texture, alpha: gI.style.alpha, worldAlpha: 1 }; this.batches[i] = batch } } if (renderer.batch.setObjectRenderer(renderer.plugins.batch), this.batches.length) { this.calculateVertices(), this.calculateTints(); for (var i$1 = 0; i$1 < this.batches.length; i$1++) { var batch$1 = this.batches[i$1]; batch$1.worldAlpha = this.worldAlpha * batch$1.alpha, renderer.plugins.batch.render(batch$1) } } } else { if (renderer.batch.flush(), !this.shader) { if (!defaultShader) { for (var sampleValues = new Int32Array(16), i$2 = 0; i$2 < 16; i$2++)sampleValues[i$2] = i$2; var uniforms = { tint: new Float32Array([1, 1, 1, 1]), translationMatrix: new Matrix(), default: UniformGroup.from({ uSamplers: sampleValues }, !0) }; var program = renderer.plugins.batch.shader.program; defaultShader = new Shader(program, uniforms) } this.shader = defaultShader } var uniforms$1 = this.shader.uniforms; uniforms$1.translationMatrix = this.transform.worldTransform; var tint = this.tint; var wa = this.worldAlpha; uniforms$1.tint[0] = (tint >> 16 & 255) / 255 * wa, uniforms$1.tint[1] = (tint >> 8 & 255) / 255 * wa, uniforms$1.tint[2] = (255 & tint) / 255 * wa, uniforms$1.tint[3] = wa, renderer.shader.bind(this.shader), renderer.geometry.bind(geometry, this.shader), renderer.state.setState(this.state); for (var i$3 = 0; i$3 < geometry.drawCalls.length; i$3++) { for (var drawCall = geometry.drawCalls[i$3], groupTextureCount = drawCall.textureCount, j = 0; j < groupTextureCount; j++)renderer.texture.bind(drawCall.textures[j], j); renderer.geometry.draw(drawCall.type, drawCall.size, drawCall.start) } } }, Graphics.prototype._calculateBounds = function () { this.finishPoly(); var lb = this.geometry.bounds; this._bounds.addFrame(this.transform, lb.minX, lb.minY, lb.maxX, lb.maxY) }, Graphics.prototype.containsPoint = function (point) { return this.worldTransform.applyInverse(point, Graphics._TEMP_POINT), this.geometry.containsPoint(Graphics._TEMP_POINT) }, Graphics.prototype.calculateTints = function () { if (this.batchTint !== this.tint) { this.batchTint = this.tint; for (var tintRGB = hex2rgb(this.tint, temp), i = 0; i < this.batches.length; i++) { var batch = this.batches[i]; var batchTint = batch._batchRGB; var color = (tintRGB[0] * batchTint[0] * 255 << 16) + (tintRGB[1] * batchTint[1] * 255 << 8) + (0 | tintRGB[2] * batchTint[2] * 255); batch._tintRGB = (color >> 16) + (65280 & color) + ((255 & color) << 16) } } }, Graphics.prototype.calculateVertices = function () { if (this._transformID !== this.transform._worldID) { this._transformID = this.transform._worldID; for (var wt = this.transform.worldTransform, a = wt.a, b = wt.b, c = wt.c, d = wt.d, tx = wt.tx, ty = wt.ty, data = this.geometry.points, vertexData = this.vertexData, count = 0, i = 0; i < data.length; i += 2) { var x = data[i]; var y = data[i + 1]; vertexData[count++] = a * x + c * y + tx, vertexData[count++] = d * y + b * x + ty } } }, Graphics.prototype.closePath = function () { var currentPath = this.currentPath; return currentPath && (currentPath.closeStroke = !0), this }, Graphics.prototype.setMatrix = function (matrix) { return this._matrix = matrix, this }, Graphics.prototype.beginHole = function () { return this.finishPoly(), this._holeMode = !0, this }, Graphics.prototype.endHole = function () { return this.finishPoly(), this._holeMode = !1, this }, Graphics.prototype.destroy = function (options) { Container.prototype.destroy.call(this, options), this.geometry.refCount--, this.geometry.refCount === 0 && this.geometry.dispose(), this._matrix = null, this.currentPath = null, this._lineStyle.destroy(), this._lineStyle = null, this._fillStyle.destroy(), this._fillStyle = null, this.geometry = null, this.shader = null, this.vertexData = null, this.batches.length = 0, this.batches = null, Container.prototype.destroy.call(this, options) }, Object.defineProperties(Graphics.prototype, prototypeAccessors), Graphics }(Container)); Graphics._TEMP_POINT = new Point(); var tempPoint = new Point(); var indices = new Uint16Array([0, 1, 2, 0, 2, 3]); var Sprite = (function (Container) { function Sprite (texture) { Container.call(this), this._anchor = new ObservablePoint(this._onAnchorUpdate, this, texture ? texture.defaultAnchor.x : 0, texture ? texture.defaultAnchor.y : 0), this._texture = null, this._width = 0, this._height = 0, this._tint = null, this._tintRGB = null, this.tint = 16777215, this.blendMode = BLEND_MODES.NORMAL, this.shader = null, this._cachedTint = 16777215, this.uvs = null, this.texture = texture || Texture.EMPTY, this.vertexData = new Float32Array(8), this.vertexTrimmedData = null, this._transformID = -1, this._textureID = -1, this._transformTrimmedID = -1, this._textureTrimmedID = -1, this.indices = indices, this.size = 4, this.start = 0, this.pluginName = 'batch', this.isSprite = !0, this._roundPixels = settings.ROUND_PIXELS }Container && (Sprite.__proto__ = Container); var prototypeAccessors = { roundPixels: { configurable: !0 }, width: { configurable: !0 }, height: { configurable: !0 }, anchor: { configurable: !0 }, tint: { configurable: !0 }, texture: { configurable: !0 } }; return ((Sprite.prototype = Object.create(Container && Container.prototype)).constructor = Sprite).prototype._onTextureUpdate = function () { this._textureID = -1, this._textureTrimmedID = -1, this._cachedTint = 16777215, this.uvs = this._texture._uvs.uvsFloat32, this._width && (this.scale.x = sign(this.scale.x) * this._width / this._texture.orig.width), this._height && (this.scale.y = sign(this.scale.y) * this._height / this._texture.orig.height) }, Sprite.prototype._onAnchorUpdate = function () { this._transformID = -1, this._transformTrimmedID = -1 }, Sprite.prototype.calculateVertices = function () { var texture = this._texture; if (this._transformID !== this.transform._worldID || this._textureID !== texture._updateID) { this._transformID = this.transform._worldID, this._textureID = texture._updateID; var wt = this.transform.worldTransform; var a = wt.a; var b = wt.b; var c = wt.c; var d = wt.d; var tx = wt.tx; var ty = wt.ty; var vertexData = this.vertexData; var trim = texture.trim; var orig = texture.orig; var anchor = this._anchor; var w0 = 0; var w1 = 0; var h0 = 0; var h1 = 0; if (h0 = trim ? (w0 = (w1 = trim.x - anchor._x * orig.width) + trim.width, (h1 = trim.y - anchor._y * orig.height) + trim.height) : (w0 = (w1 = -anchor._x * orig.width) + orig.width, (h1 = -anchor._y * orig.height) + orig.height), vertexData[0] = a * w1 + c * h1 + tx, vertexData[1] = d * h1 + b * w1 + ty, vertexData[2] = a * w0 + c * h1 + tx, vertexData[3] = d * h1 + b * w0 + ty, vertexData[4] = a * w0 + c * h0 + tx, vertexData[5] = d * h0 + b * w0 + ty, vertexData[6] = a * w1 + c * h0 + tx, vertexData[7] = d * h0 + b * w1 + ty, this._roundPixels) for (var i = 0; i < 8; i++)vertexData[i] = Math.round(vertexData[i]) } }, Sprite.prototype.calculateTrimmedVertices = function () { if (this.vertexTrimmedData) { if (this._transformTrimmedID === this.transform._worldID && this._textureTrimmedID === this._texture._updateID) return } else this.vertexTrimmedData = new Float32Array(8); this._transformTrimmedID = this.transform._worldID, this._textureTrimmedID = this._texture._updateID; var texture = this._texture; var vertexData = this.vertexTrimmedData; var orig = texture.orig; var anchor = this._anchor; var wt = this.transform.worldTransform; var a = wt.a; var b = wt.b; var c = wt.c; var d = wt.d; var tx = wt.tx; var ty = wt.ty; var w1 = -anchor._x * orig.width; var w0 = w1 + orig.width; var h1 = -anchor._y * orig.height; var h0 = h1 + orig.height; vertexData[0] = a * w1 + c * h1 + tx, vertexData[1] = d * h1 + b * w1 + ty, vertexData[2] = a * w0 + c * h1 + tx, vertexData[3] = d * h1 + b * w0 + ty, vertexData[4] = a * w0 + c * h0 + tx, vertexData[5] = d * h0 + b * w0 + ty, vertexData[6] = a * w1 + c * h0 + tx, vertexData[7] = d * h0 + b * w1 + ty }, Sprite.prototype._render = function (renderer) { this.calculateVertices(), renderer.batch.setObjectRenderer(renderer.plugins[this.pluginName]), renderer.plugins[this.pluginName].render(this) }, Sprite.prototype._calculateBounds = function () { var trim = this._texture.trim; var orig = this._texture.orig; !trim || trim.width === orig.width && trim.height === orig.height ? (this.calculateVertices(), this._bounds.addQuad(this.vertexData)) : (this.calculateTrimmedVertices(), this._bounds.addQuad(this.vertexTrimmedData)) }, Sprite.prototype.getLocalBounds = function (rect) { return this.children.length === 0 ? (this._bounds.minX = this._texture.orig.width * -this._anchor._x, this._bounds.minY = this._texture.orig.height * -this._anchor._y, this._bounds.maxX = this._texture.orig.width * (1 - this._anchor._x), this._bounds.maxY = this._texture.orig.height * (1 - this._anchor._y), rect || (this._localBoundsRect || (this._localBoundsRect = new Rectangle()), rect = this._localBoundsRect), this._bounds.getRectangle(rect)) : Container.prototype.getLocalBounds.call(this, rect) }, Sprite.prototype.containsPoint = function (point) { this.worldTransform.applyInverse(point, tempPoint); var width = this._texture.orig.width; var height = this._texture.orig.height; var x1 = -width * this.anchor.x; var y1 = 0; return tempPoint.x >= x1 && tempPoint.x < x1 + width && (y1 = -height * this.anchor.y, tempPoint.y >= y1 && tempPoint.y < y1 + height) }, Sprite.prototype.destroy = function (options) { if (Container.prototype.destroy.call(this, options), this._texture.off('update', this._onTextureUpdate, this), this._anchor = null, typeof options === 'boolean' ? options : options && options.texture) { var destroyBaseTexture = typeof options === 'boolean' ? options : options && options.baseTexture; this._texture.destroy(!!destroyBaseTexture) } this._texture = null, this.shader = null }, Sprite.from = function (source, options) { return new Sprite(source instanceof Texture ? source : Texture.from(source, options)) }, prototypeAccessors.roundPixels.set = function (value) { this._roundPixels !== value && (this._transformID = -1), this._roundPixels = value }, prototypeAccessors.roundPixels.get = function () { return this._roundPixels }, prototypeAccessors.width.get = function () { return Math.abs(this.scale.x) * this._texture.orig.width }, prototypeAccessors.width.set = function (value) { var s = sign(this.scale.x) || 1; this.scale.x = s * value / this._texture.orig.width, this._width = value }, prototypeAccessors.height.get = function () { return Math.abs(this.scale.y) * this._texture.orig.height }, prototypeAccessors.height.set = function (value) { var s = sign(this.scale.y) || 1; this.scale.y = s * value / this._texture.orig.height, this._height = value }, prototypeAccessors.anchor.get = function () { return this._anchor }, prototypeAccessors.anchor.set = function (value) { this._anchor.copyFrom(value) }, prototypeAccessors.tint.get = function () { return this._tint }, prototypeAccessors.tint.set = function (value) { this._tint = value, this._tintRGB = (value >> 16) + (65280 & value) + ((255 & value) << 16) }, prototypeAccessors.texture.get = function () { return this._texture }, prototypeAccessors.texture.set = function (value) { this._texture !== value && (this._texture = value || Texture.EMPTY, this._cachedTint = 16777215, this._textureID = -1, this._textureTrimmedID = -1, value && (value.baseTexture.valid ? this._onTextureUpdate() : value.once('update', this._onTextureUpdate, this))) }, Object.defineProperties(Sprite.prototype, prototypeAccessors), Sprite }(Container)); var TEXT_GRADIENT = { LINEAR_VERTICAL: 0, LINEAR_HORIZONTAL: 1 }; var defaultStyle = { align: 'left', breakWords: !1, dropShadow: !1, dropShadowAlpha: 1, dropShadowAngle: Math.PI / 6, dropShadowBlur: 0, dropShadowColor: 'black', dropShadowDistance: 5, fill: 'black', fillGradientType: TEXT_GRADIENT.LINEAR_VERTICAL, fillGradientStops: [], fontFamily: 'Arial', fontSize: 26, fontStyle: 'normal', fontVariant: 'normal', fontWeight: 'normal', letterSpacing: 0, lineHeight: 0, lineJoin: 'miter', miterLimit: 10, padding: 0, stroke: 'black', strokeThickness: 0, textBaseline: 'alphabetic', trim: !1, whiteSpace: 'pre', wordWrap: !1, wordWrapWidth: 100, leading: 0 }; var genericFontFamilies = ['serif', 'sans-serif', 'monospace', 'cursive', 'fantasy', 'system-ui']; var TextStyle = function (style) { this.styleID = 0, this.reset(), deepCopyProperties(this, style, style) }; var prototypeAccessors$7 = { align: { configurable: !0 }, breakWords: { configurable: !0 }, dropShadow: { configurable: !0 }, dropShadowAlpha: { configurable: !0 }, dropShadowAngle: { configurable: !0 }, dropShadowBlur: { configurable: !0 }, dropShadowColor: { configurable: !0 }, dropShadowDistance: { configurable: !0 }, fill: { configurable: !0 }, fillGradientType: { configurable: !0 }, fillGradientStops: { configurable: !0 }, fontFamily: { configurable: !0 }, fontSize: { configurable: !0 }, fontStyle: { configurable: !0 }, fontVariant: { configurable: !0 }, fontWeight: { configurable: !0 }, letterSpacing: { configurable: !0 }, lineHeight: { configurable: !0 }, leading: { configurable: !0 }, lineJoin: { configurable: !0 }, miterLimit: { configurable: !0 }, padding: { configurable: !0 }, stroke: { configurable: !0 }, strokeThickness: { configurable: !0 }, textBaseline: { configurable: !0 }, trim: { configurable: !0 }, whiteSpace: { configurable: !0 }, wordWrap: { configurable: !0 }, wordWrapWidth: { configurable: !0 } }; function getSingleColor (color) { return typeof color === 'number' ? hex2string(color) : (typeof color === 'string' && color.indexOf('0x') === 0 && (color = color.replace('0x', '#')), color) } function getColor (color) { if (Array.isArray(color)) { for (var i = 0; i < color.length; ++i)color[i] = getSingleColor(color[i]); return color } return getSingleColor(color) } function deepCopyProperties (target, source, propertyObj) { for (var prop in propertyObj)Array.isArray(source[prop]) ? target[prop] = source[prop].slice() : target[prop] = source[prop] }TextStyle.prototype.clone = function () { var clonedProperties = {}; return deepCopyProperties(clonedProperties, this, defaultStyle), new TextStyle(clonedProperties) }, TextStyle.prototype.reset = function () { deepCopyProperties(this, defaultStyle, defaultStyle) }, prototypeAccessors$7.align.get = function () { return this._align }, prototypeAccessors$7.align.set = function (align) { this._align !== align && (this._align = align, this.styleID++) }, prototypeAccessors$7.breakWords.get = function () { return this._breakWords }, prototypeAccessors$7.breakWords.set = function (breakWords) { this._breakWords !== breakWords && (this._breakWords = breakWords, this.styleID++) }, prototypeAccessors$7.dropShadow.get = function () { return this._dropShadow }, prototypeAccessors$7.dropShadow.set = function (dropShadow) { this._dropShadow !== dropShadow && (this._dropShadow = dropShadow, this.styleID++) }, prototypeAccessors$7.dropShadowAlpha.get = function () { return this._dropShadowAlpha }, prototypeAccessors$7.dropShadowAlpha.set = function (dropShadowAlpha) { this._dropShadowAlpha !== dropShadowAlpha && (this._dropShadowAlpha = dropShadowAlpha, this.styleID++) }, prototypeAccessors$7.dropShadowAngle.get = function () { return this._dropShadowAngle }, prototypeAccessors$7.dropShadowAngle.set = function (dropShadowAngle) { this._dropShadowAngle !== dropShadowAngle && (this._dropShadowAngle = dropShadowAngle, this.styleID++) }, prototypeAccessors$7.dropShadowBlur.get = function () { return this._dropShadowBlur }, prototypeAccessors$7.dropShadowBlur.set = function (dropShadowBlur) { this._dropShadowBlur !== dropShadowBlur && (this._dropShadowBlur = dropShadowBlur, this.styleID++) }, prototypeAccessors$7.dropShadowColor.get = function () { return this._dropShadowColor }, prototypeAccessors$7.dropShadowColor.set = function (dropShadowColor) { var outputColor = getColor(dropShadowColor); this._dropShadowColor !== outputColor && (this._dropShadowColor = outputColor, this.styleID++) }, prototypeAccessors$7.dropShadowDistance.get = function () { return this._dropShadowDistance }, prototypeAccessors$7.dropShadowDistance.set = function (dropShadowDistance) { this._dropShadowDistance !== dropShadowDistance && (this._dropShadowDistance = dropShadowDistance, this.styleID++) }, prototypeAccessors$7.fill.get = function () { return this._fill }, prototypeAccessors$7.fill.set = function (fill) { var outputColor = getColor(fill); this._fill !== outputColor && (this._fill = outputColor, this.styleID++) }, prototypeAccessors$7.fillGradientType.get = function () { return this._fillGradientType }, prototypeAccessors$7.fillGradientType.set = function (fillGradientType) { this._fillGradientType !== fillGradientType && (this._fillGradientType = fillGradientType, this.styleID++) }, prototypeAccessors$7.fillGradientStops.get = function () { return this._fillGradientStops }, prototypeAccessors$7.fillGradientStops.set = function (fillGradientStops) { !(function (array1, array2) { if (!Array.isArray(array1) || !Array.isArray(array2)) return !1; if (array1.length !== array2.length) return !1; for (var i = 0; i < array1.length; ++i) if (array1[i] !== array2[i]) return !1; return !0 }(this._fillGradientStops, fillGradientStops)) && (this._fillGradientStops = fillGradientStops, this.styleID++) }, prototypeAccessors$7.fontFamily.get = function () { return this._fontFamily }, prototypeAccessors$7.fontFamily.set = function (fontFamily) { this.fontFamily !== fontFamily && (this._fontFamily = fontFamily, this.styleID++) }, prototypeAccessors$7.fontSize.get = function () { return this._fontSize }, prototypeAccessors$7.fontSize.set = function (fontSize) { this._fontSize !== fontSize && (this._fontSize = fontSize, this.styleID++) }, prototypeAccessors$7.fontStyle.get = function () { return this._fontStyle }, prototypeAccessors$7.fontStyle.set = function (fontStyle) { this._fontStyle !== fontStyle && (this._fontStyle = fontStyle, this.styleID++) }, prototypeAccessors$7.fontVariant.get = function () { return this._fontVariant }, prototypeAccessors$7.fontVariant.set = function (fontVariant) { this._fontVariant !== fontVariant && (this._fontVariant = fontVariant, this.styleID++) }, prototypeAccessors$7.fontWeight.get = function () { return this._fontWeight }, prototypeAccessors$7.fontWeight.set = function (fontWeight) { this._fontWeight !== fontWeight && (this._fontWeight = fontWeight, this.styleID++) }, prototypeAccessors$7.letterSpacing.get = function () { return this._letterSpacing }, prototypeAccessors$7.letterSpacing.set = function (letterSpacing) { this._letterSpacing !== letterSpacing && (this._letterSpacing = letterSpacing, this.styleID++) }, prototypeAccessors$7.lineHeight.get = function () { return this._lineHeight }, prototypeAccessors$7.lineHeight.set = function (lineHeight) { this._lineHeight !== lineHeight && (this._lineHeight = lineHeight, this.styleID++) }, prototypeAccessors$7.leading.get = function () { return this._leading }, prototypeAccessors$7.leading.set = function (leading) { this._leading !== leading && (this._leading = leading, this.styleID++) }, prototypeAccessors$7.lineJoin.get = function () { return this._lineJoin }, prototypeAccessors$7.lineJoin.set = function (lineJoin) { this._lineJoin !== lineJoin && (this._lineJoin = lineJoin, this.styleID++) }, prototypeAccessors$7.miterLimit.get = function () { return this._miterLimit }, prototypeAccessors$7.miterLimit.set = function (miterLimit) { this._miterLimit !== miterLimit && (this._miterLimit = miterLimit, this.styleID++) }, prototypeAccessors$7.padding.get = function () { return this._padding }, prototypeAccessors$7.padding.set = function (padding) { this._padding !== padding && (this._padding = padding, this.styleID++) }, prototypeAccessors$7.stroke.get = function () { return this._stroke }, prototypeAccessors$7.stroke.set = function (stroke) { var outputColor = getColor(stroke); this._stroke !== outputColor && (this._stroke = outputColor, this.styleID++) }, prototypeAccessors$7.strokeThickness.get = function () { return this._strokeThickness }, prototypeAccessors$7.strokeThickness.set = function (strokeThickness) { this._strokeThickness !== strokeThickness && (this._strokeThickness = strokeThickness, this.styleID++) }, prototypeAccessors$7.textBaseline.get = function () { return this._textBaseline }, prototypeAccessors$7.textBaseline.set = function (textBaseline) { this._textBaseline !== textBaseline && (this._textBaseline = textBaseline, this.styleID++) }, prototypeAccessors$7.trim.get = function () { return this._trim }, prototypeAccessors$7.trim.set = function (trim) { this._trim !== trim && (this._trim = trim, this.styleID++) }, prototypeAccessors$7.whiteSpace.get = function () { return this._whiteSpace }, prototypeAccessors$7.whiteSpace.set = function (whiteSpace) { this._whiteSpace !== whiteSpace && (this._whiteSpace = whiteSpace, this.styleID++) }, prototypeAccessors$7.wordWrap.get = function () { return this._wordWrap }, prototypeAccessors$7.wordWrap.set = function (wordWrap) { this._wordWrap !== wordWrap && (this._wordWrap = wordWrap, this.styleID++) }, prototypeAccessors$7.wordWrapWidth.get = function () { return this._wordWrapWidth }, prototypeAccessors$7.wordWrapWidth.set = function (wordWrapWidth) { this._wordWrapWidth !== wordWrapWidth && (this._wordWrapWidth = wordWrapWidth, this.styleID++) }, TextStyle.prototype.toFontString = function () { var fontSizeString = typeof this.fontSize === 'number' ? this.fontSize + 'px' : this.fontSize; var fontFamilies = this.fontFamily; Array.isArray(this.fontFamily) || (fontFamilies = this.fontFamily.split(',')); for (var i = fontFamilies.length - 1; i >= 0; i--) { var fontFamily = fontFamilies[i].trim(); !/([\"\'])[^\'\"]+\1/.test(fontFamily) && genericFontFamilies.indexOf(fontFamily) < 0 && (fontFamily = '"' + fontFamily + '"'), fontFamilies[i] = fontFamily } return this.fontStyle + ' ' + this.fontVariant + ' ' + this.fontWeight + ' ' + fontSizeString + ' ' + fontFamilies.join(',') }, Object.defineProperties(TextStyle.prototype, prototypeAccessors$7); var TextMetrics = function (text, style, width, height, lines, lineWidths, lineHeight, maxLineWidth, fontProperties) { this.text = text, this.style = style, this.width = width, this.height = height, this.lines = lines, this.lineWidths = lineWidths, this.lineHeight = lineHeight, this.maxLineWidth = maxLineWidth, this.fontProperties = fontProperties }; TextMetrics.measureText = function (text, style, wordWrap, canvas) { void 0 === canvas && (canvas = TextMetrics._canvas), wordWrap = wordWrap == null ? style.wordWrap : wordWrap; var font = style.toFontString(); var fontProperties = TextMetrics.measureFont(font); fontProperties.fontSize === 0 && (fontProperties.fontSize = style.fontSize, fontProperties.ascent = style.fontSize); var context = canvas.getContext('2d'); context.font = font; for (var lines = (wordWrap ? TextMetrics.wordWrap(text, style, canvas) : text).split(/(?:\r\n|\r|\n)/), lineWidths = new Array(lines.length), maxLineWidth = 0, i = 0; i < lines.length; i++) { var lineWidth = context.measureText(lines[i]).width + (lines[i].length - 1) * style.letterSpacing; lineWidths[i] = lineWidth, maxLineWidth = Math.max(maxLineWidth, lineWidth) } var width = maxLineWidth + style.strokeThickness; style.dropShadow && (width += style.dropShadowDistance); var lineHeight = style.lineHeight || fontProperties.fontSize + style.strokeThickness; var height = Math.max(lineHeight, fontProperties.fontSize + style.strokeThickness) + (lines.length - 1) * (lineHeight + style.leading); return style.dropShadow && (height += style.dropShadowDistance), new TextMetrics(text, style, width, height, lines, lineWidths, lineHeight + style.leading, maxLineWidth, fontProperties) }, TextMetrics.wordWrap = function (text, style, canvas) { void 0 === canvas && (canvas = TextMetrics._canvas); for (var context = canvas.getContext('2d'), width = 0, line = '', lines = '', cache = {}, letterSpacing = style.letterSpacing, whiteSpace = style.whiteSpace, collapseSpaces = TextMetrics.collapseSpaces(whiteSpace), collapseNewlines = TextMetrics.collapseNewlines(whiteSpace), canPrependSpaces = !collapseSpaces, wordWrapWidth = style.wordWrapWidth + letterSpacing, tokens = TextMetrics.tokenize(text), i = 0; i < tokens.length; i++) { var token = tokens[i]; if (TextMetrics.isNewline(token)) { if (!collapseNewlines) { lines += TextMetrics.addLine(line), canPrependSpaces = !collapseSpaces, line = '', width = 0; continue }token = ' ' } if (collapseSpaces) { var currIsBreakingSpace = TextMetrics.isBreakingSpace(token); var lastIsBreakingSpace = TextMetrics.isBreakingSpace(line[line.length - 1]); if (currIsBreakingSpace && lastIsBreakingSpace) continue } var tokenWidth = TextMetrics.getFromCache(token, letterSpacing, cache, context); if (wordWrapWidth < tokenWidth) if (line !== '' && (lines += TextMetrics.addLine(line), line = '', width = 0), TextMetrics.canBreakWords(token, style.breakWords)) for (var characters = token.split(''), j = 0; j < characters.length; j++) { for (var char = characters[j], k = 1; characters[j + k];) { var nextChar = characters[j + k]; var lastChar = char[char.length - 1]; if (TextMetrics.canBreakChars(lastChar, nextChar, token, j, style.breakWords)) break; char += nextChar, k++ }j += char.length - 1; var characterWidth = TextMetrics.getFromCache(char, letterSpacing, cache, context); wordWrapWidth < characterWidth + width && (lines += TextMetrics.addLine(line), canPrependSpaces = !1, line = '', width = 0), line += char, width += characterWidth } else { line.length > 0 && (lines += TextMetrics.addLine(line), line = '', width = 0); var isLastToken = i === tokens.length - 1; lines += TextMetrics.addLine(token, !isLastToken), canPrependSpaces = !1, line = '', width = 0 } else wordWrapWidth < tokenWidth + width && (canPrependSpaces = !1, lines += TextMetrics.addLine(line), line = '', width = 0), (line.length > 0 || !TextMetrics.isBreakingSpace(token) || canPrependSpaces) && (line += token, width += tokenWidth) } return lines += TextMetrics.addLine(line, !1) }, TextMetrics.addLine = function (line, newLine) { return void 0 === newLine && (newLine = !0), line = TextMetrics.trimRight(line), line = newLine ? line + '\n' : line }, TextMetrics.getFromCache = function (key, letterSpacing, cache, context) { var width = cache[key]; if (void 0 === width) { var spacing = key.length * letterSpacing; width = context.measureText(key).width + spacing, cache[key] = width } return width }, TextMetrics.collapseSpaces = function (whiteSpace) { return whiteSpace === 'normal' || whiteSpace === 'pre-line' }, TextMetrics.collapseNewlines = function (whiteSpace) { return whiteSpace === 'normal' }, TextMetrics.trimRight = function (text) { if (typeof text !== 'string') return ''; for (var i = text.length - 1; i >= 0; i--) { var char = text[i]; if (!TextMetrics.isBreakingSpace(char)) break; text = text.slice(0, -1) } return text }, TextMetrics.isNewline = function (char) { return typeof char === 'string' && TextMetrics._newlines.indexOf(char.charCodeAt(0)) >= 0 }, TextMetrics.isBreakingSpace = function (char) { return typeof char === 'string' && TextMetrics._breakingSpaces.indexOf(char.charCodeAt(0)) >= 0 }, TextMetrics.tokenize = function (text) { var tokens = []; var token = ''; if (typeof text !== 'string') return tokens; for (var i = 0; i < text.length; i++) { var char = text[i]; TextMetrics.isBreakingSpace(char) || TextMetrics.isNewline(char) ? (token !== '' && (tokens.push(token), token = ''), tokens.push(char)) : token += char } return token !== '' && tokens.push(token), tokens }, TextMetrics.canBreakWords = function (token, breakWords) { return breakWords }, TextMetrics.canBreakChars = function (char, nextChar, token, index, breakWords) { return !0 }, TextMetrics.measureFont = function (font) { if (TextMetrics._fonts[font]) return TextMetrics._fonts[font]; var properties = {}; var canvas = TextMetrics._canvas; var context = TextMetrics._context; context.font = font; var metricsString = TextMetrics.METRICS_STRING + TextMetrics.BASELINE_SYMBOL; var width = Math.ceil(context.measureText(metricsString).width); var baseline = Math.ceil(context.measureText(TextMetrics.BASELINE_SYMBOL).width); var height = 2 * baseline; baseline = baseline * TextMetrics.BASELINE_MULTIPLIER | 0, canvas.width = width, canvas.height = height, context.fillStyle = '#f00', context.fillRect(0, 0, width, height), context.font = font, context.textBaseline = 'alphabetic', context.fillStyle = '#000', context.fillText(metricsString, 0, baseline); var imagedata = context.getImageData(0, 0, width, height).data; var pixels = imagedata.length; var line = 4 * width; var i = 0; var idx = 0; var stop = !1; for (i = 0; i < baseline; ++i) { for (var j = 0; j < line; j += 4) if (imagedata[idx + j] !== 255) { stop = !0; break } if (stop) break; idx += line } for (properties.ascent = baseline - i, idx = pixels - line, stop = !1, i = height; baseline < i; --i) { for (var j$1 = 0; j$1 < line; j$1 += 4) if (imagedata[idx + j$1] !== 255) { stop = !0; break } if (stop) break; idx -= line } return properties.descent = i - baseline, properties.fontSize = properties.ascent + properties.descent, TextMetrics._fonts[font] = properties }, TextMetrics.clearMetrics = function (font) { void 0 === font && (font = ''), font ? delete TextMetrics._fonts[font] : TextMetrics._fonts = {} }; var canvas = document.createElement('canvas'); canvas.width = canvas.height = 10, TextMetrics._canvas = canvas, TextMetrics._context = canvas.getContext('2d'), TextMetrics._fonts = {}, TextMetrics.METRICS_STRING = '|ÉqÅ', TextMetrics.BASELINE_SYMBOL = 'M', TextMetrics.BASELINE_MULTIPLIER = 1.4, TextMetrics._newlines = [10, 13]; var defaultDestroyOptions = { texture: !0, children: !(TextMetrics._breakingSpaces = [9, 32, 8192, 8193, 8194, 8195, 8196, 8197, 8198, 8200, 8201, 8202, 8287, 12288]), baseTexture: !0 }; var Text = (function (Sprite) { function Text (text, style, canvas) { (canvas = canvas || document.createElement('canvas')).width = 3, canvas.height = 3; var texture = Texture.from(canvas); texture.orig = new Rectangle(), texture.trim = new Rectangle(), Sprite.call(this, texture), this.canvas = canvas, this.context = this.canvas.getContext('2d'), this._resolution = settings.RESOLUTION, this._autoResolution = !0, this._text = null, this._style = null, this._styleListener = null, this._font = '', this.text = text, this.style = style, this.localStyleID = -1 }Sprite && (Text.__proto__ = Sprite); var prototypeAccessors = { width: { configurable: !0 }, height: { configurable: !0 }, style: { configurable: !0 }, text: { configurable: !0 }, resolution: { configurable: !0 } }; return ((Text.prototype = Object.create(Sprite && Sprite.prototype)).constructor = Text).prototype.updateText = function (respectDirty) { var style = this._style; if (this.localStyleID !== style.styleID && (this.dirty = !0, this.localStyleID = style.styleID), this.dirty || !respectDirty) { this._font = this._style.toFontString(); var linePositionX; var linePositionY; var context = this.context; var measured = TextMetrics.measureText(this._text || ' ', this._style, this._style.wordWrap, this.canvas); var width = measured.width; var height = measured.height; var lines = measured.lines; var lineHeight = measured.lineHeight; var lineWidths = measured.lineWidths; var maxLineWidth = measured.maxLineWidth; var fontProperties = measured.fontProperties; if (this.canvas.width = Math.ceil((Math.max(1, width) + 2 * style.padding) * this._resolution), this.canvas.height = Math.ceil((Math.max(1, height) + 2 * style.padding) * this._resolution), context.scale(this._resolution, this._resolution), context.clearRect(0, 0, this.canvas.width, this.canvas.height), context.font = this._font, context.strokeStyle = style.stroke, context.lineWidth = style.strokeThickness, context.textBaseline = style.textBaseline, context.lineJoin = style.lineJoin, context.miterLimit = style.miterLimit, style.dropShadow) { var dropShadowColor = style.dropShadowColor; var rgb = hex2rgb(typeof dropShadowColor === 'number' ? dropShadowColor : string2hex(dropShadowColor)); context.shadowColor = 'rgba(' + 255 * rgb[0] + ',' + 255 * rgb[1] + ',' + 255 * rgb[2] + ',' + style.dropShadowAlpha + ')', context.shadowBlur = style.dropShadowBlur, context.shadowOffsetX = Math.cos(style.dropShadowAngle) * style.dropShadowDistance, context.shadowOffsetY = Math.sin(style.dropShadowAngle) * style.dropShadowDistance } else context.shadowColor = 0, context.shadowBlur = 0, context.shadowOffsetX = 0, context.shadowOffsetY = 0; context.fillStyle = this._generateFillStyle(style, lines); for (var i = 0; i < lines.length; i++)linePositionX = style.strokeThickness / 2, linePositionY = style.strokeThickness / 2 + i * lineHeight + fontProperties.ascent, style.align === 'right' ? linePositionX += maxLineWidth - lineWidths[i] : style.align === 'center' && (linePositionX += (maxLineWidth - lineWidths[i]) / 2), style.stroke && style.strokeThickness && this.drawLetterSpacing(lines[i], linePositionX + style.padding, linePositionY + style.padding, !0), style.fill && this.drawLetterSpacing(lines[i], linePositionX + style.padding, linePositionY + style.padding); this.updateTexture() } }, Text.prototype.drawLetterSpacing = function (text, x, y, isStroke) { void 0 === isStroke && (isStroke = !1); var letterSpacing = this._style.letterSpacing; if (letterSpacing !== 0) for (var currentPosition = x, stringArray = Array.from ? Array.from(text) : text.split(''), i = 0; i < stringArray.length; ++i) { var currentChar = stringArray[i]; isStroke ? this.context.strokeText(currentChar, currentPosition, y) : this.context.fillText(currentChar, currentPosition, y), currentPosition += this.context.measureText(currentChar).width + letterSpacing } else isStroke ? this.context.strokeText(text, x, y) : this.context.fillText(text, x, y) }, Text.prototype.updateTexture = function () { var canvas = this.canvas; if (this._style.trim) { var trimmed = trimCanvas(canvas); trimmed.data && (canvas.width = trimmed.width, canvas.height = trimmed.height, this.context.putImageData(trimmed.data, 0, 0)) } var texture = this._texture; var style = this._style; var padding = style.trim ? 0 : style.padding; var baseTexture = texture.baseTexture; texture.trim.width = texture._frame.width = canvas.width / this._resolution, texture.trim.height = texture._frame.height = canvas.height / this._resolution, texture.trim.x = -padding, texture.trim.y = -padding, texture.orig.width = texture._frame.width - 2 * padding, texture.orig.height = texture._frame.height - 2 * padding, this._onTextureUpdate(), baseTexture.setRealSize(canvas.width, canvas.height, this._resolution), this.dirty = !1 }, Text.prototype.render = function (renderer) { this._autoResolution && this._resolution !== renderer.resolution && (this._resolution = renderer.resolution, this.dirty = !0), this.updateText(!0), Sprite.prototype.render.call(this, renderer) }, Text.prototype._renderCanvas = function (renderer) { this._autoResolution && this._resolution !== renderer.resolution && (this._resolution = renderer.resolution, this.dirty = !0), this.updateText(!0), Sprite.prototype._renderCanvas.call(this, renderer) }, Text.prototype.getLocalBounds = function (rect) { return this.updateText(!0), Sprite.prototype.getLocalBounds.call(this, rect) }, Text.prototype._calculateBounds = function () { this.updateText(!0), this.calculateVertices(), this._bounds.addQuad(this.vertexData) }, Text.prototype._onStyleChange = function () { this.dirty = !0 }, Text.prototype._generateFillStyle = function (style, lines) { if (!Array.isArray(style.fill)) return style.fill; var gradient; var totalIterations; var currentIteration; var stop; var width = this.canvas.width / this._resolution; var height = this.canvas.height / this._resolution; var fill = style.fill.slice(); var fillGradientStops = style.fillGradientStops.slice(); if (!fillGradientStops.length) for (var lengthPlus1 = fill.length + 1, i = 1; i < lengthPlus1; ++i)fillGradientStops.push(i / lengthPlus1); if (fill.unshift(style.fill[0]), fillGradientStops.unshift(0), fill.push(style.fill[style.fill.length - 1]), fillGradientStops.push(1), style.fillGradientType === TEXT_GRADIENT.LINEAR_VERTICAL) { gradient = this.context.createLinearGradient(width / 2, 0, width / 2, height), totalIterations = (fill.length + 1) * lines.length; for (var i$1 = currentIteration = 0; i$1 < lines.length; i$1++) { currentIteration += 1; for (var j = 0; j < fill.length; j++)stop = typeof fillGradientStops[j] === 'number' ? fillGradientStops[j] / lines.length + i$1 / lines.length : currentIteration / totalIterations, gradient.addColorStop(stop, fill[j]), currentIteration++ } } else { gradient = this.context.createLinearGradient(0, height / 2, width, height / 2), totalIterations = fill.length + 1, currentIteration = 1; for (var i$2 = 0; i$2 < fill.length; i$2++)stop = typeof fillGradientStops[i$2] === 'number' ? fillGradientStops[i$2] : currentIteration / totalIterations, gradient.addColorStop(stop, fill[i$2]), currentIteration++ } return gradient }, Text.prototype.destroy = function (options) { typeof options === 'boolean' && (options = { children: options }), options = Object.assign({}, defaultDestroyOptions, options), Sprite.prototype.destroy.call(this, options), this.context = null, this.canvas = null, this._style = null }, prototypeAccessors.width.get = function () { return this.updateText(!0), Math.abs(this.scale.x) * this._texture.orig.width }, prototypeAccessors.width.set = function (value) { this.updateText(!0); var s = sign(this.scale.x) || 1; this.scale.x = s * value / this._texture.orig.width, this._width = value }, prototypeAccessors.height.get = function () { return this.updateText(!0), Math.abs(this.scale.y) * this._texture.orig.height }, prototypeAccessors.height.set = function (value) { this.updateText(!0); var s = sign(this.scale.y) || 1; this.scale.y = s * value / this._texture.orig.height, this._height = value }, prototypeAccessors.style.get = function () { return this._style }, prototypeAccessors.style.set = function (style) { style = style || {}, this._style = style instanceof TextStyle ? style : new TextStyle(style), this.localStyleID = -1, this.dirty = !0 }, prototypeAccessors.text.get = function () { return this._text }, prototypeAccessors.text.set = function (text) { text = String(text == null ? '' : text), this._text !== text && (this._text = text, this.dirty = !0) }, prototypeAccessors.resolution.get = function () { return this._resolution }, prototypeAccessors.resolution.set = function (value) { this._autoResolution = !1, this._resolution !== value && (this._resolution = value, this.dirty = !0) }, Object.defineProperties(Text.prototype, prototypeAccessors), Text }(Sprite)); settings.UPLOADS_PER_FRAME = 4; var CountLimiter = function (maxItemsPerFrame) { this.maxItemsPerFrame = maxItemsPerFrame, this.itemsLeft = 0 }; CountLimiter.prototype.beginFrame = function () { this.itemsLeft = this.maxItemsPerFrame }, CountLimiter.prototype.allowedToUpload = function () { return this.itemsLeft-- > 0 }; var BasePrepare = function (renderer) { var this$1 = this; this.limiter = new CountLimiter(settings.UPLOADS_PER_FRAME), this.renderer = renderer, this.uploadHookHelper = null, this.queue = [], this.addHooks = [], this.uploadHooks = [], this.completes = [], this.ticking = !1, this.delayedTick = function () { this$1.queue && this$1.prepareItems() }, this.registerFindHook(findText), this.registerFindHook(findTextStyle), this.registerFindHook(findMultipleBaseTextures), this.registerFindHook(findBaseTexture), this.registerFindHook(findTexture), this.registerUploadHook(drawText), this.registerUploadHook(calculateTextStyle) }; function findMultipleBaseTextures (item, queue) { var result = !1; if (item && item._textures && item._textures.length) for (var i = 0; i < item._textures.length; i++) if (item._textures[i] instanceof Texture) { var baseTexture = item._textures[i].baseTexture; queue.indexOf(baseTexture) === -1 && (queue.push(baseTexture), result = !0) } return result } function findBaseTexture (item, queue) { return item instanceof BaseTexture && (queue.indexOf(item) === -1 && queue.push(item), !0) } function findTexture (item, queue) { if (item._texture && item._texture instanceof Texture) { var texture = item._texture.baseTexture; return queue.indexOf(texture) === -1 && queue.push(texture), !0 } return !1 } function drawText (helper, item) { return item instanceof Text && (item.updateText(!0), !0) } function calculateTextStyle (helper, item) { if (item instanceof TextStyle) { var font = item.toFontString(); return TextMetrics.measureFont(font), !0 } return !1 } function findText (item, queue) { if (item instanceof Text) { queue.indexOf(item.style) === -1 && queue.push(item.style), queue.indexOf(item) === -1 && queue.push(item); var texture = item._texture.baseTexture; return queue.indexOf(texture) === -1 && queue.push(texture), !0 } return !1 } function findTextStyle (item, queue) { return item instanceof TextStyle && (queue.indexOf(item) === -1 && queue.push(item), !0) }BasePrepare.prototype.upload = function (item, done) { typeof item === 'function' && (done = item, item = null), item && this.add(item), this.queue.length ? (done && this.completes.push(done), this.ticking || (this.ticking = !0, Ticker.system.addOnce(this.tick, this, UPDATE_PRIORITY.UTILITY))) : done && done() }, BasePrepare.prototype.tick = function () { setTimeout(this.delayedTick, 0) }, BasePrepare.prototype.prepareItems = function () { for (this.limiter.beginFrame(); this.queue.length && this.limiter.allowedToUpload();) { var item = this.queue[0]; var uploaded = !1; if (item && !item._destroyed) for (var i = 0, len = this.uploadHooks.length; i < len; i++) if (this.uploadHooks[i](this.uploadHookHelper, item)) { this.queue.shift(), uploaded = !0; break }uploaded || this.queue.shift() } if (this.queue.length)Ticker.system.addOnce(this.tick, this, UPDATE_PRIORITY.UTILITY); else { this.ticking = !1; for (var completes = this.completes.slice(0), i$1 = this.completes.length = 0, len$1 = completes.length; i$1 < len$1; i$1++)completes[i$1]() } }, BasePrepare.prototype.registerFindHook = function (addHook) { return addHook && this.addHooks.push(addHook), this }, BasePrepare.prototype.registerUploadHook = function (uploadHook) { return uploadHook && this.uploadHooks.push(uploadHook), this }, BasePrepare.prototype.add = function (item) { for (var i = 0, len = this.addHooks.length; i < len && !this.addHooks[i](item, this.queue); i++);if (item instanceof Container) for (var i$1 = item.children.length - 1; i$1 >= 0; i$1--) this.add(item.children[i$1]); return this }, BasePrepare.prototype.destroy = function () { this.ticking && Ticker.system.remove(this.tick, this), this.ticking = !1, this.addHooks = null, this.uploadHooks = null, this.renderer = null, this.completes = null, this.queue = null, this.limiter = null, this.uploadHookHelper = null }; var Prepare = (function (BasePrepare) { function Prepare (renderer) { BasePrepare.call(this, renderer), this.uploadHookHelper = this.renderer, this.registerFindHook(findGraphics), this.registerUploadHook(uploadBaseTextures), this.registerUploadHook(uploadGraphics) } return BasePrepare && (Prepare.__proto__ = BasePrepare), (Prepare.prototype = Object.create(BasePrepare && BasePrepare.prototype)).constructor = Prepare }(BasePrepare)); function uploadBaseTextures (renderer, item) { return item instanceof BaseTexture && (item._glTextures[renderer.CONTEXT_UID] || renderer.textureManager.updateTexture(item), !0) } function uploadGraphics (renderer, item) { return item instanceof Graphics && (!item.dirty && !item.clearDirty && item._webGL[renderer.plugins.graphics.CONTEXT_UID] || renderer.plugins.graphics.updateGraphics(item), !0) } function findGraphics (item, queue) { return item instanceof Graphics && (queue.push(item), !0) } var TimeLimiter = function (maxMilliseconds) { this.maxMilliseconds = maxMilliseconds, this.frameStart = 0 }; TimeLimiter.prototype.beginFrame = function () { this.frameStart = Date.now() }, TimeLimiter.prototype.allowedToUpload = function () { return Date.now() - this.frameStart < this.maxMilliseconds }; function Application (options) { var this$1 = this; options = Object.assign({ forceCanvas: !1 }, options), this.renderer = autoDetectRenderer(options), this.stage = new Container(), Application._plugins.forEach(function (plugin) { plugin.init.call(this$1, options) }) } var prepare_es = { BasePrepare: BasePrepare, CountLimiter: CountLimiter, Prepare: Prepare, TimeLimiter: TimeLimiter }; var prototypeAccessors$8 = { view: { configurable: !0 }, screen: { configurable: !0 } }; Application.registerPlugin = function (plugin) { Application._plugins.push(plugin) }, Application.prototype.render = function () { this.renderer.render(this.stage) }, prototypeAccessors$8.view.get = function () { return this.renderer.view }, prototypeAccessors$8.screen.get = function () { return this.renderer.screen }, Application.prototype.destroy = function (removeView) { var this$1 = this; var plugins = Application._plugins.slice(0); plugins.reverse(), plugins.forEach(function (plugin) { plugin.destroy.call(this$1) }), this.stage.destroy(), this.stage = null, this.renderer.destroy(removeView), this.renderer = null, this._options = null }, Object.defineProperties(Application.prototype, prototypeAccessors$8), Application._plugins = []; var ResizePlugin = function () {}; ResizePlugin.init = function (options) { var this$1 = this; Object.defineProperty(this, 'resizeTo', { set: function (dom) { window.removeEventListener('resize', this.resize), (this._resizeTo = dom) && (window.addEventListener('resize', this.resize), this.resize()) }, get: function () { return this._resizeTo } }), this.resize = function () { this$1._resizeTo && (this$1._resizeTo === window ? this$1.renderer.resize(window.innerWidth, window.innerHeight) : this$1.renderer.resize(this$1._resizeTo.clientWidth, this$1._resizeTo.clientHeight)) }, this._resizeTo = null, this.resizeTo = options.resizeTo || null }, ResizePlugin.destroy = function () { this.resizeTo = null, this.resize = null }, Application.registerPlugin(ResizePlugin); function parseUri (str, opts) { opts = opts || {}; for (var o = { key: ['source', 'protocol', 'authority', 'userInfo', 'user', 'password', 'host', 'port', 'relative', 'path', 'directory', 'file', 'query', 'anchor'], q: { name: 'queryKey', parser: /(?:^|&)([^&=]*)=?([^&]*)/g }, parser: { strict: /^(?:([^:\/?#]+):)?(?:\/\/((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\/?#]*)(?::(\d*))?))?((((?:[^?#\/]*\/)*)([^?#]*))(?:\?([^#]*))?(?:#(.*))?)/, loose: /^(?:(?![^:@]+:[^:@\/]*@)([^:\/?#.]+):)?(?:\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/ } }, m = o.parser[opts.strictMode ? 'strict' : 'loose'].exec(str), uri = {}, i = 14; i--;)uri[o.key[i]] = m[i] || ''; return uri[o.q.name] = {}, uri[o.key[12]].replace(o.q.parser, function ($0, $1, $2) { $1 && (uri[o.q.name][$1] = $2) }), uri } var miniSignals = createCommonjsModule(function (module, exports) { Object.defineProperty(exports, '__esModule', { value: !0 }); var _createClass = function (Constructor, protoProps, staticProps) { return protoProps && defineProperties(Constructor.prototype, protoProps), staticProps && defineProperties(Constructor, staticProps), Constructor }; function defineProperties (target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, 'value' in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor) } } function _classCallCheck (instance, Constructor) { if (!(instance instanceof Constructor)) throw new TypeError('Cannot call a class as a function') } var MiniSignalBinding = (function () { function MiniSignalBinding (fn, once, thisArg) { void 0 === once && (once = !1), _classCallCheck(this, MiniSignalBinding), this._fn = fn, this._once = once, this._thisArg = thisArg, this._next = this._prev = this._owner = null } return _createClass(MiniSignalBinding, [{ key: 'detach', value: function () { return this._owner !== null && (this._owner.detach(this), !0) } }]), MiniSignalBinding }()); function _addMiniSignalBinding (self, node) { return self._head ? (self._tail._next = node)._prev = self._tail : self._head = node, (self._tail = node)._owner = self, node } var MiniSignal = (function () { function MiniSignal () { _classCallCheck(this, MiniSignal), this._head = this._tail = void 0 } return _createClass(MiniSignal, [{ key: 'handlers', value: function (argument_0) { var exists = !(arguments.length <= 0 || void 0 === argument_0) && argument_0; var node = this._head; if (exists) return !!node; for (var ee = []; node;)ee.push(node), node = node._next; return ee } }, { key: 'has', value: function (node) { if (!(node instanceof MiniSignalBinding)) throw new Error('MiniSignal#has(): First arg must be a MiniSignalBinding object.'); return node._owner === this } }, { key: 'dispatch', value: function () { var arguments$1 = arguments; var node = this._head; if (!node) return !1; for (;node;)node._once && this.detach(node), node._fn.apply(node._thisArg, arguments$1), node = node._next; return !0 } }, { key: 'add', value: function (fn, argument_1) { var thisArg = arguments.length <= 1 || void 0 === argument_1 ? null : argument_1; if (typeof fn !== 'function') throw new Error('MiniSignal#add(): First arg must be a Function.'); return _addMiniSignalBinding(this, new MiniSignalBinding(fn, !1, thisArg)) } }, { key: 'once', value: function (fn, argument_1) { var thisArg = arguments.length <= 1 || void 0 === argument_1 ? null : argument_1; if (typeof fn !== 'function') throw new Error('MiniSignal#once(): First arg must be a Function.'); return _addMiniSignalBinding(this, new MiniSignalBinding(fn, !0, thisArg)) } }, { key: 'detach', value: function (node) { if (!(node instanceof MiniSignalBinding)) throw new Error('MiniSignal#detach(): First arg must be a MiniSignalBinding object.'); return node._owner !== this || (node._prev && (node._prev._next = node._next), node._next && (node._next._prev = node._prev), node === this._head ? (this._head = node._next, node._next === null && (this._tail = null)) : node === this._tail && (this._tail = node._prev, this._tail._next = null), node._owner = null), this } }, { key: 'detachAll', value: function () { var node = this._head; if (!node) return this; for (this._head = this._tail = null; node;)node._owner = null, node = node._next; return this } }]), MiniSignal }()); MiniSignal.MiniSignalBinding = MiniSignalBinding, exports.default = MiniSignal, module.exports = exports.default }); var async = (unwrapExports(miniSignals), createCommonjsModule(function (module, exports) { function _noop () {} function onlyOnce (fn) { return function () { if (fn === null) throw new Error('Callback was already called.'); var callFn = fn; fn = null, callFn.apply(this, arguments) } }exports.__esModule = !0, exports.eachSeries = function (array, iterator, callback, deferNext) { var i = 0; var len = array.length; !(function next (err) { err || i === len ? callback && callback(err) : deferNext ? setTimeout(function () { iterator(array[i++], next) }, 1) : iterator(array[i++], next) }()) }, exports.queue = function (worker, concurrency) { if (concurrency == null)concurrency = 1; else if (concurrency === 0) throw new Error('Concurrency must not be zero'); var workers = 0; var q = { _tasks: [], concurrency: concurrency, saturated: _noop, unsaturated: _noop, buffer: concurrency / 4, empty: _noop, drain: _noop, error: _noop, started: !1, paused: !1, push: function (data, callback) { _insert(data, !1, callback) }, kill: function () { workers = 0, q.drain = _noop, q.started = !1, q._tasks = [] }, unshift: function (data, callback) { _insert(data, !0, callback) }, process: function () { for (;!q.paused && workers < q.concurrency && q._tasks.length;) { var task = q._tasks.shift(); q._tasks.length === 0 && q.empty(), (workers += 1) === q.concurrency && q.saturated(), worker(task.data, onlyOnce(_next(task))) } }, length: function () { return q._tasks.length }, running: function () { return workers }, idle: function () { return q._tasks.length + workers === 0 }, pause: function () { !0 !== q.paused && (q.paused = !0) }, resume: function () { if (!1 !== q.paused) { q.paused = !1; for (var w = 1; w <= q.concurrency; w++)q.process() } } }; function _insert (data, insertAtFront, callback) { if (callback != null && typeof callback !== 'function') throw new Error('task callback must be a function'); if (q.started = !0, data == null && q.idle())setTimeout(function () { return q.drain() }, 1); else { var item = { data: data, callback: typeof callback === 'function' ? callback : _noop }; insertAtFront ? q._tasks.unshift(item) : q._tasks.push(item), setTimeout(function () { return q.process() }, 1) } } function _next (task) { return function (argument_0) { workers -= 1, task.callback.apply(task, arguments), argument_0 != null && q.error(argument_0, task.data), workers <= q.concurrency - q.buffer && q.unsaturated(), q.idle() && q.drain(), q.process() } } return q } })); var Resource_1 = (unwrapExports(async), async.eachSeries, async.queue, createCommonjsModule(function (module, exports) { exports.__esModule = !0, exports.Resource = void 0; var _createClass = function (Constructor, protoProps, staticProps) { return protoProps && defineProperties(Constructor.prototype, protoProps), staticProps && defineProperties(Constructor, staticProps), Constructor }; function defineProperties (target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, 'value' in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor) } } var _parseUri2 = _interopRequireDefault(parseUri); var _miniSignals2 = _interopRequireDefault(miniSignals); function _interopRequireDefault (obj) { return obj && obj.__esModule ? obj : { default: obj } } var useXdr = !(!window.XDomainRequest || 'withCredentials' in new XMLHttpRequest()); var tempAnchor = null; function _noop () {} var Resource = exports.Resource = (function () { function Resource (name, url, options) { if ((function (instance, Constructor) { if (!(instance instanceof Constructor)) throw new TypeError('Cannot call a class as a function') }(this, Resource)), typeof name !== 'string' || typeof url !== 'string') throw new Error('Both name and url are required for constructing a resource.'); options = options || {}, this._flags = 0, this._setFlag(Resource.STATUS_FLAGS.DATA_URL, url.indexOf('data:') === 0), this.name = name, this.url = url, this.extension = this._getExtension(), this.data = null, this.crossOrigin = !0 === options.crossOrigin ? 'anonymous' : options.crossOrigin, this.timeout = options.timeout || 0, this.loadType = options.loadType || this._determineLoadType(), this.xhrType = options.xhrType, this.metadata = options.metadata || {}, this.error = null, this.xhr = null, this.children = [], this.type = Resource.TYPE.UNKNOWN, this.progressChunk = 0, this._dequeue = _noop, this._onLoadBinding = null, this._elementTimer = 0, this._boundComplete = this.complete.bind(this), this._boundOnError = this._onError.bind(this), this._boundOnProgress = this._onProgress.bind(this), this._boundOnTimeout = this._onTimeout.bind(this), this._boundXhrOnError = this._xhrOnError.bind(this), this._boundXhrOnTimeout = this._xhrOnTimeout.bind(this), this._boundXhrOnAbort = this._xhrOnAbort.bind(this), this._boundXhrOnLoad = this._xhrOnLoad.bind(this), this.onStart = new _miniSignals2.default(), this.onProgress = new _miniSignals2.default(), this.onComplete = new _miniSignals2.default(), this.onAfterMiddleware = new _miniSignals2.default() } return Resource.setExtensionLoadType = function (extname, loadType) { setExtMap(Resource._loadTypeMap, extname, loadType) }, Resource.setExtensionXhrType = function (extname, xhrType) { setExtMap(Resource._xhrTypeMap, extname, xhrType) }, Resource.prototype.complete = function () { this._clearEvents(), this._finish() }, Resource.prototype.abort = function (message) { if (!this.error) { if (this.error = new Error(message), this._clearEvents(), this.xhr) this.xhr.abort(); else if (this.xdr) this.xdr.abort(); else if (this.data) if (this.data.src) this.data.src = Resource.EMPTY_GIF; else for (;this.data.firstChild;) this.data.removeChild(this.data.firstChild); this._finish() } }, Resource.prototype.load = function (cb) { var _this = this; if (!this.isLoading) if (this.isComplete)cb && setTimeout(function () { return cb(_this) }, 1); else switch (cb && this.onComplete.once(cb), this._setFlag(Resource.STATUS_FLAGS.LOADING, !0), this.onStart.dispatch(this), !1 !== this.crossOrigin && typeof this.crossOrigin === 'string' || (this.crossOrigin = this._determineCrossOrigin(this.url)), this.loadType) { case Resource.LOAD_TYPE.IMAGE:this.type = Resource.TYPE.IMAGE, this._loadElement('image'); break; case Resource.LOAD_TYPE.AUDIO:this.type = Resource.TYPE.AUDIO, this._loadSourceElement('audio'); break; case Resource.LOAD_TYPE.VIDEO:this.type = Resource.TYPE.VIDEO, this._loadSourceElement('video'); break; case Resource.LOAD_TYPE.XHR:default:useXdr && this.crossOrigin ? this._loadXdr() : this._loadXhr() } }, Resource.prototype._hasFlag = function (flag) { return (this._flags & flag) != 0 }, Resource.prototype._setFlag = function (flag, value) { this._flags = value ? this._flags | flag : this._flags & ~flag }, Resource.prototype._clearEvents = function () { clearTimeout(this._elementTimer), this.data && this.data.removeEventListener && (this.data.removeEventListener('error', this._boundOnError, !1), this.data.removeEventListener('load', this._boundComplete, !1), this.data.removeEventListener('progress', this._boundOnProgress, !1), this.data.removeEventListener('canplaythrough', this._boundComplete, !1)), this.xhr && (this.xhr.removeEventListener ? (this.xhr.removeEventListener('error', this._boundXhrOnError, !1), this.xhr.removeEventListener('timeout', this._boundXhrOnTimeout, !1), this.xhr.removeEventListener('abort', this._boundXhrOnAbort, !1), this.xhr.removeEventListener('progress', this._boundOnProgress, !1), this.xhr.removeEventListener('load', this._boundXhrOnLoad, !1)) : (this.xhr.onerror = null, this.xhr.ontimeout = null, this.xhr.onprogress = null, this.xhr.onload = null)) }, Resource.prototype._finish = function () { if (this.isComplete) throw new Error('Complete called again for an already completed resource.'); this._setFlag(Resource.STATUS_FLAGS.COMPLETE, !0), this._setFlag(Resource.STATUS_FLAGS.LOADING, !1), this.onComplete.dispatch(this) }, Resource.prototype._loadElement = function (type) { this.metadata.loadElement ? this.data = this.metadata.loadElement : type === 'image' && void 0 !== window.Image ? this.data = new Image() : this.data = document.createElement(type), this.crossOrigin && (this.data.crossOrigin = this.crossOrigin), this.metadata.skipSource || (this.data.src = this.url), this.data.addEventListener('error', this._boundOnError, !1), this.data.addEventListener('load', this._boundComplete, !1), this.data.addEventListener('progress', this._boundOnProgress, !1), this.timeout && (this._elementTimer = setTimeout(this._boundOnTimeout, this.timeout)) }, Resource.prototype._loadSourceElement = function (type) { if (this.metadata.loadElement ? this.data = this.metadata.loadElement : type === 'audio' && void 0 !== window.Audio ? this.data = new Audio() : this.data = document.createElement(type), this.data !== null) { if (this.crossOrigin && (this.data.crossOrigin = this.crossOrigin), !this.metadata.skipSource) if (navigator.isCocoonJS) this.data.src = Array.isArray(this.url) ? this.url[0] : this.url; else if (Array.isArray(this.url)) for (var mimeTypes = this.metadata.mimeType, i = 0; i < this.url.length; ++i) this.data.appendChild(this._createSource(type, this.url[i], Array.isArray(mimeTypes) ? mimeTypes[i] : mimeTypes)); else { var _mimeTypes = this.metadata.mimeType; this.data.appendChild(this._createSource(type, this.url, Array.isArray(_mimeTypes) ? _mimeTypes[0] : _mimeTypes)) } this.data.addEventListener('error', this._boundOnError, !1), this.data.addEventListener('load', this._boundComplete, !1), this.data.addEventListener('progress', this._boundOnProgress, !1), this.data.addEventListener('canplaythrough', this._boundComplete, !1), this.data.load(), this.timeout && (this._elementTimer = setTimeout(this._boundOnTimeout, this.timeout)) } else this.abort('Unsupported element: ' + type) }, Resource.prototype._loadXhr = function () { typeof this.xhrType !== 'string' && (this.xhrType = this._determineXhrType()); var xhr = this.xhr = new XMLHttpRequest(); xhr.open('GET', this.url, !0), xhr.timeout = this.timeout, this.xhrType === Resource.XHR_RESPONSE_TYPE.JSON || this.xhrType === Resource.XHR_RESPONSE_TYPE.DOCUMENT ? xhr.responseType = Resource.XHR_RESPONSE_TYPE.TEXT : xhr.responseType = this.xhrType, xhr.addEventListener('error', this._boundXhrOnError, !1), xhr.addEventListener('timeout', this._boundXhrOnTimeout, !1), xhr.addEventListener('abort', this._boundXhrOnAbort, !1), xhr.addEventListener('progress', this._boundOnProgress, !1), xhr.addEventListener('load', this._boundXhrOnLoad, !1), xhr.send() }, Resource.prototype._loadXdr = function () { typeof this.xhrType !== 'string' && (this.xhrType = this._determineXhrType()); var xdr = this.xhr = new XDomainRequest(); xdr.timeout = this.timeout || 5e3, xdr.onerror = this._boundXhrOnError, xdr.ontimeout = this._boundXhrOnTimeout, xdr.onprogress = this._boundOnProgress, xdr.onload = this._boundXhrOnLoad, xdr.open('GET', this.url, !0), setTimeout(function () { return xdr.send() }, 1) }, Resource.prototype._createSource = function (type, url, mime) { mime = mime || type + '/' + this._getExtension(url); var source = document.createElement('source'); return source.src = url, source.type = mime, source }, Resource.prototype._onError = function (event) { this.abort('Failed to load element using: ' + event.target.nodeName) }, Resource.prototype._onProgress = function (event) { event && event.lengthComputable && this.onProgress.dispatch(this, event.loaded / event.total) }, Resource.prototype._onTimeout = function () { this.abort('Load timed out.') }, Resource.prototype._xhrOnError = function () { var xhr = this.xhr; this.abort(reqType(xhr) + ' Request failed. Status: ' + xhr.status + ', text: "' + xhr.statusText + '"') }, Resource.prototype._xhrOnTimeout = function () { var xhr = this.xhr; this.abort(reqType(xhr) + ' Request timed out.') }, Resource.prototype._xhrOnAbort = function () { var xhr = this.xhr; this.abort(reqType(xhr) + ' Request was aborted by the user.') }, Resource.prototype._xhrOnLoad = function () { var xhr = this.xhr; var text = ''; var status = void 0 === xhr.status ? 200 : xhr.status; if (xhr.responseType !== '' && xhr.responseType !== 'text' && void 0 !== xhr.responseType || (text = xhr.responseText), status === 0 && (text.length > 0 || xhr.responseType === Resource.XHR_RESPONSE_TYPE.BUFFER) ? status = 200 : status === 1223 && (status = 204), (status / 100 | 0) == 2) { if (this.xhrType === Resource.XHR_RESPONSE_TYPE.TEXT) this.data = text, this.type = Resource.TYPE.TEXT; else if (this.xhrType === Resource.XHR_RESPONSE_TYPE.JSON) try { this.data = JSON.parse(text), this.type = Resource.TYPE.JSON } catch (e) { return void this.abort('Error trying to parse loaded json: ' + e) } else if (this.xhrType === Resource.XHR_RESPONSE_TYPE.DOCUMENT) try { if (window.DOMParser) { var domparser = new DOMParser(); this.data = domparser.parseFromString(text, 'text/xml') } else { var div = document.createElement('div'); div.innerHTML = text, this.data = div } this.type = Resource.TYPE.XML } catch (e) { return void this.abort('Error trying to parse loaded xml: ' + e) } else this.data = xhr.response || text; this.complete() } else this.abort('[' + xhr.status + '] ' + xhr.statusText + ': ' + xhr.responseURL) }, Resource.prototype._determineCrossOrigin = function (url, loc) { if (url.indexOf('data:') === 0) return ''; if (window.origin !== window.location.origin) return 'anonymous'; loc = loc || window.location, (tempAnchor = tempAnchor || document.createElement('a')).href = url; var samePort = !(url = (0, _parseUri2.default)(tempAnchor.href, { strictMode: !0 })).port && loc.port === '' || url.port === loc.port; var protocol = url.protocol ? url.protocol + ':' : ''; return url.host === loc.hostname && samePort && protocol === loc.protocol ? '' : 'anonymous' }, Resource.prototype._determineXhrType = function () { return Resource._xhrTypeMap[this.extension] || Resource.XHR_RESPONSE_TYPE.TEXT }, Resource.prototype._determineLoadType = function () { return Resource._loadTypeMap[this.extension] || Resource.LOAD_TYPE.XHR }, Resource.prototype._getExtension = function () { var url = this.url; var ext = ''; if (this.isDataUrl) { var slashIndex = url.indexOf('/'); ext = url.substring(slashIndex + 1, url.indexOf(';', slashIndex)) } else { var queryStart = url.indexOf('?'); var hashStart = url.indexOf('#'); var index = Math.min(queryStart > -1 ? queryStart : url.length, hashStart > -1 ? hashStart : url.length); ext = (url = url.substring(0, index)).substring(url.lastIndexOf('.') + 1) } return ext.toLowerCase() }, Resource.prototype._getMimeFromXhrType = function (type) { switch (type) { case Resource.XHR_RESPONSE_TYPE.BUFFER:return 'application/octet-binary'; case Resource.XHR_RESPONSE_TYPE.BLOB:return 'application/blob'; case Resource.XHR_RESPONSE_TYPE.DOCUMENT:return 'application/xml'; case Resource.XHR_RESPONSE_TYPE.JSON:return 'application/json'; case Resource.XHR_RESPONSE_TYPE.DEFAULT:case Resource.XHR_RESPONSE_TYPE.TEXT:default:return 'text/plain' } }, _createClass(Resource, [{ key: 'isDataUrl', get: function () { return this._hasFlag(Resource.STATUS_FLAGS.DATA_URL) } }, { key: 'isComplete', get: function () { return this._hasFlag(Resource.STATUS_FLAGS.COMPLETE) } }, { key: 'isLoading', get: function () { return this._hasFlag(Resource.STATUS_FLAGS.LOADING) } }]), Resource }()); function setExtMap (map, extname, val) { extname && extname.indexOf('.') === 0 && (extname = extname.substring(1)), extname && (map[extname] = val) } function reqType (xhr) { return xhr.toString().replace('object ', '') }Resource.STATUS_FLAGS = { NONE: 0, DATA_URL: 1, COMPLETE: 2, LOADING: 4 }, Resource.TYPE = { UNKNOWN: 0, JSON: 1, XML: 2, IMAGE: 3, AUDIO: 4, VIDEO: 5, TEXT: 6 }, Resource.LOAD_TYPE = { XHR: 1, IMAGE: 2, AUDIO: 3, VIDEO: 4 }, Resource.XHR_RESPONSE_TYPE = { DEFAULT: 'text', BUFFER: 'arraybuffer', BLOB: 'blob', DOCUMENT: 'document', JSON: 'json', TEXT: 'text' }, Resource._loadTypeMap = { gif: Resource.LOAD_TYPE.IMAGE, png: Resource.LOAD_TYPE.IMAGE, bmp: Resource.LOAD_TYPE.IMAGE, jpg: Resource.LOAD_TYPE.IMAGE, jpeg: Resource.LOAD_TYPE.IMAGE, tif: Resource.LOAD_TYPE.IMAGE, tiff: Resource.LOAD_TYPE.IMAGE, webp: Resource.LOAD_TYPE.IMAGE, tga: Resource.LOAD_TYPE.IMAGE, svg: Resource.LOAD_TYPE.IMAGE, 'svg+xml': Resource.LOAD_TYPE.IMAGE, mp3: Resource.LOAD_TYPE.AUDIO, ogg: Resource.LOAD_TYPE.AUDIO, wav: Resource.LOAD_TYPE.AUDIO, mp4: Resource.LOAD_TYPE.VIDEO, webm: Resource.LOAD_TYPE.VIDEO }, Resource._xhrTypeMap = { xhtml: Resource.XHR_RESPONSE_TYPE.DOCUMENT, html: Resource.XHR_RESPONSE_TYPE.DOCUMENT, htm: Resource.XHR_RESPONSE_TYPE.DOCUMENT, xml: Resource.XHR_RESPONSE_TYPE.DOCUMENT, tmx: Resource.XHR_RESPONSE_TYPE.DOCUMENT, svg: Resource.XHR_RESPONSE_TYPE.DOCUMENT, tsx: Resource.XHR_RESPONSE_TYPE.DOCUMENT, gif: Resource.XHR_RESPONSE_TYPE.BLOB, png: Resource.XHR_RESPONSE_TYPE.BLOB, bmp: Resource.XHR_RESPONSE_TYPE.BLOB, jpg: Resource.XHR_RESPONSE_TYPE.BLOB, jpeg: Resource.XHR_RESPONSE_TYPE.BLOB, tif: Resource.XHR_RESPONSE_TYPE.BLOB, tiff: Resource.XHR_RESPONSE_TYPE.BLOB, webp: Resource.XHR_RESPONSE_TYPE.BLOB, tga: Resource.XHR_RESPONSE_TYPE.BLOB, json: Resource.XHR_RESPONSE_TYPE.JSON, text: Resource.XHR_RESPONSE_TYPE.TEXT, txt: Resource.XHR_RESPONSE_TYPE.TEXT, ttf: Resource.XHR_RESPONSE_TYPE.BUFFER, otf: Resource.XHR_RESPONSE_TYPE.BUFFER }, Resource.EMPTY_GIF = 'data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw==', module.exports.default = Resource })); var Loader_1 = (unwrapExports(Resource_1), Resource_1.Resource, createCommonjsModule(function (module, exports) { exports.__esModule = !0, exports.Loader = void 0; var _typeof = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol' ? function (obj) { return typeof obj } : function (obj) { return obj && typeof Symbol === 'function' && obj.constructor === Symbol && obj !== Symbol.prototype ? 'symbol' : typeof obj }; var _createClass = function (Constructor, protoProps, staticProps) { return protoProps && defineProperties(Constructor.prototype, protoProps), staticProps && defineProperties(Constructor, staticProps), Constructor }; function defineProperties (target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, 'value' in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor) } } var _miniSignals2 = _interopRequireDefault(miniSignals); var _parseUri2 = _interopRequireDefault(parseUri); var async$1 = (function (obj) { { if (obj && obj.__esModule) return obj; var newObj = {}; if (obj != null) for (var key in obj)Object.prototype.hasOwnProperty.call(obj, key) && (newObj[key] = obj[key]); return newObj.default = obj, newObj } }(async)); function _interopRequireDefault (obj) { return obj && obj.__esModule ? obj : { default: obj } } var rgxExtractUrlHash = /(#[\w-]+)?$/; var Loader = exports.Loader = (function () { function Loader () { var _this = this; var baseUrl = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : ''; var concurrency = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 10; !(function (instance, Constructor) { if (!(instance instanceof Constructor)) throw new TypeError('Cannot call a class as a function') }(this, Loader)), this.baseUrl = baseUrl, this.progress = 0, this.loading = !1, this.defaultQueryString = '', this._beforeMiddleware = [], this._afterMiddleware = [], this._resourcesParsing = [], this._boundLoadResource = function (r, d) { return _this._loadResource(r, d) }, this._queue = async$1.queue(this._boundLoadResource, concurrency), this._queue.pause(), this.resources = {}, this.onProgress = new _miniSignals2.default(), this.onError = new _miniSignals2.default(), this.onLoad = new _miniSignals2.default(), this.onStart = new _miniSignals2.default(), this.onComplete = new _miniSignals2.default(); for (var i = 0; i < Loader._defaultBeforeMiddleware.length; ++i) this.pre(Loader._defaultBeforeMiddleware[i]); for (var _i = 0; _i < Loader._defaultAfterMiddleware.length; ++_i) this.use(Loader._defaultAfterMiddleware[_i]) } return Loader.prototype.add = function (name, url, options, cb) { if (Array.isArray(name)) { for (var i = 0; i < name.length; ++i) this.add(name[i]); return this } if ((void 0 === name ? 'undefined' : _typeof(name)) === 'object' && (cb = url || name.callback || name.onComplete, url = (options = name).url, name = name.name || name.key || name.url), typeof url !== 'string' && (cb = options, options = url, url = name), typeof url !== 'string') throw new Error('No url passed to add resource to loader.'); if (typeof options === 'function' && (cb = options, options = null), this.loading && (!options || !options.parentResource)) throw new Error('Cannot add resources while the loader is running.'); if (this.resources[name]) throw new Error('Resource named "' + name + '" already exists.'); if (url = this._prepareUrl(url), this.resources[name] = new Resource_1.Resource(name, url, options), typeof cb === 'function' && this.resources[name].onAfterMiddleware.once(cb), this.loading) { for (var parent = options.parentResource, incompleteChildren = [], _i2 = 0; _i2 < parent.children.length; ++_i2)parent.children[_i2].isComplete || incompleteChildren.push(parent.children[_i2]); var eachChunk = parent.progressChunk * (incompleteChildren.length + 1) / (incompleteChildren.length + 2); parent.children.push(this.resources[name]), parent.progressChunk = eachChunk; for (var _i3 = 0; _i3 < incompleteChildren.length; ++_i3)incompleteChildren[_i3].progressChunk = eachChunk; this.resources[name].progressChunk = eachChunk } return this._queue.push(this.resources[name]), this }, Loader.prototype.pre = function (fn) { return this._beforeMiddleware.push(fn), this }, Loader.prototype.use = function (fn) { return this._afterMiddleware.push(fn), this }, Loader.prototype.reset = function () { for (var k in this.progress = 0, this.loading = !1, this._queue.kill(), this._queue.pause(), this.resources) { var res = this.resources[k]; res._onLoadBinding && res._onLoadBinding.detach(), res.isLoading && res.abort() } return this.resources = {}, this }, Loader.prototype.load = function (cb) { if (typeof cb === 'function' && this.onComplete.once(cb), this.loading) return this; if (this._queue.idle()) this._onStart(), this._onComplete(); else { for (var chunk = 100 / this._queue._tasks.length, i = 0; i < this._queue._tasks.length; ++i) this._queue._tasks[i].data.progressChunk = chunk; this._onStart(), this._queue.resume() } return this }, Loader.prototype._prepareUrl = function (url) { var parsedUrl = (0, _parseUri2.default)(url, { strictMode: !0 }); var result = void 0; if (result = parsedUrl.protocol || !parsedUrl.path || url.indexOf('//') === 0 ? url : this.baseUrl.length && this.baseUrl.lastIndexOf('/') !== this.baseUrl.length - 1 && url.charAt(0) !== '/' ? this.baseUrl + '/' + url : this.baseUrl + url, this.defaultQueryString) { var hash = rgxExtractUrlHash.exec(result)[0]; (result = result.substr(0, result.length - hash.length)).indexOf('?') !== -1 ? result += '&' + this.defaultQueryString : result += '?' + this.defaultQueryString, result += hash } return result }, Loader.prototype._loadResource = function (resource, dequeue) { var _this2 = this; resource._dequeue = dequeue, async$1.eachSeries(this._beforeMiddleware, function (fn, next) { fn.call(_this2, resource, function () { next(resource.isComplete ? {} : null) }) }, function () { resource.isComplete ? _this2._onLoad(resource) : (resource._onLoadBinding = resource.onComplete.once(_this2._onLoad, _this2), resource.load()) }, !0) }, Loader.prototype._onStart = function () { this.progress = 0, this.loading = !0, this.onStart.dispatch(this) }, Loader.prototype._onComplete = function () { this.progress = 100, this.loading = !1, this.onComplete.dispatch(this, this.resources) }, Loader.prototype._onLoad = function (resource) { var _this3 = this; resource._onLoadBinding = null, this._resourcesParsing.push(resource), resource._dequeue(), async$1.eachSeries(this._afterMiddleware, function (fn, next) { fn.call(_this3, resource, next) }, function () { resource.onAfterMiddleware.dispatch(resource), _this3.progress = Math.min(100, _this3.progress + resource.progressChunk), _this3.onProgress.dispatch(_this3, resource), resource.error ? _this3.onError.dispatch(resource.error, _this3, resource) : _this3.onLoad.dispatch(_this3, resource), _this3._resourcesParsing.splice(_this3._resourcesParsing.indexOf(resource), 1), _this3._queue.idle() && _this3._resourcesParsing.length === 0 && _this3._onComplete() }, !0) }, _createClass(Loader, [{ key: 'concurrency', get: function () { return this._queue.concurrency }, set: function (concurrency) { this._queue.concurrency = concurrency } }]), Loader }()); Loader._defaultBeforeMiddleware = [], Loader._defaultAfterMiddleware = [], Loader.pre = function (fn) { return Loader._defaultBeforeMiddleware.push(fn), Loader }, Loader.use = function (fn) { return Loader._defaultAfterMiddleware.push(fn), Loader } })); var b64 = (unwrapExports(Loader_1), Loader_1.Loader, createCommonjsModule(function (module, exports) { exports.__esModule = !0, exports.encodeBinary = encodeBinary; var _keyStr = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/='; function encodeBinary (input) { for (var output = '', inx = 0; inx < input.length;) { for (var bytebuffer = [0, 0, 0], encodedCharIndexes = [0, 0, 0, 0], jnx = 0; jnx < bytebuffer.length; ++jnx)inx < input.length ? bytebuffer[jnx] = 255 & input.charCodeAt(inx++) : bytebuffer[jnx] = 0; switch (encodedCharIndexes[0] = bytebuffer[0] >> 2, encodedCharIndexes[1] = (3 & bytebuffer[0]) << 4 | bytebuffer[1] >> 4, encodedCharIndexes[2] = (15 & bytebuffer[1]) << 2 | bytebuffer[2] >> 6, encodedCharIndexes[3] = 63 & bytebuffer[2], inx - (input.length - 1)) { case 2:encodedCharIndexes[3] = 64, encodedCharIndexes[2] = 64; break; case 1:encodedCharIndexes[3] = 64 } for (var _jnx = 0; _jnx < encodedCharIndexes.length; ++_jnx)output += _keyStr.charAt(encodedCharIndexes[_jnx]) } return output }module.exports.default = encodeBinary })); var Loader$1 = (unwrapExports(b64), b64.encodeBinary, Loader_1.Loader); var Resource$2 = Resource_1.Resource; Loader$1.Resource = Resource$2, Loader$1.async = async, Loader$1.encodeBinary = b64, Loader$1.base64 = b64; var lib = Loader$1; var Loader_1$1 = Loader$1; var default_1$1 = Loader$1; var lib_1 = lib.Resource; function unwrapExports$1 (x) { return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x.default : x } function createCommonjsModule$1 (fn, module) { return fn(module = { exports: {} }, module.exports), module.exports }lib.Loader = Loader_1$1, lib.default = default_1$1; function parseUri$1 (str, opts) { opts = opts || {}; for (var o = { key: ['source', 'protocol', 'authority', 'userInfo', 'user', 'password', 'host', 'port', 'relative', 'path', 'directory', 'file', 'query', 'anchor'], q: { name: 'queryKey', parser: /(?:^|&)([^&=]*)=?([^&]*)/g }, parser: { strict: /^(?:([^:\/?#]+):)?(?:\/\/((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\/?#]*)(?::(\d*))?))?((((?:[^?#\/]*\/)*)([^?#]*))(?:\?([^#]*))?(?:#(.*))?)/, loose: /^(?:(?![^:@]+:[^:@\/]*@)([^:\/?#.]+):)?(?:\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/ } }, m = o.parser[opts.strictMode ? 'strict' : 'loose'].exec(str), uri = {}, i = 14; i--;)uri[o.key[i]] = m[i] || ''; return uri[o.q.name] = {}, uri[o.key[12]].replace(o.q.parser, function ($0, $1, $2) { $1 && (uri[o.q.name][$1] = $2) }), uri } var miniSignals$2 = createCommonjsModule$1(function (module, exports) { Object.defineProperty(exports, '__esModule', { value: !0 }); var _createClass = function (Constructor, protoProps, staticProps) { return protoProps && defineProperties(Constructor.prototype, protoProps), staticProps && defineProperties(Constructor, staticProps), Constructor }; function defineProperties (target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, 'value' in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor) } } function _classCallCheck (instance, Constructor) { if (!(instance instanceof Constructor)) throw new TypeError('Cannot call a class as a function') } var MiniSignalBinding = (function () { function MiniSignalBinding (fn, once, thisArg) { void 0 === once && (once = !1), _classCallCheck(this, MiniSignalBinding), this._fn = fn, this._once = once, this._thisArg = thisArg, this._next = this._prev = this._owner = null } return _createClass(MiniSignalBinding, [{ key: 'detach', value: function () { return this._owner !== null && (this._owner.detach(this), !0) } }]), MiniSignalBinding }()); function _addMiniSignalBinding (self, node) { return self._head ? (self._tail._next = node)._prev = self._tail : self._head = node, (self._tail = node)._owner = self, node } var MiniSignal = (function () { function MiniSignal () { _classCallCheck(this, MiniSignal), this._head = this._tail = void 0 } return _createClass(MiniSignal, [{ key: 'handlers', value: function (argument_0) { var exists = !(arguments.length <= 0 || void 0 === argument_0) && argument_0; var node = this._head; if (exists) return !!node; for (var ee = []; node;)ee.push(node), node = node._next; return ee } }, { key: 'has', value: function (node) { if (!(node instanceof MiniSignalBinding)) throw new Error('MiniSignal#has(): First arg must be a MiniSignalBinding object.'); return node._owner === this } }, { key: 'dispatch', value: function () { var arguments$1 = arguments; var node = this._head; if (!node) return !1; for (;node;)node._once && this.detach(node), node._fn.apply(node._thisArg, arguments$1), node = node._next; return !0 } }, { key: 'add', value: function (fn, argument_1) { var thisArg = arguments.length <= 1 || void 0 === argument_1 ? null : argument_1; if (typeof fn !== 'function') throw new Error('MiniSignal#add(): First arg must be a Function.'); return _addMiniSignalBinding(this, new MiniSignalBinding(fn, !1, thisArg)) } }, { key: 'once', value: function (fn, argument_1) { var thisArg = arguments.length <= 1 || void 0 === argument_1 ? null : argument_1; if (typeof fn !== 'function') throw new Error('MiniSignal#once(): First arg must be a Function.'); return _addMiniSignalBinding(this, new MiniSignalBinding(fn, !0, thisArg)) } }, { key: 'detach', value: function (node) { if (!(node instanceof MiniSignalBinding)) throw new Error('MiniSignal#detach(): First arg must be a MiniSignalBinding object.'); return node._owner !== this || (node._prev && (node._prev._next = node._next), node._next && (node._next._prev = node._prev), node === this._head ? (this._head = node._next, node._next === null && (this._tail = null)) : node === this._tail && (this._tail = node._prev, this._tail._next = null), node._owner = null), this } }, { key: 'detachAll', value: function () { var node = this._head; if (!node) return this; for (this._head = this._tail = null; node;)node._owner = null, node = node._next; return this } }]), MiniSignal }()); MiniSignal.MiniSignalBinding = MiniSignalBinding, exports.default = MiniSignal, module.exports = exports.default }); unwrapExports$1(miniSignals$2); var Resource_1$1 = createCommonjsModule$1(function (module, exports) { exports.__esModule = !0, exports.Resource = void 0; var _createClass = function (Constructor, protoProps, staticProps) { return protoProps && defineProperties(Constructor.prototype, protoProps), staticProps && defineProperties(Constructor, staticProps), Constructor }; function defineProperties (target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, 'value' in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor) } } var _parseUri2 = _interopRequireDefault(parseUri$1); var _miniSignals2 = _interopRequireDefault(miniSignals$2); function _interopRequireDefault (obj) { return obj && obj.__esModule ? obj : { default: obj } } var useXdr = !(!window.XDomainRequest || 'withCredentials' in new XMLHttpRequest()); var tempAnchor = null; function _noop () {} var Resource = exports.Resource = (function () { function Resource (name, url, options) { if ((function (instance, Constructor) { if (!(instance instanceof Constructor)) throw new TypeError('Cannot call a class as a function') }(this, Resource)), typeof name !== 'string' || typeof url !== 'string') throw new Error('Both name and url are required for constructing a resource.'); options = options || {}, this._flags = 0, this._setFlag(Resource.STATUS_FLAGS.DATA_URL, url.indexOf('data:') === 0), this.name = name, this.url = url, this.extension = this._getExtension(), this.data = null, this.crossOrigin = !0 === options.crossOrigin ? 'anonymous' : options.crossOrigin, this.timeout = options.timeout || 0, this.loadType = options.loadType || this._determineLoadType(), this.xhrType = options.xhrType, this.metadata = options.metadata || {}, this.error = null, this.xhr = null, this.children = [], this.type = Resource.TYPE.UNKNOWN, this.progressChunk = 0, this._dequeue = _noop, this._onLoadBinding = null, this._elementTimer = 0, this._boundComplete = this.complete.bind(this), this._boundOnError = this._onError.bind(this), this._boundOnProgress = this._onProgress.bind(this), this._boundOnTimeout = this._onTimeout.bind(this), this._boundXhrOnError = this._xhrOnError.bind(this), this._boundXhrOnTimeout = this._xhrOnTimeout.bind(this), this._boundXhrOnAbort = this._xhrOnAbort.bind(this), this._boundXhrOnLoad = this._xhrOnLoad.bind(this), this.onStart = new _miniSignals2.default(), this.onProgress = new _miniSignals2.default(), this.onComplete = new _miniSignals2.default(), this.onAfterMiddleware = new _miniSignals2.default() } return Resource.setExtensionLoadType = function (extname, loadType) { setExtMap(Resource._loadTypeMap, extname, loadType) }, Resource.setExtensionXhrType = function (extname, xhrType) { setExtMap(Resource._xhrTypeMap, extname, xhrType) }, Resource.prototype.complete = function () { this._clearEvents(), this._finish() }, Resource.prototype.abort = function (message) { if (!this.error) { if (this.error = new Error(message), this._clearEvents(), this.xhr) this.xhr.abort(); else if (this.xdr) this.xdr.abort(); else if (this.data) if (this.data.src) this.data.src = Resource.EMPTY_GIF; else for (;this.data.firstChild;) this.data.removeChild(this.data.firstChild); this._finish() } }, Resource.prototype.load = function (cb) { var _this = this; if (!this.isLoading) if (this.isComplete)cb && setTimeout(function () { return cb(_this) }, 1); else switch (cb && this.onComplete.once(cb), this._setFlag(Resource.STATUS_FLAGS.LOADING, !0), this.onStart.dispatch(this), !1 !== this.crossOrigin && typeof this.crossOrigin === 'string' || (this.crossOrigin = this._determineCrossOrigin(this.url)), this.loadType) { case Resource.LOAD_TYPE.IMAGE:this.type = Resource.TYPE.IMAGE, this._loadElement('image'); break; case Resource.LOAD_TYPE.AUDIO:this.type = Resource.TYPE.AUDIO, this._loadSourceElement('audio'); break; case Resource.LOAD_TYPE.VIDEO:this.type = Resource.TYPE.VIDEO, this._loadSourceElement('video'); break; case Resource.LOAD_TYPE.XHR:default:useXdr && this.crossOrigin ? this._loadXdr() : this._loadXhr() } }, Resource.prototype._hasFlag = function (flag) { return (this._flags & flag) != 0 }, Resource.prototype._setFlag = function (flag, value) { this._flags = value ? this._flags | flag : this._flags & ~flag }, Resource.prototype._clearEvents = function () { clearTimeout(this._elementTimer), this.data && this.data.removeEventListener && (this.data.removeEventListener('error', this._boundOnError, !1), this.data.removeEventListener('load', this._boundComplete, !1), this.data.removeEventListener('progress', this._boundOnProgress, !1), this.data.removeEventListener('canplaythrough', this._boundComplete, !1)), this.xhr && (this.xhr.removeEventListener ? (this.xhr.removeEventListener('error', this._boundXhrOnError, !1), this.xhr.removeEventListener('timeout', this._boundXhrOnTimeout, !1), this.xhr.removeEventListener('abort', this._boundXhrOnAbort, !1), this.xhr.removeEventListener('progress', this._boundOnProgress, !1), this.xhr.removeEventListener('load', this._boundXhrOnLoad, !1)) : (this.xhr.onerror = null, this.xhr.ontimeout = null, this.xhr.onprogress = null, this.xhr.onload = null)) }, Resource.prototype._finish = function () { if (this.isComplete) throw new Error('Complete called again for an already completed resource.'); this._setFlag(Resource.STATUS_FLAGS.COMPLETE, !0), this._setFlag(Resource.STATUS_FLAGS.LOADING, !1), this.onComplete.dispatch(this) }, Resource.prototype._loadElement = function (type) { this.metadata.loadElement ? this.data = this.metadata.loadElement : type === 'image' && void 0 !== window.Image ? this.data = new Image() : this.data = document.createElement(type), this.crossOrigin && (this.data.crossOrigin = this.crossOrigin), this.metadata.skipSource || (this.data.src = this.url), this.data.addEventListener('error', this._boundOnError, !1), this.data.addEventListener('load', this._boundComplete, !1), this.data.addEventListener('progress', this._boundOnProgress, !1), this.timeout && (this._elementTimer = setTimeout(this._boundOnTimeout, this.timeout)) }, Resource.prototype._loadSourceElement = function (type) { if (this.metadata.loadElement ? this.data = this.metadata.loadElement : type === 'audio' && void 0 !== window.Audio ? this.data = new Audio() : this.data = document.createElement(type), this.data !== null) { if (this.crossOrigin && (this.data.crossOrigin = this.crossOrigin), !this.metadata.skipSource) if (navigator.isCocoonJS) this.data.src = Array.isArray(this.url) ? this.url[0] : this.url; else if (Array.isArray(this.url)) for (var mimeTypes = this.metadata.mimeType, i = 0; i < this.url.length; ++i) this.data.appendChild(this._createSource(type, this.url[i], Array.isArray(mimeTypes) ? mimeTypes[i] : mimeTypes)); else { var _mimeTypes = this.metadata.mimeType; this.data.appendChild(this._createSource(type, this.url, Array.isArray(_mimeTypes) ? _mimeTypes[0] : _mimeTypes)) } this.data.addEventListener('error', this._boundOnError, !1), this.data.addEventListener('load', this._boundComplete, !1), this.data.addEventListener('progress', this._boundOnProgress, !1), this.data.addEventListener('canplaythrough', this._boundComplete, !1), this.data.load(), this.timeout && (this._elementTimer = setTimeout(this._boundOnTimeout, this.timeout)) } else this.abort('Unsupported element: ' + type) }, Resource.prototype._loadXhr = function () { typeof this.xhrType !== 'string' && (this.xhrType = this._determineXhrType()); var xhr = this.xhr = new XMLHttpRequest(); xhr.open('GET', this.url, !0), xhr.timeout = this.timeout, this.xhrType === Resource.XHR_RESPONSE_TYPE.JSON || this.xhrType === Resource.XHR_RESPONSE_TYPE.DOCUMENT ? xhr.responseType = Resource.XHR_RESPONSE_TYPE.TEXT : xhr.responseType = this.xhrType, xhr.addEventListener('error', this._boundXhrOnError, !1), xhr.addEventListener('timeout', this._boundXhrOnTimeout, !1), xhr.addEventListener('abort', this._boundXhrOnAbort, !1), xhr.addEventListener('progress', this._boundOnProgress, !1), xhr.addEventListener('load', this._boundXhrOnLoad, !1), xhr.send() }, Resource.prototype._loadXdr = function () { typeof this.xhrType !== 'string' && (this.xhrType = this._determineXhrType()); var xdr = this.xhr = new XDomainRequest(); xdr.timeout = this.timeout || 5e3, xdr.onerror = this._boundXhrOnError, xdr.ontimeout = this._boundXhrOnTimeout, xdr.onprogress = this._boundOnProgress, xdr.onload = this._boundXhrOnLoad, xdr.open('GET', this.url, !0), setTimeout(function () { return xdr.send() }, 1) }, Resource.prototype._createSource = function (type, url, mime) { mime = mime || type + '/' + this._getExtension(url); var source = document.createElement('source'); return source.src = url, source.type = mime, source }, Resource.prototype._onError = function (event) { this.abort('Failed to load element using: ' + event.target.nodeName) }, Resource.prototype._onProgress = function (event) { event && event.lengthComputable && this.onProgress.dispatch(this, event.loaded / event.total) }, Resource.prototype._onTimeout = function () { this.abort('Load timed out.') }, Resource.prototype._xhrOnError = function () { var xhr = this.xhr; this.abort(reqType(xhr) + ' Request failed. Status: ' + xhr.status + ', text: "' + xhr.statusText + '"') }, Resource.prototype._xhrOnTimeout = function () { var xhr = this.xhr; this.abort(reqType(xhr) + ' Request timed out.') }, Resource.prototype._xhrOnAbort = function () { var xhr = this.xhr; this.abort(reqType(xhr) + ' Request was aborted by the user.') }, Resource.prototype._xhrOnLoad = function () { var xhr = this.xhr; var text = ''; var status = void 0 === xhr.status ? 200 : xhr.status; if (xhr.responseType !== '' && xhr.responseType !== 'text' && void 0 !== xhr.responseType || (text = xhr.responseText), status === 0 && (text.length > 0 || xhr.responseType === Resource.XHR_RESPONSE_TYPE.BUFFER) ? status = 200 : status === 1223 && (status = 204), (status / 100 | 0) == 2) { if (this.xhrType === Resource.XHR_RESPONSE_TYPE.TEXT) this.data = text, this.type = Resource.TYPE.TEXT; else if (this.xhrType === Resource.XHR_RESPONSE_TYPE.JSON) try { this.data = JSON.parse(text), this.type = Resource.TYPE.JSON } catch (e) { return void this.abort('Error trying to parse loaded json: ' + e) } else if (this.xhrType === Resource.XHR_RESPONSE_TYPE.DOCUMENT) try { if (window.DOMParser) { var domparser = new DOMParser(); this.data = domparser.parseFromString(text, 'text/xml') } else { var div = document.createElement('div'); div.innerHTML = text, this.data = div } this.type = Resource.TYPE.XML } catch (e) { return void this.abort('Error trying to parse loaded xml: ' + e) } else this.data = xhr.response || text; this.complete() } else this.abort('[' + xhr.status + '] ' + xhr.statusText + ': ' + xhr.responseURL) }, Resource.prototype._determineCrossOrigin = function (url, loc) { if (url.indexOf('data:') === 0) return ''; if (window.origin !== window.location.origin) return 'anonymous'; loc = loc || window.location, (tempAnchor = tempAnchor || document.createElement('a')).href = url; var samePort = !(url = (0, _parseUri2.default)(tempAnchor.href, { strictMode: !0 })).port && loc.port === '' || url.port === loc.port; var protocol = url.protocol ? url.protocol + ':' : ''; return url.host === loc.hostname && samePort && protocol === loc.protocol ? '' : 'anonymous' }, Resource.prototype._determineXhrType = function () { return Resource._xhrTypeMap[this.extension] || Resource.XHR_RESPONSE_TYPE.TEXT }, Resource.prototype._determineLoadType = function () { return Resource._loadTypeMap[this.extension] || Resource.LOAD_TYPE.XHR }, Resource.prototype._getExtension = function () { var url = this.url; var ext = ''; if (this.isDataUrl) { var slashIndex = url.indexOf('/'); ext = url.substring(slashIndex + 1, url.indexOf(';', slashIndex)) } else { var queryStart = url.indexOf('?'); var hashStart = url.indexOf('#'); var index = Math.min(queryStart > -1 ? queryStart : url.length, hashStart > -1 ? hashStart : url.length); ext = (url = url.substring(0, index)).substring(url.lastIndexOf('.') + 1) } return ext.toLowerCase() }, Resource.prototype._getMimeFromXhrType = function (type) { switch (type) { case Resource.XHR_RESPONSE_TYPE.BUFFER:return 'application/octet-binary'; case Resource.XHR_RESPONSE_TYPE.BLOB:return 'application/blob'; case Resource.XHR_RESPONSE_TYPE.DOCUMENT:return 'application/xml'; case Resource.XHR_RESPONSE_TYPE.JSON:return 'application/json'; case Resource.XHR_RESPONSE_TYPE.DEFAULT:case Resource.XHR_RESPONSE_TYPE.TEXT:default:return 'text/plain' } }, _createClass(Resource, [{ key: 'isDataUrl', get: function () { return this._hasFlag(Resource.STATUS_FLAGS.DATA_URL) } }, { key: 'isComplete', get: function () { return this._hasFlag(Resource.STATUS_FLAGS.COMPLETE) } }, { key: 'isLoading', get: function () { return this._hasFlag(Resource.STATUS_FLAGS.LOADING) } }]), Resource }()); function setExtMap (map, extname, val) { extname && extname.indexOf('.') === 0 && (extname = extname.substring(1)), extname && (map[extname] = val) } function reqType (xhr) { return xhr.toString().replace('object ', '') }Resource.STATUS_FLAGS = { NONE: 0, DATA_URL: 1, COMPLETE: 2, LOADING: 4 }, Resource.TYPE = { UNKNOWN: 0, JSON: 1, XML: 2, IMAGE: 3, AUDIO: 4, VIDEO: 5, TEXT: 6 }, Resource.LOAD_TYPE = { XHR: 1, IMAGE: 2, AUDIO: 3, VIDEO: 4 }, Resource.XHR_RESPONSE_TYPE = { DEFAULT: 'text', BUFFER: 'arraybuffer', BLOB: 'blob', DOCUMENT: 'document', JSON: 'json', TEXT: 'text' }, Resource._loadTypeMap = { gif: Resource.LOAD_TYPE.IMAGE, png: Resource.LOAD_TYPE.IMAGE, bmp: Resource.LOAD_TYPE.IMAGE, jpg: Resource.LOAD_TYPE.IMAGE, jpeg: Resource.LOAD_TYPE.IMAGE, tif: Resource.LOAD_TYPE.IMAGE, tiff: Resource.LOAD_TYPE.IMAGE, webp: Resource.LOAD_TYPE.IMAGE, tga: Resource.LOAD_TYPE.IMAGE, svg: Resource.LOAD_TYPE.IMAGE, 'svg+xml': Resource.LOAD_TYPE.IMAGE, mp3: Resource.LOAD_TYPE.AUDIO, ogg: Resource.LOAD_TYPE.AUDIO, wav: Resource.LOAD_TYPE.AUDIO, mp4: Resource.LOAD_TYPE.VIDEO, webm: Resource.LOAD_TYPE.VIDEO }, Resource._xhrTypeMap = { xhtml: Resource.XHR_RESPONSE_TYPE.DOCUMENT, html: Resource.XHR_RESPONSE_TYPE.DOCUMENT, htm: Resource.XHR_RESPONSE_TYPE.DOCUMENT, xml: Resource.XHR_RESPONSE_TYPE.DOCUMENT, tmx: Resource.XHR_RESPONSE_TYPE.DOCUMENT, svg: Resource.XHR_RESPONSE_TYPE.DOCUMENT, tsx: Resource.XHR_RESPONSE_TYPE.DOCUMENT, gif: Resource.XHR_RESPONSE_TYPE.BLOB, png: Resource.XHR_RESPONSE_TYPE.BLOB, bmp: Resource.XHR_RESPONSE_TYPE.BLOB, jpg: Resource.XHR_RESPONSE_TYPE.BLOB, jpeg: Resource.XHR_RESPONSE_TYPE.BLOB, tif: Resource.XHR_RESPONSE_TYPE.BLOB, tiff: Resource.XHR_RESPONSE_TYPE.BLOB, webp: Resource.XHR_RESPONSE_TYPE.BLOB, tga: Resource.XHR_RESPONSE_TYPE.BLOB, json: Resource.XHR_RESPONSE_TYPE.JSON, text: Resource.XHR_RESPONSE_TYPE.TEXT, txt: Resource.XHR_RESPONSE_TYPE.TEXT, ttf: Resource.XHR_RESPONSE_TYPE.BUFFER, otf: Resource.XHR_RESPONSE_TYPE.BUFFER }, Resource.EMPTY_GIF = 'data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw==', module.exports.default = Resource }); unwrapExports$1(Resource_1$1); Resource_1$1.Resource; var b64$2 = createCommonjsModule$1(function (module, exports) { exports.__esModule = !0, exports.encodeBinary = encodeBinary; var _keyStr = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/='; function encodeBinary (input) { for (var output = '', inx = 0; inx < input.length;) { for (var bytebuffer = [0, 0, 0], encodedCharIndexes = [0, 0, 0, 0], jnx = 0; jnx < bytebuffer.length; ++jnx)inx < input.length ? bytebuffer[jnx] = 255 & input.charCodeAt(inx++) : bytebuffer[jnx] = 0; switch (encodedCharIndexes[0] = bytebuffer[0] >> 2, encodedCharIndexes[1] = (3 & bytebuffer[0]) << 4 | bytebuffer[1] >> 4, encodedCharIndexes[2] = (15 & bytebuffer[1]) << 2 | bytebuffer[2] >> 6, encodedCharIndexes[3] = 63 & bytebuffer[2], inx - (input.length - 1)) { case 2:encodedCharIndexes[3] = 64, encodedCharIndexes[2] = 64; break; case 1:encodedCharIndexes[3] = 64 } for (var _jnx = 0; _jnx < encodedCharIndexes.length; ++_jnx)output += _keyStr.charAt(encodedCharIndexes[_jnx]) } return output }module.exports.default = encodeBinary }); unwrapExports$1(b64$2); b64$2.encodeBinary; var blob = createCommonjsModule$1(function (module, exports) { exports.__esModule = !0, exports.blobMiddlewareFactory = function () { return function (resource, next) { if (resource.data) { if (resource.xhr && resource.xhrType === Resource_1$1.Resource.XHR_RESPONSE_TYPE.BLOB) if (window.Blob && typeof resource.data !== 'string') { if (resource.data.type.indexOf('image') === 0) { var src = Url.createObjectURL(resource.data); return resource.blob = resource.data, resource.data = new Image(), resource.data.src = src, resource.type = Resource_1$1.Resource.TYPE.IMAGE, void (resource.data.onload = function () { Url.revokeObjectURL(src), resource.data.onload = null, next() }) } } else { var type = resource.xhr.getResponseHeader('content-type'); if (type && type.indexOf('image') === 0) return resource.data = new Image(), resource.data.src = 'data:' + type + ';base64,' + (0, b64$2.encodeBinary)(resource.xhr.responseText), resource.type = Resource_1$1.Resource.TYPE.IMAGE, void (resource.data.onload = function () { resource.data.onload = null, next() }) }next() } else next() } }; var Url = window.URL || window.webkitURL }); unwrapExports$1(blob); var blob_1 = blob.blobMiddlewareFactory; var TextureLoader = function () {}; TextureLoader.use = function (resource, next) { resource.data && resource.type === lib_1.TYPE.IMAGE && (resource.texture = Texture.fromLoader(resource.data, resource.url, resource.name)), next() }; var Loader$2 = (function (ResourceLoader) { function Loader (baseUrl, concurrency) { var this$1 = this; ResourceLoader.call(this, baseUrl, concurrency), eventemitter3.call(this); for (var i = 0; i < Loader._plugins.length; ++i) { var plugin = Loader._plugins[i]; var pre = plugin.pre; var use = plugin.use; pre && this.pre(pre), use && this.use(use) } this.onStart.add(function (l) { return this$1.emit('start', l) }), this.onProgress.add(function (l, r) { return this$1.emit('progress', l, r) }), this.onError.add(function (e, l, r) { return this$1.emit('error', e, l, r) }), this.onLoad.add(function (l, r) { return this$1.emit('load', l, r) }), this.onComplete.add(function (l, r) { return this$1.emit('complete', l, r) }), this._protected = !1 }ResourceLoader && (Loader.__proto__ = ResourceLoader); var staticAccessors = { shared: { configurable: !0 } }; return ((Loader.prototype = Object.create(ResourceLoader && ResourceLoader.prototype)).constructor = Loader).prototype.destroy = function () { this._protected || (this.removeAllListeners(), this.reset()) }, staticAccessors.shared.get = function () { var shared = Loader._shared; return shared || ((shared = new Loader())._protected = !0, Loader._shared = shared), shared }, Object.defineProperties(Loader, staticAccessors), Loader }(lib)); Object.assign(Loader$2.prototype, eventemitter3.prototype), Loader$2._plugins = [], Loader$2.registerPlugin = function (plugin) { return Loader$2._plugins.push(plugin), plugin.add && plugin.add(), Loader$2 }, Loader$2.registerPlugin({ use: blob_1() }), Loader$2.registerPlugin(TextureLoader); var AppLoaderPlugin = function () {}; AppLoaderPlugin.init = function (options) { options = Object.assign({ sharedLoader: !1 }, options), this.loader = options.sharedLoader ? Loader$2.shared : new Loader$2() }, AppLoaderPlugin.destroy = function () { this.loader && (this.loader.destroy(), this.loader = null) }; var LoaderResource = lib_1; var ParticleContainer = (function (Container) { function ParticleContainer (maxSize, properties, batchSize, autoResize) { void 0 === maxSize && (maxSize = 1500), void 0 === batchSize && (batchSize = 16384), void 0 === autoResize && (autoResize = !1), Container.call(this); batchSize > 16384 && (batchSize = 16384), this._properties = [!1, !0, !1, !1, !1], this._maxSize = maxSize, this._batchSize = batchSize, this._buffers = null, this._bufferUpdateIDs = [], this._updateID = 0, this.interactiveChildren = !1, this.blendMode = BLEND_MODES.NORMAL, this.autoResize = autoResize, this.roundPixels = !0, this.baseTexture = null, this.setProperties(properties), this._tint = 0, this.tintRgb = new Float32Array(4), this.tint = 16777215 }Container && (ParticleContainer.__proto__ = Container); var prototypeAccessors = { tint: { configurable: !0 } }; return ((ParticleContainer.prototype = Object.create(Container && Container.prototype)).constructor = ParticleContainer).prototype.setProperties = function (properties) { properties && (this._properties[0] = 'vertices' in properties || 'scale' in properties ? !!properties.vertices || !!properties.scale : this._properties[0], this._properties[1] = 'position' in properties ? !!properties.position : this._properties[1], this._properties[2] = 'rotation' in properties ? !!properties.rotation : this._properties[2], this._properties[3] = 'uvs' in properties ? !!properties.uvs : this._properties[3], this._properties[4] = 'tint' in properties || 'alpha' in properties ? !!properties.tint || !!properties.alpha : this._properties[4]) }, ParticleContainer.prototype.updateTransform = function () { this.displayObjectUpdateTransform() }, prototypeAccessors.tint.get = function () { return this._tint }, prototypeAccessors.tint.set = function (value) { hex2rgb(this._tint = value, this.tintRgb) }, ParticleContainer.prototype.render = function (renderer) { var this$1 = this; this.visible && !(this.worldAlpha <= 0) && this.children.length && this.renderable && (this.baseTexture || (this.baseTexture = this.children[0]._texture.baseTexture, this.baseTexture.valid || this.baseTexture.once('update', function () { return this$1.onChildrenChange(0) })), renderer.batch.setObjectRenderer(renderer.plugins.particle), renderer.plugins.particle.render(this)) }, ParticleContainer.prototype.onChildrenChange = function (smallestChildIndex) { for (var bufferIndex = Math.floor(smallestChildIndex / this._batchSize); this._bufferUpdateIDs.length < bufferIndex;) this._bufferUpdateIDs.push(0); this._bufferUpdateIDs[bufferIndex] = ++this._updateID }, ParticleContainer.prototype.dispose = function () { if (this._buffers) { for (var i = 0; i < this._buffers.length; ++i) this._buffers[i].destroy(); this._buffers = null } }, ParticleContainer.prototype.destroy = function (options) { Container.prototype.destroy.call(this, options), this.dispose(), this._properties = null, this._buffers = null, this._bufferUpdateIDs = null }, Object.defineProperties(ParticleContainer.prototype, prototypeAccessors), ParticleContainer }(Container)); var ParticleBuffer = function (properties, dynamicPropertyFlags, size) { this.geometry = new Geometry(), this.indexBuffer = null, this.size = size, this.dynamicProperties = [], this.staticProperties = []; for (var i = 0; i < properties.length; ++i) { var property = properties[i]; property = { attributeName: property.attributeName, size: property.size, uploadFunction: property.uploadFunction, type: property.type || TYPES.FLOAT, offset: property.offset }, dynamicPropertyFlags[i] ? this.dynamicProperties.push(property) : this.staticProperties.push(property) } this.staticStride = 0, this.staticBuffer = null, this.staticData = null, this.staticDataUint32 = null, this.dynamicStride = 0, this.dynamicBuffer = null, this.dynamicData = null, this.dynamicDataUint32 = null, this._updateID = 0, this.initBuffers() }; ParticleBuffer.prototype.initBuffers = function () { var geometry = this.geometry; var dynamicOffset = 0; this.indexBuffer = new Buffer(createIndicesForQuads(this.size), !0, !0), geometry.addIndex(this.indexBuffer); for (var i = this.dynamicStride = 0; i < this.dynamicProperties.length; ++i) { var property = this.dynamicProperties[i]; property.offset = dynamicOffset, dynamicOffset += property.size, this.dynamicStride += property.size } var dynBuffer = new ArrayBuffer(this.size * this.dynamicStride * 4 * 4); this.dynamicData = new Float32Array(dynBuffer), this.dynamicDataUint32 = new Uint32Array(dynBuffer), this.dynamicBuffer = new Buffer(this.dynamicData, !1, !1); for (var staticOffset = 0, i$1 = this.staticStride = 0; i$1 < this.staticProperties.length; ++i$1) { var property$1 = this.staticProperties[i$1]; property$1.offset = staticOffset, staticOffset += property$1.size, this.staticStride += property$1.size } var statBuffer = new ArrayBuffer(this.size * this.staticStride * 4 * 4); this.staticData = new Float32Array(statBuffer), this.staticDataUint32 = new Uint32Array(statBuffer), this.staticBuffer = new Buffer(this.staticData, !0, !1); for (var i$2 = 0; i$2 < this.dynamicProperties.length; ++i$2) { var property$2 = this.dynamicProperties[i$2]; geometry.addAttribute(property$2.attributeName, this.dynamicBuffer, 0, property$2.type === TYPES.UNSIGNED_BYTE, property$2.type, 4 * this.dynamicStride, 4 * property$2.offset) } for (var i$3 = 0; i$3 < this.staticProperties.length; ++i$3) { var property$3 = this.staticProperties[i$3]; geometry.addAttribute(property$3.attributeName, this.staticBuffer, 0, property$3.type === TYPES.UNSIGNED_BYTE, property$3.type, 4 * this.staticStride, 4 * property$3.offset) } }, ParticleBuffer.prototype.uploadDynamic = function (children, startIndex, amount) { for (var i = 0; i < this.dynamicProperties.length; i++) { var property = this.dynamicProperties[i]; property.uploadFunction(children, startIndex, amount, property.type === TYPES.UNSIGNED_BYTE ? this.dynamicDataUint32 : this.dynamicData, this.dynamicStride, property.offset) } this.dynamicBuffer._updateID++ }, ParticleBuffer.prototype.uploadStatic = function (children, startIndex, amount) { for (var i = 0; i < this.staticProperties.length; i++) { var property = this.staticProperties[i]; property.uploadFunction(children, startIndex, amount, property.type === TYPES.UNSIGNED_BYTE ? this.staticDataUint32 : this.staticData, this.staticStride, property.offset) } this.staticBuffer._updateID++ }, ParticleBuffer.prototype.destroy = function () { this.indexBuffer = null, this.dynamicProperties = null, this.dynamicBuffer = null, this.dynamicData = null, this.dynamicDataUint32 = null, this.staticProperties = null, this.staticBuffer = null, this.staticData = null, this.staticDataUint32 = null, this.geometry.destroy() }; var ParticleRenderer = (function (ObjectRenderer) { function ParticleRenderer (renderer) { ObjectRenderer.call(this, renderer), this.shader = null, this.properties = null, this.tempMatrix = new Matrix(), this.properties = [{ attributeName: 'aVertexPosition', size: 2, uploadFunction: this.uploadVertices, offset: 0 }, { attributeName: 'aPositionCoord', size: 2, uploadFunction: this.uploadPosition, offset: 0 }, { attributeName: 'aRotation', size: 1, uploadFunction: this.uploadRotation, offset: 0 }, { attributeName: 'aTextureCoord', size: 2, uploadFunction: this.uploadUvs, offset: 0 }, { attributeName: 'aColor', size: 1, type: TYPES.UNSIGNED_BYTE, uploadFunction: this.uploadTint, offset: 0 }], this.shader = Shader.from('attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\nattribute vec4 aColor;\n\nattribute vec2 aPositionCoord;\nattribute float aRotation;\n\nuniform mat3 translationMatrix;\nuniform vec4 uColor;\n\nvarying vec2 vTextureCoord;\nvarying vec4 vColor;\n\nvoid main(void){\n    float x = (aVertexPosition.x) * cos(aRotation) - (aVertexPosition.y) * sin(aRotation);\n    float y = (aVertexPosition.x) * sin(aRotation) + (aVertexPosition.y) * cos(aRotation);\n\n    vec2 v = vec2(x, y);\n    v = v + aPositionCoord;\n\n    gl_Position = vec4((translationMatrix * vec3(v, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = aTextureCoord;\n    vColor = aColor * uColor;\n}\n', 'varying vec2 vTextureCoord;\nvarying vec4 vColor;\n\nuniform sampler2D uSampler;\n\nvoid main(void){\n    vec4 color = texture2D(uSampler, vTextureCoord) * vColor;\n    gl_FragColor = color;\n}', {}) } return ObjectRenderer && (ParticleRenderer.__proto__ = ObjectRenderer), ((ParticleRenderer.prototype = Object.create(ObjectRenderer && ObjectRenderer.prototype)).constructor = ParticleRenderer).prototype.render = function (container) { var children = container.children; var maxSize = container._maxSize; var batchSize = container._batchSize; var renderer = this.renderer; var totalChildren = children.length; if (totalChildren !== 0) { maxSize < totalChildren && !container.autoResize && (totalChildren = maxSize); var buffers = container._buffers; buffers = buffers || (container._buffers = this.generateBuffers(container)); var baseTexture = children[0]._texture.baseTexture; this.renderer.state.setBlendMode(correctBlendMode(container.blendMode, baseTexture.premultiplyAlpha)); var gl = renderer.gl; var m = container.worldTransform.copyTo(this.tempMatrix); m.prepend(renderer.globalUniforms.uniforms.projectionMatrix), this.shader.uniforms.translationMatrix = m.toArray(!0), this.shader.uniforms.uColor = premultiplyRgba(container.tintRgb, container.worldAlpha, this.shader.uniforms.uColor, baseTexture.premultiplyAlpha), this.shader.uniforms.uSampler = baseTexture, this.renderer.shader.bind(this.shader); for (var updateStatic = !1, i = 0, j = 0; i < totalChildren; i += batchSize, j += 1) { var amount = totalChildren - i; batchSize < amount && (amount = batchSize), j >= buffers.length && buffers.push(this._generateOneMoreBuffer(container)); var buffer = buffers[j]; buffer.uploadDynamic(children, i, amount); var bid = container._bufferUpdateIDs[j] || 0; (updateStatic = updateStatic || buffer._updateID < bid) && (buffer._updateID = container._updateID, buffer.uploadStatic(children, i, amount)), renderer.geometry.bind(buffer.geometry), gl.drawElements(gl.TRIANGLES, 6 * amount, gl.UNSIGNED_SHORT, 0) } } }, ParticleRenderer.prototype.generateBuffers = function (container) { for (var buffers = [], size = container._maxSize, batchSize = container._batchSize, dynamicPropertyFlags = container._properties, i = 0; i < size; i += batchSize)buffers.push(new ParticleBuffer(this.properties, dynamicPropertyFlags, batchSize)); return buffers }, ParticleRenderer.prototype._generateOneMoreBuffer = function (container) { var batchSize = container._batchSize; var dynamicPropertyFlags = container._properties; return new ParticleBuffer(this.properties, dynamicPropertyFlags, batchSize) }, ParticleRenderer.prototype.uploadVertices = function (children, startIndex, amount, array, stride, offset) { for (var w0 = 0, w1 = 0, h0 = 0, h1 = 0, i = 0; i < amount; ++i) { var sprite = children[startIndex + i]; var texture = sprite._texture; var sx = sprite.scale.x; var sy = sprite.scale.y; var trim = texture.trim; var orig = texture.orig; trim ? (w0 = (w1 = trim.x - sprite.anchor.x * orig.width) + trim.width, h0 = (h1 = trim.y - sprite.anchor.y * orig.height) + trim.height) : (w0 = orig.width * (1 - sprite.anchor.x), w1 = orig.width * -sprite.anchor.x, h0 = orig.height * (1 - sprite.anchor.y), h1 = orig.height * -sprite.anchor.y), array[offset] = w1 * sx, array[offset + 1] = h1 * sy, array[offset + stride] = w0 * sx, array[offset + stride + 1] = h1 * sy, array[offset + 2 * stride] = w0 * sx, array[offset + 2 * stride + 1] = h0 * sy, array[offset + 3 * stride] = w1 * sx, array[offset + 3 * stride + 1] = h0 * sy, offset += 4 * stride } }, ParticleRenderer.prototype.uploadPosition = function (children, startIndex, amount, array, stride, offset) { for (var i = 0; i < amount; i++) { var spritePosition = children[startIndex + i].position; array[offset] = spritePosition.x, array[offset + 1] = spritePosition.y, array[offset + stride] = spritePosition.x, array[offset + stride + 1] = spritePosition.y, array[offset + 2 * stride] = spritePosition.x, array[offset + 2 * stride + 1] = spritePosition.y, array[offset + 3 * stride] = spritePosition.x, array[offset + 3 * stride + 1] = spritePosition.y, offset += 4 * stride } }, ParticleRenderer.prototype.uploadRotation = function (children, startIndex, amount, array, stride, offset) { for (var i = 0; i < amount; i++) { var spriteRotation = children[startIndex + i].rotation; array[offset] = spriteRotation, array[offset + stride] = spriteRotation, array[offset + 2 * stride] = spriteRotation, array[offset + 3 * stride] = spriteRotation, offset += 4 * stride } }, ParticleRenderer.prototype.uploadUvs = function (children, startIndex, amount, array, stride, offset) { for (var i = 0; i < amount; ++i) { var textureUvs = children[startIndex + i]._texture._uvs; textureUvs ? (array[offset] = textureUvs.x0, array[offset + 1] = textureUvs.y0, array[offset + stride] = textureUvs.x1, array[offset + stride + 1] = textureUvs.y1, array[offset + 2 * stride] = textureUvs.x2, array[offset + 2 * stride + 1] = textureUvs.y2, array[offset + 3 * stride] = textureUvs.x3, array[offset + 3 * stride + 1] = textureUvs.y3) : (array[offset] = 0, array[offset + 1] = 0, array[offset + stride] = 0, array[offset + stride + 1] = 0, array[offset + 2 * stride] = 0, array[offset + 2 * stride + 1] = 0, array[offset + 3 * stride] = 0, array[offset + 3 * stride + 1] = 0), offset += 4 * stride } }, ParticleRenderer.prototype.uploadTint = function (children, startIndex, amount, array, stride, offset) { for (var i = 0; i < amount; ++i) { var sprite = children[startIndex + i]; var premultiplied = sprite._texture.baseTexture.premultiplyAlpha; var alpha = sprite.alpha; var argb = alpha < 1 && premultiplied ? premultiplyTint(sprite._tintRGB, alpha) : sprite._tintRGB + (255 * alpha << 24); array[offset] = argb, array[offset + stride] = argb, array[offset + 2 * stride] = argb, array[offset + 3 * stride] = argb, offset += 4 * stride } }, ParticleRenderer.prototype.destroy = function () { ObjectRenderer.prototype.destroy.call(this), this.shader && (this.shader.destroy(), this.shader = null), this.tempMatrix = null }, ParticleRenderer }(ObjectRenderer)); var Spritesheet = function (baseTexture, data, resolutionFilename) { void 0 === resolutionFilename && (resolutionFilename = null), this.baseTexture = baseTexture, this.textures = {}, this.animations = {}, this.data = data, this.resolution = this._updateResolution(resolutionFilename || (this.baseTexture.resource ? this.baseTexture.resource.url : null)), this._frames = this.data.frames, this._frameKeys = Object.keys(this._frames), this._batchIndex = 0, this._callback = null }; var staticAccessors$4 = { BATCH_SIZE: { configurable: !0 } }; staticAccessors$4.BATCH_SIZE.get = function () { return 1e3 }, Spritesheet.prototype._updateResolution = function (resolutionFilename) { var scale = this.data.meta.scale; var resolution = getResolutionOfUrl(resolutionFilename, null); return resolution === null && (resolution = void 0 !== scale ? parseFloat(scale) : 1), resolution !== 1 && this.baseTexture.setResolution(resolution), resolution }, Spritesheet.prototype.parse = function (callback) { this._batchIndex = 0, this._callback = callback, this._frameKeys.length <= Spritesheet.BATCH_SIZE ? (this._processFrames(0), this._processAnimations(), this._parseComplete()) : this._nextBatch() }, Spritesheet.prototype._processFrames = function (initialFrameIndex) { for (var frameIndex = initialFrameIndex, maxFrames = Spritesheet.BATCH_SIZE; frameIndex - initialFrameIndex < maxFrames && frameIndex < this._frameKeys.length;) { var i = this._frameKeys[frameIndex]; var data = this._frames[i]; var rect = data.frame; if (rect) { var frame = null; var trim = null; var sourceSize = !1 !== data.trimmed && data.sourceSize ? data.sourceSize : data.frame; var orig = new Rectangle(0, 0, Math.floor(sourceSize.w) / this.resolution, Math.floor(sourceSize.h) / this.resolution); frame = data.rotated ? new Rectangle(Math.floor(rect.x) / this.resolution, Math.floor(rect.y) / this.resolution, Math.floor(rect.h) / this.resolution, Math.floor(rect.w) / this.resolution) : new Rectangle(Math.floor(rect.x) / this.resolution, Math.floor(rect.y) / this.resolution, Math.floor(rect.w) / this.resolution, Math.floor(rect.h) / this.resolution), !1 !== data.trimmed && data.spriteSourceSize && (trim = new Rectangle(Math.floor(data.spriteSourceSize.x) / this.resolution, Math.floor(data.spriteSourceSize.y) / this.resolution, Math.floor(rect.w) / this.resolution, Math.floor(rect.h) / this.resolution)), this.textures[i] = new Texture(this.baseTexture, frame, orig, trim, data.rotated ? 2 : 0, data.anchor), Texture.addToCache(this.textures[i], i) }frameIndex++ } }, Spritesheet.prototype._processAnimations = function () { var animations = this.data.animations || {}; for (var animName in animations) { this.animations[animName] = []; for (var i = 0; i < animations[animName].length; i++) { var frameName = animations[animName][i]; this.animations[animName].push(this.textures[frameName]) } } }, Spritesheet.prototype._parseComplete = function () { var callback = this._callback; this._callback = null, this._batchIndex = 0, callback.call(this, this.textures) }, Spritesheet.prototype._nextBatch = function () { var this$1 = this; this._processFrames(this._batchIndex * Spritesheet.BATCH_SIZE), this._batchIndex++, setTimeout(function () { this$1._batchIndex * Spritesheet.BATCH_SIZE < this$1._frameKeys.length ? this$1._nextBatch() : (this$1._processAnimations(), this$1._parseComplete()) }, 0) }, Spritesheet.prototype.destroy = function (destroyBase) { for (var i in void 0 === destroyBase && (destroyBase = !1), this.textures) this.textures[i].destroy(); this._frames = null, this._frameKeys = null, this.data = null, this.textures = null, destroyBase && this.baseTexture.destroy(), this.baseTexture = null }, Object.defineProperties(Spritesheet, staticAccessors$4); var SpritesheetLoader = function () {}; SpritesheetLoader.use = function (resource, next) { var imageResourceName = resource.name + '_image'; if (resource.data && resource.type === LoaderResource.TYPE.JSON && resource.data.frames && !this.resources[imageResourceName]) { var loadOptions = { crossOrigin: resource.crossOrigin, metadata: resource.metadata.imageMetadata, parentResource: resource }; var resourcePath = SpritesheetLoader.getResourcePath(resource, this.baseUrl); this.add(imageResourceName, resourcePath, loadOptions, function (res) { if (res.error)next(res.error); else { var spritesheet = new Spritesheet(res.texture.baseTexture, resource.data, resource.url); spritesheet.parse(function () { resource.spritesheet = spritesheet, resource.textures = spritesheet.textures, next() }) } }) } else next() }, SpritesheetLoader.getResourcePath = function (resource, baseUrl) { return resource.isDataUrl ? resource.data.meta.image : url.resolve(resource.url.replace(baseUrl, ''), resource.data.meta.image) }; var tempPoint$1 = new Point(); var TilingSprite = (function (Sprite) { function TilingSprite (texture, width, height) { void 0 === width && (width = 100), void 0 === height && (height = 100), Sprite.call(this, texture), this.tileTransform = new Transform(), this._width = width, this._height = height, this._canvasPattern = null, this.uvMatrix = texture.uvMatrix || new TextureMatrix(texture), this.pluginName = 'tilingSprite', this.uvRespectAnchor = !1 }Sprite && (TilingSprite.__proto__ = Sprite), (TilingSprite.prototype = Object.create(Sprite && Sprite.prototype)).constructor = TilingSprite; var prototypeAccessors = { clampMargin: { configurable: !0 }, tileScale: { configurable: !0 }, tilePosition: { configurable: !0 }, width: { configurable: !0 }, height: { configurable: !0 } }; return prototypeAccessors.clampMargin.get = function () { return this.uvMatrix.clampMargin }, prototypeAccessors.clampMargin.set = function (value) { this.uvMatrix.clampMargin = value, this.uvMatrix.update(!0) }, prototypeAccessors.tileScale.get = function () { return this.tileTransform.scale }, prototypeAccessors.tileScale.set = function (value) { this.tileTransform.scale.copyFrom(value) }, prototypeAccessors.tilePosition.get = function () { return this.tileTransform.position }, prototypeAccessors.tilePosition.set = function (value) { this.tileTransform.position.copyFrom(value) }, TilingSprite.prototype._onTextureUpdate = function () { this.uvMatrix && (this.uvMatrix.texture = this._texture), this._cachedTint = 16777215 }, TilingSprite.prototype._render = function (renderer) { var texture = this._texture; texture && texture.valid && (this.tileTransform.updateLocalTransform(), this.uvMatrix.update(), renderer.batch.setObjectRenderer(renderer.plugins[this.pluginName]), renderer.plugins[this.pluginName].render(this)) }, TilingSprite.prototype._calculateBounds = function () { var minX = this._width * -this._anchor._x; var minY = this._height * -this._anchor._y; var maxX = this._width * (1 - this._anchor._x); var maxY = this._height * (1 - this._anchor._y); this._bounds.addFrame(this.transform, minX, minY, maxX, maxY) }, TilingSprite.prototype.getLocalBounds = function (rect) { return this.children.length === 0 ? (this._bounds.minX = this._width * -this._anchor._x, this._bounds.minY = this._height * -this._anchor._y, this._bounds.maxX = this._width * (1 - this._anchor._x), this._bounds.maxY = this._height * (1 - this._anchor._y), rect || (this._localBoundsRect || (this._localBoundsRect = new Rectangle()), rect = this._localBoundsRect), this._bounds.getRectangle(rect)) : Sprite.prototype.getLocalBounds.call(this, rect) }, TilingSprite.prototype.containsPoint = function (point) { this.worldTransform.applyInverse(point, tempPoint$1); var width = this._width; var height = this._height; var x1 = -width * this.anchor._x; if (tempPoint$1.x >= x1 && tempPoint$1.x < x1 + width) { var y1 = -height * this.anchor._y; if (tempPoint$1.y >= y1 && tempPoint$1.y < y1 + height) return !0 } return !1 }, TilingSprite.prototype.destroy = function (options) { Sprite.prototype.destroy.call(this, options), this.tileTransform = null, this.uvMatrix = null }, TilingSprite.from = function (source, width, height) { return new TilingSprite(Texture.from(source), width, height) }, TilingSprite.fromFrame = function (frameId, width, height) { var texture = TextureCache[frameId]; if (!texture) throw new Error('The frameId "' + frameId + '" does not exist in the texture cache ' + this); return new TilingSprite(texture, width, height) }, TilingSprite.fromImage = function (imageId, width, height, options, argument_4) { return options && typeof options !== 'object' && (options = { scaleMode: argument_4, resourceOptions: { crossorigin: arguments[3] } }), new TilingSprite(Texture.from(imageId, options), width, height) }, prototypeAccessors.width.get = function () { return this._width }, prototypeAccessors.width.set = function (value) { this._width = value }, prototypeAccessors.height.get = function () { return this._height }, prototypeAccessors.height.set = function (value) { this._height = value }, Object.defineProperties(TilingSprite.prototype, prototypeAccessors), TilingSprite }(Sprite)); var vertex$3 = 'attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\nuniform mat3 translationMatrix;\nuniform mat3 uTransform;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = (uTransform * vec3(aTextureCoord, 1.0)).xy;\n}\n'; var tempMat$1 = new Matrix(); var TilingSpriteRenderer = (function (ObjectRenderer) { function TilingSpriteRenderer (renderer) { ObjectRenderer.call(this, renderer); var uniforms = { globals: this.renderer.globalUniforms }; this.shader = Shader.from(vertex$3, 'varying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform vec4 uColor;\nuniform mat3 uMapCoord;\nuniform vec4 uClampFrame;\nuniform vec2 uClampOffset;\n\nvoid main(void)\n{\n    vec2 coord = mod(vTextureCoord - uClampOffset, vec2(1.0, 1.0)) + uClampOffset;\n    coord = (uMapCoord * vec3(coord, 1.0)).xy;\n    coord = clamp(coord, uClampFrame.xy, uClampFrame.zw);\n\n    vec4 sample = texture2D(uSampler, coord);\n    gl_FragColor = sample * uColor;\n}\n', uniforms), this.simpleShader = Shader.from(vertex$3, 'varying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform vec4 uColor;\n\nvoid main(void)\n{\n    vec4 sample = texture2D(uSampler, vTextureCoord);\n    gl_FragColor = sample * uColor;\n}\n', uniforms), this.quad = new QuadUv() } return ObjectRenderer && (TilingSpriteRenderer.__proto__ = ObjectRenderer), ((TilingSpriteRenderer.prototype = Object.create(ObjectRenderer && ObjectRenderer.prototype)).constructor = TilingSpriteRenderer).prototype.render = function (ts) { var renderer = this.renderer; var quad = this.quad; var vertices = quad.vertices; vertices[0] = vertices[6] = ts._width * -ts.anchor.x, vertices[1] = vertices[3] = ts._height * -ts.anchor.y, vertices[2] = vertices[4] = ts._width * (1 - ts.anchor.x), vertices[5] = vertices[7] = ts._height * (1 - ts.anchor.y), ts.uvRespectAnchor && ((vertices = quad.uvs)[0] = vertices[6] = -ts.anchor.x, vertices[1] = vertices[3] = -ts.anchor.y, vertices[2] = vertices[4] = 1 - ts.anchor.x, vertices[5] = vertices[7] = 1 - ts.anchor.y), quad.invalidate(); var tex = ts._texture; var baseTex = tex.baseTexture; var lt = ts.tileTransform.localTransform; var uv = ts.uvMatrix; var isSimple = baseTex.isPowerOfTwo && tex.frame.width === baseTex.width && tex.frame.height === baseTex.height; isSimple && (baseTex._glTextures[renderer.CONTEXT_UID] ? isSimple = baseTex.wrapMode !== WRAP_MODES.CLAMP : baseTex.wrapMode === WRAP_MODES.CLAMP && (baseTex.wrapMode = WRAP_MODES.REPEAT)); var shader = isSimple ? this.simpleShader : this.shader; var w = tex.width; var h = tex.height; var W = ts._width; var H = ts._height; tempMat$1.set(lt.a * w / W, lt.b * w / H, lt.c * h / W, lt.d * h / H, lt.tx / W, lt.ty / H), tempMat$1.invert(), isSimple ? tempMat$1.prepend(uv.mapCoord) : (shader.uniforms.uMapCoord = uv.mapCoord.toArray(!0), shader.uniforms.uClampFrame = uv.uClampFrame, shader.uniforms.uClampOffset = uv.uClampOffset), shader.uniforms.uTransform = tempMat$1.toArray(!0), shader.uniforms.uColor = premultiplyTintToRgba(ts.tint, ts.worldAlpha, shader.uniforms.uColor, baseTex.premultiplyAlpha), shader.uniforms.translationMatrix = ts.transform.worldTransform.toArray(!0), shader.uniforms.uSampler = tex, renderer.shader.bind(shader), renderer.geometry.bind(quad), renderer.state.setBlendMode(correctBlendMode(ts.blendMode, baseTex.premultiplyAlpha)), renderer.geometry.draw(this.renderer.gl.TRIANGLES, 6, 0) }, TilingSpriteRenderer }(ObjectRenderer)); var BitmapText = (function (Container) { function BitmapText (text, style) { var this$1 = this; void 0 === style && (style = {}), Container.call(this), this._textWidth = 0, this._textHeight = 0, this._glyphs = [], this._font = { tint: void 0 !== style.tint ? style.tint : 16777215, align: style.align || 'left', name: null, size: 0 }, this.font = style.font, this._text = text, this._maxWidth = 0, this._maxLineHeight = 0, this._letterSpacing = 0, this._anchor = new ObservablePoint(function () { this$1.dirty = !0 }, this, 0, 0), this.dirty = !1, this.roundPixels = settings.ROUND_PIXELS, this.updateText() }Container && (BitmapText.__proto__ = Container); var prototypeAccessors = { tint: { configurable: !0 }, align: { configurable: !0 }, anchor: { configurable: !0 }, font: { configurable: !0 }, text: { configurable: !0 }, maxWidth: { configurable: !0 }, maxLineHeight: { configurable: !0 }, textWidth: { configurable: !0 }, letterSpacing: { configurable: !0 }, textHeight: { configurable: !0 } }; return ((BitmapText.prototype = Object.create(Container && Container.prototype)).constructor = BitmapText).prototype.updateText = function () { for (var data = BitmapText.fonts[this._font.name], scale = this._font.size / data.size, pos = new Point(), chars = [], lineWidths = [], text = this._text.replace(/(?:\r\n|\r)/g, '\n') || ' ', textLength = text.length, maxWidth = this._maxWidth * data.size / this._font.size, prevCharCode = null, lastLineWidth = 0, maxLineWidth = 0, line = 0, lastBreakPos = -1, lastBreakWidth = 0, spacesRemoved = 0, maxLineHeight = 0, i = 0; i < textLength; i++) { var charCode = text.charCodeAt(i); var char = text.charAt(i); if (/(?:\s)/.test(char) && (lastBreakPos = i, lastBreakWidth = lastLineWidth), char !== '\r' && char !== '\n') { var charData = data.chars[charCode]; charData && (prevCharCode && charData.kerning[prevCharCode] && (pos.x += charData.kerning[prevCharCode]), chars.push({ texture: charData.texture, line: line, charCode: charCode, position: new Point(pos.x + charData.xOffset + this._letterSpacing / 2, pos.y + charData.yOffset) }), pos.x += charData.xAdvance + this._letterSpacing, lastLineWidth = pos.x, maxLineHeight = Math.max(maxLineHeight, charData.yOffset + charData.texture.height), prevCharCode = charCode, lastBreakPos !== -1 && maxWidth > 0 && pos.x > maxWidth && (removeItems(chars, 1 + lastBreakPos - ++spacesRemoved, 1 + i - lastBreakPos), i = lastBreakPos, lastBreakPos = -1, lineWidths.push(lastBreakWidth), maxLineWidth = Math.max(maxLineWidth, lastBreakWidth), line++, pos.x = 0, pos.y += data.lineHeight, prevCharCode = null)) } else lineWidths.push(lastLineWidth), maxLineWidth = Math.max(maxLineWidth, lastLineWidth), ++line, ++spacesRemoved, pos.x = 0, pos.y += data.lineHeight, prevCharCode = null } var lastChar = text.charAt(text.length - 1); lastChar !== '\r' && lastChar !== '\n' && (/(?:\s)/.test(lastChar) && (lastLineWidth = lastBreakWidth), lineWidths.push(lastLineWidth), maxLineWidth = Math.max(maxLineWidth, lastLineWidth)); for (var lineAlignOffsets = [], i$1 = 0; i$1 <= line; i$1++) { var alignOffset = 0; this._font.align === 'right' ? alignOffset = maxLineWidth - lineWidths[i$1] : this._font.align === 'center' && (alignOffset = (maxLineWidth - lineWidths[i$1]) / 2), lineAlignOffsets.push(alignOffset) } for (var lenChars = chars.length, tint = this.tint, i$2 = 0; i$2 < lenChars; i$2++) { var c = this._glyphs[i$2]; c ? c.texture = chars[i$2].texture : ((c = new Sprite(chars[i$2].texture)).roundPixels = this.roundPixels, this._glyphs.push(c)), c.position.x = (chars[i$2].position.x + lineAlignOffsets[chars[i$2].line]) * scale, c.position.y = chars[i$2].position.y * scale, c.scale.x = c.scale.y = scale, c.tint = tint, c.parent || this.addChild(c) } for (var i$3 = lenChars; i$3 < this._glyphs.length; ++i$3) this.removeChild(this._glyphs[i$3]); if (this._textWidth = maxLineWidth * scale, this._textHeight = (pos.y + data.lineHeight) * scale, this.anchor.x !== 0 || this.anchor.y !== 0) for (var i$4 = 0; i$4 < lenChars; i$4++) this._glyphs[i$4].x -= this._textWidth * this.anchor.x, this._glyphs[i$4].y -= this._textHeight * this.anchor.y; this._maxLineHeight = maxLineHeight * scale }, BitmapText.prototype.updateTransform = function () { this.validate(), this.containerUpdateTransform() }, BitmapText.prototype.getLocalBounds = function () { return this.validate(), Container.prototype.getLocalBounds.call(this) }, BitmapText.prototype.validate = function () { this.dirty && (this.updateText(), this.dirty = !1) }, prototypeAccessors.tint.get = function () { return this._font.tint }, prototypeAccessors.tint.set = function (value) { this._font.tint = typeof value === 'number' && value >= 0 ? value : 16777215, this.dirty = !0 }, prototypeAccessors.align.get = function () { return this._font.align }, prototypeAccessors.align.set = function (value) { this._font.align = value || 'left', this.dirty = !0 }, prototypeAccessors.anchor.get = function () { return this._anchor }, prototypeAccessors.anchor.set = function (value) { typeof value === 'number' ? this._anchor.set(value) : this._anchor.copyFrom(value) }, prototypeAccessors.font.get = function () { return this._font }, prototypeAccessors.font.set = function (value) { value && (typeof value === 'string' ? (value = value.split(' '), this._font.name = value.length === 1 ? value[0] : value.slice(1).join(' '), this._font.size = value.length >= 2 ? parseInt(value[0], 10) : BitmapText.fonts[this._font.name].size) : (this._font.name = value.name, this._font.size = typeof value.size === 'number' ? value.size : parseInt(value.size, 10)), this.dirty = !0) }, prototypeAccessors.text.get = function () { return this._text }, prototypeAccessors.text.set = function (text) { text = String(text == null ? '' : text), this._text !== text && (this._text = text, this.dirty = !0) }, prototypeAccessors.maxWidth.get = function () { return this._maxWidth }, prototypeAccessors.maxWidth.set = function (value) { this._maxWidth !== value && (this._maxWidth = value, this.dirty = !0) }, prototypeAccessors.maxLineHeight.get = function () { return this.validate(), this._maxLineHeight }, prototypeAccessors.textWidth.get = function () { return this.validate(), this._textWidth }, prototypeAccessors.letterSpacing.get = function () { return this._letterSpacing }, prototypeAccessors.letterSpacing.set = function (value) { this._letterSpacing !== value && (this._letterSpacing = value, this.dirty = !0) }, prototypeAccessors.textHeight.get = function () { return this.validate(), this._textHeight }, BitmapText.registerFont = function (xml, textures) { var data = {}; var info = xml.getElementsByTagName('info')[0]; var common = xml.getElementsByTagName('common')[0]; var pages = xml.getElementsByTagName('page'); var res = getResolutionOfUrl(pages[0].getAttribute('file'), settings.RESOLUTION); var pagesTextures = {}; data.font = info.getAttribute('face'), data.size = parseInt(info.getAttribute('size'), 10), data.lineHeight = parseInt(common.getAttribute('lineHeight'), 10) / res, data.chars = {}, textures instanceof Texture && (textures = [textures]); for (var i = 0; i < pages.length; i++) { var id = pages[i].getAttribute('id'); var file = pages[i].getAttribute('file'); pagesTextures[id] = textures instanceof Array ? textures[i] : textures[file] } for (var letters = xml.getElementsByTagName('char'), i$1 = 0; i$1 < letters.length; i$1++) { var letter = letters[i$1]; var charCode = parseInt(letter.getAttribute('id'), 10); var page = letter.getAttribute('page') || 0; var textureRect = new Rectangle(parseInt(letter.getAttribute('x'), 10) / res + pagesTextures[page].frame.x / res, parseInt(letter.getAttribute('y'), 10) / res + pagesTextures[page].frame.y / res, parseInt(letter.getAttribute('width'), 10) / res, parseInt(letter.getAttribute('height'), 10) / res); data.chars[charCode] = { xOffset: parseInt(letter.getAttribute('xoffset'), 10) / res, yOffset: parseInt(letter.getAttribute('yoffset'), 10) / res, xAdvance: parseInt(letter.getAttribute('xadvance'), 10) / res, kerning: {}, texture: new Texture(pagesTextures[page].baseTexture, textureRect), page: page } } for (var kernings = xml.getElementsByTagName('kerning'), i$2 = 0; i$2 < kernings.length; i$2++) { var kerning = kernings[i$2]; var first = parseInt(kerning.getAttribute('first'), 10) / res; var second = parseInt(kerning.getAttribute('second'), 10) / res; var amount = parseInt(kerning.getAttribute('amount'), 10) / res; data.chars[second] && (data.chars[second].kerning[first] = amount) } return BitmapText.fonts[data.font] = data }, Object.defineProperties(BitmapText.prototype, prototypeAccessors), BitmapText }(Container)); BitmapText.fonts = {}; var BitmapFontLoader = function () {}; BitmapFontLoader.parse = function (resource, texture) { resource.bitmapFont = BitmapText.registerFont(resource.data, texture) }, BitmapFontLoader.add = function () { LoaderResource.setExtensionXhrType('fnt', LoaderResource.XHR_RESPONSE_TYPE.DOCUMENT) }, BitmapFontLoader.dirname = function (url) { var dir = url.replace(/\/$/, '').replace(/\/[^\/]*$/, ''); return dir === url ? '.' : dir === '' ? '/' : dir }, BitmapFontLoader.use = function (resource, next) { if (resource.data && resource.type === LoaderResource.TYPE.XML) if (resource.data.getElementsByTagName('page').length !== 0 && resource.data.getElementsByTagName('info').length !== 0 && resource.data.getElementsByTagName('info')[0].getAttribute('face') !== null) { var xmlUrl = resource.isDataUrl ? '' : BitmapFontLoader.dirname(resource.url); resource.isDataUrl && (xmlUrl === '.' && (xmlUrl = ''), this.baseUrl && xmlUrl && this.baseUrl.charAt(this.baseUrl.length - 1) === '/' && (xmlUrl += '/')), (xmlUrl = xmlUrl.replace(this.baseUrl, '')) && xmlUrl.charAt(xmlUrl.length - 1) !== '/' && (xmlUrl += '/'); for (var pages = resource.data.getElementsByTagName('page'), textures = {}, completed = function (page) { textures[page.metadata.pageFile] = page.texture, Object.keys(textures).length === pages.length && (BitmapFontLoader.parse(resource, textures), next()) }, i = 0; i < pages.length; ++i) { var pageFile = pages[i].getAttribute('file'); var url = xmlUrl + pageFile; var exists = !1; for (var name in this.resources) { var bitmapResource = this.resources[name]; if (bitmapResource.url === url) { bitmapResource.metadata.pageFile = pageFile, bitmapResource.texture ? completed(bitmapResource) : bitmapResource.onAfterMiddleware.add(completed), exists = !0; break } } if (!exists) { var options = { crossOrigin: resource.crossOrigin, loadType: LoaderResource.LOAD_TYPE.IMAGE, metadata: Object.assign({ pageFile: pageFile }, resource.metadata.imageMetadata), parentResource: resource }; this.add(url, options, completed) } } } else next(); else next() }; var AlphaFilter = (function (Filter) { function AlphaFilter (alpha) { void 0 === alpha && (alpha = 1), Filter.call(this, _default, 'varying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform float uAlpha;\n\nvoid main(void)\n{\n   gl_FragColor = texture2D(uSampler, vTextureCoord) * uAlpha;\n}\n', { uAlpha: 1 }), this.alpha = alpha }Filter && (AlphaFilter.__proto__ = Filter), (AlphaFilter.prototype = Object.create(Filter && Filter.prototype)).constructor = AlphaFilter; var prototypeAccessors = { alpha: { configurable: !0 } }; return prototypeAccessors.alpha.get = function () { return this.uniforms.uAlpha }, prototypeAccessors.alpha.set = function (value) { this.uniforms.uAlpha = value }, Object.defineProperties(AlphaFilter.prototype, prototypeAccessors), AlphaFilter }(Filter)); var vertTemplate = '\n    attribute vec2 aVertexPosition;\n\n    uniform mat3 projectionMatrix;\n\n    uniform float strength;\n\n    varying vec2 vBlurTexCoords[%size%];\n\n    uniform vec4 inputSize;\n    uniform vec4 outputFrame;\n    \n    vec4 filterVertexPosition( void )\n    {\n        vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;\n    \n        return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\n    }\n    \n    vec2 filterTextureCoord( void )\n    {\n        return aVertexPosition * (outputFrame.zw * inputSize.zw);\n    }\n\n    void main(void)\n    {\n        gl_Position = filterVertexPosition();\n\n        vec2 textureCoord = filterTextureCoord();\n        %blur%\n    }'; var GAUSSIAN_VALUES = { 5: [0.153388, 0.221461, 0.250301], 7: [0.071303, 0.131514, 0.189879, 0.214607], 9: [0.028532, 0.067234, 0.124009, 0.179044, 0.20236], 11: [0.0093, 0.028002, 0.065984, 0.121703, 0.175713, 0.198596], 13: [0.002406, 0.009255, 0.027867, 0.065666, 0.121117, 0.174868, 0.197641], 15: [489e-6, 0.002403, 0.009246, 0.02784, 0.065602, 0.120999, 0.174697, 0.197448] }; var fragTemplate$2 = ['varying vec2 vBlurTexCoords[%size%];', 'uniform sampler2D uSampler;', 'void main(void)', '{', '    gl_FragColor = vec4(0.0);', '    %blur%', '}'].join('\n'); var BlurFilterPass = (function (Filter) { function BlurFilterPass (horizontal, strength, quality, resolution, kernelSize) { var vertSrc = (function (kernelSize, x) { var template; var halfLength = Math.ceil(kernelSize / 2); var vertSource = vertTemplate; var blurLoop = ''; template = x ? 'vBlurTexCoords[%index%] =  textureCoord + vec2(%sampleIndex% * strength, 0.0);' : 'vBlurTexCoords[%index%] =  textureCoord + vec2(0.0, %sampleIndex% * strength);'; for (var i = 0; i < kernelSize; i++) { var blur = template.replace('%index%', i); blurLoop += blur = blur.replace('%sampleIndex%', i - (halfLength - 1) + '.0'), blurLoop += '\n' } return vertSource = (vertSource = vertSource.replace('%blur%', blurLoop)).replace('%size%', kernelSize) }(kernelSize = kernelSize || 5, horizontal)); var fragSrc = (function (kernelSize) { for (var value, kernel = GAUSSIAN_VALUES[kernelSize], halfLength = kernel.length, fragSource = fragTemplate$2, blurLoop = '', i = 0; i < kernelSize; i++) { var blur = 'gl_FragColor += texture2D(uSampler, vBlurTexCoords[%index%]) * %value%;'.replace('%index%', i); halfLength <= (value = i) && (value = kernelSize - i - 1), blurLoop += blur = blur.replace('%value%', kernel[value]), blurLoop += '\n' } return fragSource = (fragSource = fragSource.replace('%blur%', blurLoop)).replace('%size%', kernelSize) }(kernelSize)); Filter.call(this, vertSrc, fragSrc), this.horizontal = horizontal, this.resolution = resolution || settings.RESOLUTION, this._quality = 0, this.quality = quality || 4, this.blur = strength || 8 }Filter && (BlurFilterPass.__proto__ = Filter); var prototypeAccessors = { blur: { configurable: !0 }, quality: { configurable: !0 } }; return ((BlurFilterPass.prototype = Object.create(Filter && Filter.prototype)).constructor = BlurFilterPass).prototype.apply = function (filterManager, input, output, clear) { if (output ? this.horizontal ? this.uniforms.strength = 1 / output.width * (output.width / input.width) : this.uniforms.strength = 1 / output.height * (output.height / input.height) : this.horizontal ? this.uniforms.strength = 1 / filterManager.renderer.width * (filterManager.renderer.width / input.width) : this.uniforms.strength = 1 / filterManager.renderer.height * (filterManager.renderer.height / input.height), this.uniforms.strength *= this.strength, this.uniforms.strength /= this.passes, this.passes === 1)filterManager.applyFilter(this, input, output, clear); else { var renderTarget = filterManager.getFilterTexture(); var renderer = filterManager.renderer; var flip = input; var flop = renderTarget; this.state.blend = !1, filterManager.applyFilter(this, flip, flop, !1); for (var i = 1; i < this.passes - 1; i++) { renderer.renderTexture.bind(flip, flip.filterFrame); var temp = this.uniforms.uSampler = flop; flop = flip, flip = temp, renderer.shader.bind(this), renderer.geometry.draw(5) } this.state.blend = !0, filterManager.applyFilter(this, flop, output, clear), filterManager.returnFilterTexture(renderTarget) } }, prototypeAccessors.blur.get = function () { return this.strength }, prototypeAccessors.blur.set = function (value) { this.padding = 1 + 2 * Math.abs(value), this.strength = value }, prototypeAccessors.quality.get = function () { return this._quality }, prototypeAccessors.quality.set = function (value) { this._quality = value, this.passes = value }, Object.defineProperties(BlurFilterPass.prototype, prototypeAccessors), BlurFilterPass }(Filter)); var BlurFilter = (function (Filter) { function BlurFilter (strength, quality, resolution, kernelSize) { Filter.call(this), this.blurXFilter = new BlurFilterPass(!0, strength, quality, resolution, kernelSize), this.blurYFilter = new BlurFilterPass(!1, strength, quality, resolution, kernelSize), this.resolution = resolution || settings.RESOLUTION, this.quality = quality || 4, this.blur = strength || 8, this.repeatEdgePixels = !1 }Filter && (BlurFilter.__proto__ = Filter); var prototypeAccessors = { blur: { configurable: !0 }, quality: { configurable: !0 }, blurX: { configurable: !0 }, blurY: { configurable: !0 }, blendMode: { configurable: !0 }, repeatEdgePixels: { configurable: !0 } }; return ((BlurFilter.prototype = Object.create(Filter && Filter.prototype)).constructor = BlurFilter).prototype.apply = function (filterManager, input, output, clear) { var xStrength = Math.abs(this.blurXFilter.strength); var yStrength = Math.abs(this.blurYFilter.strength); if (xStrength && yStrength) { var renderTarget = filterManager.getFilterTexture(); this.blurXFilter.apply(filterManager, input, renderTarget, !0), this.blurYFilter.apply(filterManager, renderTarget, output, clear), filterManager.returnFilterTexture(renderTarget) } else yStrength ? this.blurYFilter.apply(filterManager, input, output, clear) : this.blurXFilter.apply(filterManager, input, output, clear) }, BlurFilter.prototype.updatePadding = function () { this._repeatEdgePixels ? this.padding = 0 : this.padding = 2 * Math.max(Math.abs(this.blurXFilter.strength), Math.abs(this.blurYFilter.strength)) }, prototypeAccessors.blur.get = function () { return this.blurXFilter.blur }, prototypeAccessors.blur.set = function (value) { this.blurXFilter.blur = this.blurYFilter.blur = value, this.updatePadding() }, prototypeAccessors.quality.get = function () { return this.blurXFilter.quality }, prototypeAccessors.quality.set = function (value) { this.blurXFilter.quality = this.blurYFilter.quality = value }, prototypeAccessors.blurX.get = function () { return this.blurXFilter.blur }, prototypeAccessors.blurX.set = function (value) { this.blurXFilter.blur = value, this.updatePadding() }, prototypeAccessors.blurY.get = function () { return this.blurYFilter.blur }, prototypeAccessors.blurY.set = function (value) { this.blurYFilter.blur = value, this.updatePadding() }, prototypeAccessors.blendMode.get = function () { return this.blurYFilter.blendMode }, prototypeAccessors.blendMode.set = function (value) { this.blurYFilter.blendMode = value }, prototypeAccessors.repeatEdgePixels.get = function () { return this._repeatEdgePixels }, prototypeAccessors.repeatEdgePixels.set = function (value) { this._repeatEdgePixels = value, this.updatePadding() }, Object.defineProperties(BlurFilter.prototype, prototypeAccessors), BlurFilter }(Filter)); var ColorMatrixFilter = (function (Filter) { function ColorMatrixFilter () { var uniforms = { m: new Float32Array([1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0]), uAlpha: 1 }; Filter.call(this, defaultFilter, 'varying vec2 vTextureCoord;\nuniform sampler2D uSampler;\nuniform float m[20];\nuniform float uAlpha;\n\nvoid main(void)\n{\n    vec4 c = texture2D(uSampler, vTextureCoord);\n\n    if (uAlpha == 0.0) {\n        gl_FragColor = c;\n        return;\n    }\n\n    // Un-premultiply alpha before applying the color matrix. See issue #3539.\n    if (c.a > 0.0) {\n      c.rgb /= c.a;\n    }\n\n    vec4 result;\n\n    result.r = (m[0] * c.r);\n        result.r += (m[1] * c.g);\n        result.r += (m[2] * c.b);\n        result.r += (m[3] * c.a);\n        result.r += m[4];\n\n    result.g = (m[5] * c.r);\n        result.g += (m[6] * c.g);\n        result.g += (m[7] * c.b);\n        result.g += (m[8] * c.a);\n        result.g += m[9];\n\n    result.b = (m[10] * c.r);\n       result.b += (m[11] * c.g);\n       result.b += (m[12] * c.b);\n       result.b += (m[13] * c.a);\n       result.b += m[14];\n\n    result.a = (m[15] * c.r);\n       result.a += (m[16] * c.g);\n       result.a += (m[17] * c.b);\n       result.a += (m[18] * c.a);\n       result.a += m[19];\n\n    vec3 rgb = mix(c.rgb, result.rgb, uAlpha);\n\n    // Premultiply alpha again.\n    rgb *= result.a;\n\n    gl_FragColor = vec4(rgb, result.a);\n}\n', uniforms), this.alpha = 1 }Filter && (ColorMatrixFilter.__proto__ = Filter); var prototypeAccessors = { matrix: { configurable: !0 }, alpha: { configurable: !0 } }; return ((ColorMatrixFilter.prototype = Object.create(Filter && Filter.prototype)).constructor = ColorMatrixFilter).prototype._loadMatrix = function (matrix, multiply) { void 0 === multiply && (multiply = !1); var newMatrix = matrix; multiply && (this._multiply(newMatrix, this.uniforms.m, matrix), newMatrix = this._colorMatrix(newMatrix)), this.uniforms.m = newMatrix }, ColorMatrixFilter.prototype._multiply = function (out, a, b) { return out[0] = a[0] * b[0] + a[1] * b[5] + a[2] * b[10] + a[3] * b[15], out[1] = a[0] * b[1] + a[1] * b[6] + a[2] * b[11] + a[3] * b[16], out[2] = a[0] * b[2] + a[1] * b[7] + a[2] * b[12] + a[3] * b[17], out[3] = a[0] * b[3] + a[1] * b[8] + a[2] * b[13] + a[3] * b[18], out[4] = a[0] * b[4] + a[1] * b[9] + a[2] * b[14] + a[3] * b[19] + a[4], out[5] = a[5] * b[0] + a[6] * b[5] + a[7] * b[10] + a[8] * b[15], out[6] = a[5] * b[1] + a[6] * b[6] + a[7] * b[11] + a[8] * b[16], out[7] = a[5] * b[2] + a[6] * b[7] + a[7] * b[12] + a[8] * b[17], out[8] = a[5] * b[3] + a[6] * b[8] + a[7] * b[13] + a[8] * b[18], out[9] = a[5] * b[4] + a[6] * b[9] + a[7] * b[14] + a[8] * b[19] + a[9], out[10] = a[10] * b[0] + a[11] * b[5] + a[12] * b[10] + a[13] * b[15], out[11] = a[10] * b[1] + a[11] * b[6] + a[12] * b[11] + a[13] * b[16], out[12] = a[10] * b[2] + a[11] * b[7] + a[12] * b[12] + a[13] * b[17], out[13] = a[10] * b[3] + a[11] * b[8] + a[12] * b[13] + a[13] * b[18], out[14] = a[10] * b[4] + a[11] * b[9] + a[12] * b[14] + a[13] * b[19] + a[14], out[15] = a[15] * b[0] + a[16] * b[5] + a[17] * b[10] + a[18] * b[15], out[16] = a[15] * b[1] + a[16] * b[6] + a[17] * b[11] + a[18] * b[16], out[17] = a[15] * b[2] + a[16] * b[7] + a[17] * b[12] + a[18] * b[17], out[18] = a[15] * b[3] + a[16] * b[8] + a[17] * b[13] + a[18] * b[18], out[19] = a[15] * b[4] + a[16] * b[9] + a[17] * b[14] + a[18] * b[19] + a[19], out }, ColorMatrixFilter.prototype._colorMatrix = function (matrix) { var m = new Float32Array(matrix); return m[4] /= 255, m[9] /= 255, m[14] /= 255, m[19] /= 255, m }, ColorMatrixFilter.prototype.brightness = function (b, multiply) { var matrix = [b, 0, 0, 0, 0, 0, b, 0, 0, 0, 0, 0, b, 0, 0, 0, 0, 0, 1, 0]; this._loadMatrix(matrix, multiply) }, ColorMatrixFilter.prototype.greyscale = function (scale, multiply) { var matrix = [scale, scale, scale, 0, 0, scale, scale, scale, 0, 0, scale, scale, scale, 0, 0, 0, 0, 0, 1, 0]; this._loadMatrix(matrix, multiply) }, ColorMatrixFilter.prototype.blackAndWhite = function (multiply) { this._loadMatrix([0.3, 0.6, 0.1, 0, 0, 0.3, 0.6, 0.1, 0, 0, 0.3, 0.6, 0.1, 0, 0, 0, 0, 0, 1, 0], multiply) }, ColorMatrixFilter.prototype.hue = function (rotation, multiply) { rotation = (rotation || 0) / 180 * Math.PI; var cosR = Math.cos(rotation); var sinR = Math.sin(rotation); var w = 1 / 3; var sqrW = (0, Math.sqrt)(w); var matrix = [cosR + (1 - cosR) * w, w * (1 - cosR) - sqrW * sinR, w * (1 - cosR) + sqrW * sinR, 0, 0, w * (1 - cosR) + sqrW * sinR, cosR + w * (1 - cosR), w * (1 - cosR) - sqrW * sinR, 0, 0, w * (1 - cosR) - sqrW * sinR, w * (1 - cosR) + sqrW * sinR, cosR + w * (1 - cosR), 0, 0, 0, 0, 0, 1, 0]; this._loadMatrix(matrix, multiply) }, ColorMatrixFilter.prototype.contrast = function (amount, multiply) { var v = (amount || 0) + 1; var o = -0.5 * (v - 1); var matrix = [v, 0, 0, 0, o, 0, v, 0, 0, o, 0, 0, v, 0, o, 0, 0, 0, 1, 0]; this._loadMatrix(matrix, multiply) }, ColorMatrixFilter.prototype.saturate = function (amount, multiply) { void 0 === amount && (amount = 0); var x = 2 * amount / 3 + 1; var y = -0.5 * (x - 1); var matrix = [x, y, y, 0, 0, y, x, y, 0, 0, y, y, x, 0, 0, 0, 0, 0, 1, 0]; this._loadMatrix(matrix, multiply) }, ColorMatrixFilter.prototype.desaturate = function () { this.saturate(-1) }, ColorMatrixFilter.prototype.negative = function (multiply) { this._loadMatrix([-1, 0, 0, 1, 0, 0, -1, 0, 1, 0, 0, 0, -1, 1, 0, 0, 0, 0, 1, 0], multiply) }, ColorMatrixFilter.prototype.sepia = function (multiply) { this._loadMatrix([0.393, 0.7689999, 0.18899999, 0, 0, 0.349, 0.6859999, 0.16799999, 0, 0, 0.272, 0.5339999, 0.13099999, 0, 0, 0, 0, 0, 1, 0], multiply) }, ColorMatrixFilter.prototype.technicolor = function (multiply) { this._loadMatrix([1.9125277891456083, -0.8545344976951645, -0.09155508482755585, 0, 11.793603434377337, -0.3087833385928097, 1.7658908555458428, -0.10601743074722245, 0, -70.35205161461398, -0.231103377548616, -0.7501899197440212, 1.847597816108189, 0, 30.950940869491138, 0, 0, 0, 1, 0], multiply) }, ColorMatrixFilter.prototype.polaroid = function (multiply) { this._loadMatrix([1.438, -0.062, -0.062, 0, 0, -0.122, 1.378, -0.122, 0, 0, -0.016, -0.016, 1.483, 0, 0, 0, 0, 0, 1, 0], multiply) }, ColorMatrixFilter.prototype.toBGR = function (multiply) { this._loadMatrix([0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0], multiply) }, ColorMatrixFilter.prototype.kodachrome = function (multiply) { this._loadMatrix([1.1285582396593525, -0.3967382283601348, -0.03992559172921793, 0, 63.72958762196502, -0.16404339962244616, 1.0835251566291304, -0.05498805115633132, 0, 24.732407896706203, -0.16786010706155763, -0.5603416277695248, 1.6014850761964943, 0, 35.62982807460946, 0, 0, 0, 1, 0], multiply) }, ColorMatrixFilter.prototype.browni = function (multiply) { this._loadMatrix([0.5997023498159715, 0.34553243048391263, -0.2708298674538042, 0, 47.43192855600873, -0.037703249837783157, 0.8609577587992641, 0.15059552388459913, 0, -36.96841498319127, 0.24113635128153335, -0.07441037908422492, 0.44972182064877153, 0, -7.562075277591283, 0, 0, 0, 1, 0], multiply) }, ColorMatrixFilter.prototype.vintage = function (multiply) { this._loadMatrix([0.6279345635605994, 0.3202183420819367, -0.03965408211312453, 0, 9.651285835294123, 0.02578397704808868, 0.6441188644374771, 0.03259127616149294, 0, 7.462829176470591, 0.0466055556782719, -0.0851232987247891, 0.5241648018700465, 0, 5.159190588235296, 0, 0, 0, 1, 0], multiply) }, ColorMatrixFilter.prototype.colorTone = function (desaturation, toned, lightColor, darkColor, multiply) { var lR = ((lightColor = lightColor || 16770432) >> 16 & 255) / 255; var lG = (lightColor >> 8 & 255) / 255; var lB = (255 & lightColor) / 255; var dR = ((darkColor = darkColor || 3375104) >> 16 & 255) / 255; var dG = (darkColor >> 8 & 255) / 255; var dB = (255 & darkColor) / 255; var matrix = [0.3, 0.59, 0.11, 0, 0, lR, lG, lB, desaturation = desaturation || 0.2, 0, dR, dG, dB, toned = toned || 0.15, 0, lR - dR, lG - dG, lB - dB, 0, 0]; this._loadMatrix(matrix, multiply) }, ColorMatrixFilter.prototype.night = function (intensity, multiply) { var matrix = [-2 * (intensity = intensity || 0.1), -intensity, 0, 0, 0, -intensity, 0, intensity, 0, 0, 0, intensity, 2 * intensity, 0, 0, 0, 0, 0, 1, 0]; this._loadMatrix(matrix, multiply) }, ColorMatrixFilter.prototype.predator = function (amount, multiply) { var matrix = [11.224130630493164 * amount, -4.794486999511719 * amount, -2.8746118545532227 * amount, 0 * amount, 0.40342438220977783 * amount, -3.6330697536468506 * amount, 9.193157196044922 * amount, -2.951810836791992 * amount, 0 * amount, -1.316135048866272 * amount, -3.2184197902679443 * amount, -4.2375030517578125 * amount, 7.476448059082031 * amount, 0 * amount, 0.8044459223747253 * amount, 0, 0, 0, 1, 0]; this._loadMatrix(matrix, multiply) }, ColorMatrixFilter.prototype.lsd = function (multiply) { this._loadMatrix([2, -0.4, 0.5, 0, 0, -0.5, 2, -0.4, 0, 0, -0.4, -0.5, 3, 0, 0, 0, 0, 0, 1, 0], multiply) }, ColorMatrixFilter.prototype.reset = function () { this._loadMatrix([1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0], !1) }, prototypeAccessors.matrix.get = function () { return this.uniforms.m }, prototypeAccessors.matrix.set = function (value) { this.uniforms.m = value }, prototypeAccessors.alpha.get = function () { return this.uniforms.uAlpha }, prototypeAccessors.alpha.set = function (value) { this.uniforms.uAlpha = value }, Object.defineProperties(ColorMatrixFilter.prototype, prototypeAccessors), ColorMatrixFilter }(Filter)); ColorMatrixFilter.prototype.grayscale = ColorMatrixFilter.prototype.greyscale; var DisplacementFilter = (function (Filter) { function DisplacementFilter (sprite, scale) { var maskMatrix = new Matrix(); sprite.renderable = !1, Filter.call(this, 'attribute vec2 aVertexPosition;\n\nuniform mat3 projectionMatrix;\nuniform mat3 filterMatrix;\n\nvarying vec2 vTextureCoord;\nvarying vec2 vFilterCoord;\n\nuniform vec4 inputSize;\nuniform vec4 outputFrame;\n\nvec4 filterVertexPosition( void )\n{\n    vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;\n\n    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\n}\n\nvec2 filterTextureCoord( void )\n{\n    return aVertexPosition * (outputFrame.zw * inputSize.zw);\n}\n\nvoid main(void)\n{\n\tgl_Position = filterVertexPosition();\n\tvTextureCoord = filterTextureCoord();\n\tvFilterCoord = ( filterMatrix * vec3( vTextureCoord, 1.0)  ).xy;\n}\n', 'varying vec2 vFilterCoord;\nvarying vec2 vTextureCoord;\n\nuniform vec2 scale;\nuniform mat2 rotation;\nuniform sampler2D uSampler;\nuniform sampler2D mapSampler;\n\nuniform highp vec4 inputSize;\nuniform vec4 inputClamp;\n\nvoid main(void)\n{\n  vec4 map =  texture2D(mapSampler, vFilterCoord);\n\n  map -= 0.5;\n  map.xy = scale * inputSize.zw * (rotation * map.xy);\n\n  gl_FragColor = texture2D(uSampler, clamp(vec2(vTextureCoord.x + map.x, vTextureCoord.y + map.y), inputClamp.xy, inputClamp.zw));\n}\n', { mapSampler: sprite._texture, filterMatrix: maskMatrix, scale: { x: 1, y: 1 }, rotation: new Float32Array([1, 0, 0, 1]) }), this.maskSprite = sprite, this.maskMatrix = maskMatrix, scale == null && (scale = 20), this.scale = new Point(scale, scale) }Filter && (DisplacementFilter.__proto__ = Filter); var prototypeAccessors = { map: { configurable: !0 } }; return ((DisplacementFilter.prototype = Object.create(Filter && Filter.prototype)).constructor = DisplacementFilter).prototype.apply = function (filterManager, input, output, clear) { this.uniforms.filterMatrix = filterManager.calculateSpriteMatrix(this.maskMatrix, this.maskSprite), this.uniforms.scale.x = this.scale.x, this.uniforms.scale.y = this.scale.y; var wt = this.maskSprite.transform.worldTransform; var lenX = Math.sqrt(wt.a * wt.a + wt.b * wt.b); var lenY = Math.sqrt(wt.c * wt.c + wt.d * wt.d); lenX !== 0 && lenY !== 0 && (this.uniforms.rotation[0] = wt.a / lenX, this.uniforms.rotation[1] = wt.b / lenX, this.uniforms.rotation[2] = wt.c / lenY, this.uniforms.rotation[3] = wt.d / lenY), filterManager.applyFilter(this, input, output, clear) }, prototypeAccessors.map.get = function () { return this.uniforms.mapSampler }, prototypeAccessors.map.set = function (value) { this.uniforms.mapSampler = value }, Object.defineProperties(DisplacementFilter.prototype, prototypeAccessors), DisplacementFilter }(Filter)); var FXAAFilter = (function (Filter) { function FXAAFilter () { Filter.call(this, '\nattribute vec2 aVertexPosition;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 v_rgbNW;\nvarying vec2 v_rgbNE;\nvarying vec2 v_rgbSW;\nvarying vec2 v_rgbSE;\nvarying vec2 v_rgbM;\n\nvarying vec2 vFragCoord;\n\nuniform vec4 inputPixel;\nuniform vec4 outputFrame;\n\nvec4 filterVertexPosition( void )\n{\n    vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;\n\n    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\n}\n\nvoid texcoords(vec2 fragCoord, vec2 inverseVP,\n               out vec2 v_rgbNW, out vec2 v_rgbNE,\n               out vec2 v_rgbSW, out vec2 v_rgbSE,\n               out vec2 v_rgbM) {\n    v_rgbNW = (fragCoord + vec2(-1.0, -1.0)) * inverseVP;\n    v_rgbNE = (fragCoord + vec2(1.0, -1.0)) * inverseVP;\n    v_rgbSW = (fragCoord + vec2(-1.0, 1.0)) * inverseVP;\n    v_rgbSE = (fragCoord + vec2(1.0, 1.0)) * inverseVP;\n    v_rgbM = vec2(fragCoord * inverseVP);\n}\n\nvoid main(void) {\n\n   gl_Position = filterVertexPosition();\n\n   vFragCoord = aVertexPosition * outputFrame.zw;\n\n   texcoords(vFragCoord, inputPixel.zw, v_rgbNW, v_rgbNE, v_rgbSW, v_rgbSE, v_rgbM);\n}\n', 'varying vec2 v_rgbNW;\nvarying vec2 v_rgbNE;\nvarying vec2 v_rgbSW;\nvarying vec2 v_rgbSE;\nvarying vec2 v_rgbM;\n\nvarying vec2 vFragCoord;\nuniform sampler2D uSampler;\nuniform highp vec4 inputPixel;\n\n\n/**\n Basic FXAA implementation based on the code on geeks3d.com with the\n modification that the texture2DLod stuff was removed since it\'s\n unsupported by WebGL.\n\n --\n\n From:\n https://github.com/mitsuhiko/webgl-meincraft\n\n Copyright (c) 2011 by Armin Ronacher.\n\n Some rights reserved.\n\n Redistribution and use in source and binary forms, with or without\n modification, are permitted provided that the following conditions are\n met:\n\n * Redistributions of source code must retain the above copyright\n notice, this list of conditions and the following disclaimer.\n\n * Redistributions in binary form must reproduce the above\n copyright notice, this list of conditions and the following\n disclaimer in the documentation and/or other materials provided\n with the distribution.\n\n * The names of the contributors may not be used to endorse or\n promote products derived from this software without specific\n prior written permission.\n\n THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n#ifndef FXAA_REDUCE_MIN\n#define FXAA_REDUCE_MIN   (1.0/ 128.0)\n#endif\n#ifndef FXAA_REDUCE_MUL\n#define FXAA_REDUCE_MUL   (1.0 / 8.0)\n#endif\n#ifndef FXAA_SPAN_MAX\n#define FXAA_SPAN_MAX     8.0\n#endif\n\n//optimized version for mobile, where dependent\n//texture reads can be a bottleneck\nvec4 fxaa(sampler2D tex, vec2 fragCoord, vec2 inverseVP,\n          vec2 v_rgbNW, vec2 v_rgbNE,\n          vec2 v_rgbSW, vec2 v_rgbSE,\n          vec2 v_rgbM) {\n    vec4 color;\n    vec3 rgbNW = texture2D(tex, v_rgbNW).xyz;\n    vec3 rgbNE = texture2D(tex, v_rgbNE).xyz;\n    vec3 rgbSW = texture2D(tex, v_rgbSW).xyz;\n    vec3 rgbSE = texture2D(tex, v_rgbSE).xyz;\n    vec4 texColor = texture2D(tex, v_rgbM);\n    vec3 rgbM  = texColor.xyz;\n    vec3 luma = vec3(0.299, 0.587, 0.114);\n    float lumaNW = dot(rgbNW, luma);\n    float lumaNE = dot(rgbNE, luma);\n    float lumaSW = dot(rgbSW, luma);\n    float lumaSE = dot(rgbSE, luma);\n    float lumaM  = dot(rgbM,  luma);\n    float lumaMin = min(lumaM, min(min(lumaNW, lumaNE), min(lumaSW, lumaSE)));\n    float lumaMax = max(lumaM, max(max(lumaNW, lumaNE), max(lumaSW, lumaSE)));\n\n    mediump vec2 dir;\n    dir.x = -((lumaNW + lumaNE) - (lumaSW + lumaSE));\n    dir.y =  ((lumaNW + lumaSW) - (lumaNE + lumaSE));\n\n    float dirReduce = max((lumaNW + lumaNE + lumaSW + lumaSE) *\n                          (0.25 * FXAA_REDUCE_MUL), FXAA_REDUCE_MIN);\n\n    float rcpDirMin = 1.0 / (min(abs(dir.x), abs(dir.y)) + dirReduce);\n    dir = min(vec2(FXAA_SPAN_MAX, FXAA_SPAN_MAX),\n              max(vec2(-FXAA_SPAN_MAX, -FXAA_SPAN_MAX),\n                  dir * rcpDirMin)) * inverseVP;\n\n    vec3 rgbA = 0.5 * (\n                       texture2D(tex, fragCoord * inverseVP + dir * (1.0 / 3.0 - 0.5)).xyz +\n                       texture2D(tex, fragCoord * inverseVP + dir * (2.0 / 3.0 - 0.5)).xyz);\n    vec3 rgbB = rgbA * 0.5 + 0.25 * (\n                                     texture2D(tex, fragCoord * inverseVP + dir * -0.5).xyz +\n                                     texture2D(tex, fragCoord * inverseVP + dir * 0.5).xyz);\n\n    float lumaB = dot(rgbB, luma);\n    if ((lumaB < lumaMin) || (lumaB > lumaMax))\n        color = vec4(rgbA, texColor.a);\n    else\n        color = vec4(rgbB, texColor.a);\n    return color;\n}\n\nvoid main() {\n\n      vec4 color;\n\n      color = fxaa(uSampler, vFragCoord, inputPixel.zw, v_rgbNW, v_rgbNE, v_rgbSW, v_rgbSE, v_rgbM);\n\n      gl_FragColor = color;\n}\n') } return Filter && (FXAAFilter.__proto__ = Filter), (FXAAFilter.prototype = Object.create(Filter && Filter.prototype)).constructor = FXAAFilter }(Filter)); var NoiseFilter = (function (Filter) { function NoiseFilter (noise, seed) { void 0 === noise && (noise = 0.5), void 0 === seed && (seed = Math.random()), Filter.call(this, defaultFilter, 'precision highp float;\n\nvarying vec2 vTextureCoord;\nvarying vec4 vColor;\n\nuniform float uNoise;\nuniform float uSeed;\nuniform sampler2D uSampler;\n\nfloat rand(vec2 co)\n{\n    return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvoid main()\n{\n    vec4 color = texture2D(uSampler, vTextureCoord);\n    float randomValue = rand(gl_FragCoord.xy * uSeed);\n    float diff = (randomValue - 0.5) * uNoise;\n\n    // Un-premultiply alpha before applying the color matrix. See issue #3539.\n    if (color.a > 0.0) {\n        color.rgb /= color.a;\n    }\n\n    color.r += diff;\n    color.g += diff;\n    color.b += diff;\n\n    // Premultiply alpha again.\n    color.rgb *= color.a;\n\n    gl_FragColor = color;\n}\n', { uNoise: 0, uSeed: 0 }), this.noise = noise, this.seed = seed }Filter && (NoiseFilter.__proto__ = Filter), (NoiseFilter.prototype = Object.create(Filter && Filter.prototype)).constructor = NoiseFilter; var prototypeAccessors = { noise: { configurable: !0 }, seed: { configurable: !0 } }; return prototypeAccessors.noise.get = function () { return this.uniforms.uNoise }, prototypeAccessors.noise.set = function (value) { this.uniforms.uNoise = value }, prototypeAccessors.seed.get = function () { return this.uniforms.uSeed }, prototypeAccessors.seed.set = function (value) { this.uniforms.uSeed = value }, Object.defineProperties(NoiseFilter.prototype, prototypeAccessors), NoiseFilter }(Filter)); var _tempMatrix = new Matrix(); DisplayObject.prototype._cacheAsBitmap = !1, DisplayObject.prototype._cacheData = !1; var CacheData = function () { this.textureCacheId = null, this.originalRender = null, this.originalRenderCanvas = null, this.originalCalculateBounds = null, this.originalGetLocalBounds = null, this.originalUpdateTransform = null, this.originalHitTest = null, this.originalDestroy = null, this.originalMask = null, this.originalFilterArea = null, this.sprite = null }; Object.defineProperties(DisplayObject.prototype, { cacheAsBitmap: { get: function () { return this._cacheAsBitmap }, set: function (value) { var data; this._cacheAsBitmap !== value && ((this._cacheAsBitmap = value) ? (this._cacheData || (this._cacheData = new CacheData()), (data = this._cacheData).originalRender = this.render, data.originalRenderCanvas = this.renderCanvas, data.originalUpdateTransform = this.updateTransform, data.originalCalculateBounds = this.calculateBounds, data.originalGetLocalBounds = this.getLocalBounds, data.originalDestroy = this.destroy, data.originalContainsPoint = this.containsPoint, data.originalMask = this._mask, data.originalFilterArea = this.filterArea, this.render = this._renderCached, this.renderCanvas = this._renderCachedCanvas, this.destroy = this._cacheAsBitmapDestroy) : ((data = this._cacheData).sprite && this._destroyCachedDisplayObject(), this.render = data.originalRender, this.renderCanvas = data.originalRenderCanvas, this.calculateBounds = data.originalCalculateBounds, this.getLocalBounds = data.originalGetLocalBounds, this.destroy = data.originalDestroy, this.updateTransform = data.originalUpdateTransform, this.containsPoint = data.originalContainsPoint, this._mask = data.originalMask, this.filterArea = data.originalFilterArea)) } } }), DisplayObject.prototype._renderCached = function (renderer) { !this.visible || this.worldAlpha <= 0 || !this.renderable || (this._initCachedDisplayObject(renderer), this._cacheData.sprite.transform._worldID = this.transform._worldID, this._cacheData.sprite.worldAlpha = this.worldAlpha, this._cacheData.sprite._render(renderer)) }, DisplayObject.prototype._initCachedDisplayObject = function (renderer) { if (!this._cacheData || !this._cacheData.sprite) { var cacheAlpha = this.alpha; this.alpha = 1, renderer.batch.flush(); var bounds = this.getLocalBounds().clone(); if (this.filters) { var padding = this.filters[0].padding; bounds.pad(padding) }bounds.ceil(settings.RESOLUTION); var cachedRenderTarget = renderer._activeRenderTarget; var renderTexture = RenderTexture.create(bounds.width, bounds.height); var textureCacheId = 'cacheAsBitmap_' + uid(); this._cacheData.textureCacheId = textureCacheId, BaseTexture.addToCache(renderTexture.baseTexture, textureCacheId), Texture.addToCache(renderTexture, textureCacheId); var m = _tempMatrix; m.tx = -bounds.x, m.ty = -bounds.y, this.transform.worldTransform.identity(), this.render = this._cacheData.originalRender, renderer.render(this, renderTexture, !0, m, !0), renderer.renderTexture.bind(cachedRenderTarget), this.render = this._renderCached, this.updateTransform = this.displayObjectUpdateTransform, this.calculateBounds = this._calculateCachedBounds, this.getLocalBounds = this._getCachedLocalBounds, this._mask = null, this.filterArea = null; var cachedSprite = new Sprite(renderTexture); cachedSprite.transform.worldTransform = this.transform.worldTransform, cachedSprite.anchor.x = -bounds.x / bounds.width, cachedSprite.anchor.y = -bounds.y / bounds.height, cachedSprite.alpha = cacheAlpha, cachedSprite._bounds = this._bounds, this._cacheData.sprite = cachedSprite, this.transform._parentID = -1, this.parent ? this.updateTransform() : (this.parent = renderer._tempDisplayObjectParent, this.updateTransform(), this.parent = null), this.containsPoint = cachedSprite.containsPoint.bind(cachedSprite) } }, DisplayObject.prototype._renderCachedCanvas = function (renderer) { !this.visible || this.worldAlpha <= 0 || !this.renderable || (this._initCachedDisplayObjectCanvas(renderer), this._cacheData.sprite.worldAlpha = this.worldAlpha, this._cacheData.sprite._renderCanvas(renderer)) }, DisplayObject.prototype._initCachedDisplayObjectCanvas = function (renderer) { if (!this._cacheData || !this._cacheData.sprite) { var bounds = this.getLocalBounds(); var cacheAlpha = this.alpha; this.alpha = 1; var cachedRenderTarget = renderer.context; bounds.ceil(settings.RESOLUTION); var renderTexture = RenderTexture.create(bounds.width, bounds.height); var textureCacheId = 'cacheAsBitmap_' + uid(); this._cacheData.textureCacheId = textureCacheId, BaseTexture.addToCache(renderTexture.baseTexture, textureCacheId), Texture.addToCache(renderTexture, textureCacheId); var m = _tempMatrix; this.transform.localTransform.copyTo(m), m.invert(), m.tx -= bounds.x, m.ty -= bounds.y, this.renderCanvas = this._cacheData.originalRenderCanvas, renderer.render(this, renderTexture, !0, m, !1), renderer.context = cachedRenderTarget, this.renderCanvas = this._renderCachedCanvas, this.updateTransform = this.displayObjectUpdateTransform, this.calculateBounds = this._calculateCachedBounds, this.getLocalBounds = this._getCachedLocalBounds, this._mask = null, this.filterArea = null; var cachedSprite = new Sprite(renderTexture); cachedSprite.transform.worldTransform = this.transform.worldTransform, cachedSprite.anchor.x = -bounds.x / bounds.width, cachedSprite.anchor.y = -bounds.y / bounds.height, cachedSprite.alpha = cacheAlpha, cachedSprite._bounds = this._bounds, this._cacheData.sprite = cachedSprite, this.transform._parentID = -1, this.parent ? this.updateTransform() : (this.parent = renderer._tempDisplayObjectParent, this.updateTransform(), this.parent = null), this.containsPoint = cachedSprite.containsPoint.bind(cachedSprite) } }, DisplayObject.prototype._calculateCachedBounds = function () { this._bounds.clear(), this._cacheData.sprite.transform._worldID = this.transform._worldID, this._cacheData.sprite._calculateBounds(), this._lastBoundsID = this._boundsID }, DisplayObject.prototype._getCachedLocalBounds = function () { return this._cacheData.sprite.getLocalBounds() }, DisplayObject.prototype._destroyCachedDisplayObject = function () { this._cacheData.sprite._texture.destroy(!0), this._cacheData.sprite = null, BaseTexture.removeFromCache(this._cacheData.textureCacheId), Texture.removeFromCache(this._cacheData.textureCacheId), this._cacheData.textureCacheId = null }, DisplayObject.prototype._cacheAsBitmapDestroy = function (options) { this.cacheAsBitmap = !1, this.destroy(options) }, DisplayObject.prototype.name = null, Container.prototype.getChildByName = function (name) { for (var i = 0; i < this.children.length; i++) if (this.children[i].name === name) return this.children[i]; return null }, DisplayObject.prototype.getGlobalPosition = function (point, skipUpdate) { return void 0 === point && (point = new Point()), void 0 === skipUpdate && (skipUpdate = !1), this.parent ? this.parent.toGlobal(this.position, point, skipUpdate) : (point.x = this.position.x, point.y = this.position.y), point }; var v5 = '5.0.0'; var MeshBatchUvs = function (uvBuffer, uvMatrix) { this.uvBuffer = uvBuffer, this.uvMatrix = uvMatrix, this.data = null, this._bufferUpdateId = -1, this._textureUpdateId = -1, this._updateID = 0 }; MeshBatchUvs.prototype.update = function (forceUpdate) { if (forceUpdate || this._bufferUpdateId !== this.uvBuffer._updateID || this._textureUpdateId !== this.uvMatrix._updateID) { this._bufferUpdateId = this.uvBuffer._updateID, this._textureUpdateId = this.uvMatrix._updateID; var data = this.uvBuffer.data; this.data && this.data.length === data.length || (this.data = new Float32Array(data.length)), this.uvMatrix.multiplyUvs(data, this.data), this._updateID++ } }; var tempPoint$2 = new Point(); var tempPolygon = new Polygon(); var Mesh = (function (Container) { function Mesh (geometry, shader, state, drawMode) { void 0 === drawMode && (drawMode = DRAW_MODES.TRIANGLES), Container.call(this), (this.geometry = geometry).refCount++, this.shader = shader, this.state = state || State.for2d(), this.drawMode = drawMode, this.start = 0, this.size = 0, this.uvs = null, this.indices = null, this.vertexData = new Float32Array(1), this.vertexDirty = 0, this._transformID = -1, this.tint = 16777215, this.blendMode = BLEND_MODES.NORMAL, this._roundPixels = settings.ROUND_PIXELS, this.batchUvs = null }Container && (Mesh.__proto__ = Container), (Mesh.prototype = Object.create(Container && Container.prototype)).constructor = Mesh; var prototypeAccessors = { uvBuffer: { configurable: !0 }, verticesBuffer: { configurable: !0 }, material: { configurable: !0 }, blendMode: { configurable: !0 }, roundPixels: { configurable: !0 }, tint: { configurable: !0 }, texture: { configurable: !0 } }; return prototypeAccessors.uvBuffer.get = function () { return this.geometry.buffers[1] }, prototypeAccessors.verticesBuffer.get = function () { return this.geometry.buffers[0] }, prototypeAccessors.material.set = function (value) { this.shader = value }, prototypeAccessors.material.get = function () { return this.shader }, prototypeAccessors.blendMode.set = function (value) { this.state.blendMode = value }, prototypeAccessors.blendMode.get = function () { return this.state.blendMode }, prototypeAccessors.roundPixels.set = function (value) { this._roundPixels !== value && (this._transformID = -1), this._roundPixels = value }, prototypeAccessors.roundPixels.get = function () { return this._roundPixels }, prototypeAccessors.tint.get = function () { return this.shader.tint }, prototypeAccessors.tint.set = function (value) { this.shader.tint = value }, prototypeAccessors.texture.get = function () { return this.shader.texture }, prototypeAccessors.texture.set = function (value) { this.shader.texture = value }, Mesh.prototype._render = function (renderer) { var vertices = this.geometry.buffers[0].data; this.shader.batchable && this.drawMode === DRAW_MODES.TRIANGLES && vertices.length < 2 * Mesh.BATCHABLE_SIZE ? this._renderToBatch(renderer) : this._renderDefault(renderer) }, Mesh.prototype._renderDefault = function (renderer) { var shader = this.shader; shader.alpha = this.worldAlpha, shader.update && shader.update(), renderer.batch.flush(), shader.program.uniformData.translationMatrix && (shader.uniforms.translationMatrix = this.transform.worldTransform.toArray(!0)), renderer.shader.bind(shader), renderer.state.setState(this.state), renderer.geometry.bind(this.geometry, shader), renderer.geometry.draw(this.drawMode, this.size, this.start, this.geometry.instanceCount) }, Mesh.prototype._renderToBatch = function (renderer) { var geometry = this.geometry; this.shader.uvMatrix && (this.shader.uvMatrix.update(), this.calculateUvs()), this.calculateVertices(), this.indices = geometry.indexBuffer.data, this._tintRGB = this.shader._tintRGB, this._texture = this.shader.texture; var pluginName = this.material.pluginName; renderer.batch.setObjectRenderer(renderer.plugins[pluginName]), renderer.plugins[pluginName].render(this) }, Mesh.prototype.calculateVertices = function () { var geometry = this.geometry; var vertices = geometry.buffers[0].data; if (geometry.vertexDirtyId !== this.vertexDirty || this._transformID !== this.transform._worldID) { this._transformID = this.transform._worldID, this.vertexData.length !== vertices.length && (this.vertexData = new Float32Array(vertices.length)); for (var wt = this.transform.worldTransform, a = wt.a, b = wt.b, c = wt.c, d = wt.d, tx = wt.tx, ty = wt.ty, vertexData = this.vertexData, i = 0; i < vertexData.length / 2; i++) { var x = vertices[2 * i]; var y = vertices[2 * i + 1]; vertexData[2 * i] = a * x + c * y + tx, vertexData[2 * i + 1] = b * x + d * y + ty } if (this._roundPixels) for (var i$1 = 0; i$1 < vertexData.length; i$1++)vertexData[i$1] = Math.round(vertexData[i$1]); this.vertexDirty = geometry.vertexDirtyId } }, Mesh.prototype.calculateUvs = function () { var geomUvs = this.geometry.buffers[1]; this.shader.uvMatrix.isSimple ? this.uvs = geomUvs.data : (this.batchUvs || (this.batchUvs = new MeshBatchUvs(geomUvs, this.shader.uvMatrix)), this.batchUvs.update(), this.uvs = this.batchUvs.data) }, Mesh.prototype._calculateBounds = function () { this.calculateVertices(), this._bounds.addVertexData(this.vertexData, 0, this.vertexData.length) }, Mesh.prototype.containsPoint = function (point) { if (!this.getBounds().contains(point.x, point.y)) return !1; this.worldTransform.applyInverse(point, tempPoint$2); for (var vertices = this.geometry.getBuffer('aVertexPosition').data, points = tempPolygon.points, indices = this.geometry.getIndex().data, len = indices.length, step = this.drawMode === 4 ? 3 : 1, i = 0; i + 2 < len; i += step) { var ind0 = 2 * indices[i]; var ind1 = 2 * indices[i + 1]; var ind2 = 2 * indices[i + 2]; if (points[0] = vertices[ind0], points[1] = vertices[1 + ind0], points[2] = vertices[ind1], points[3] = vertices[1 + ind1], points[4] = vertices[ind2], points[5] = vertices[1 + ind2], tempPolygon.contains(tempPoint$2.x, tempPoint$2.y)) return !0 } return !1 }, Mesh.prototype.destroy = function (options) { Container.prototype.destroy.call(this, options), this.geometry.refCount--, this.geometry.refCount === 0 && this.geometry.dispose(), this.geometry = null, this.shader = null, this.state = null, this.uvs = null, this.indices = null, this.vertexData = null }, Object.defineProperties(Mesh.prototype, prototypeAccessors), Mesh }(Container)); Mesh.BATCHABLE_SIZE = 100; var MeshMaterial = (function (Shader) { function MeshMaterial (uSampler, options) { var uniforms = { uSampler: uSampler, alpha: 1, uTextureMatrix: Matrix.IDENTITY, uColor: new Float32Array([1, 1, 1, 1]) }; (options = Object.assign({ tint: 16777215, alpha: 1, pluginName: 'batch' }, options)).uniforms && Object.assign(uniforms, options.uniforms), Shader.call(this, options.program || Program.from('attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\nuniform mat3 translationMatrix;\nuniform mat3 uTextureMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = (uTextureMatrix * vec3(aTextureCoord, 1.0)).xy;\n}\n', 'varying vec2 vTextureCoord;\nuniform vec4 uColor;\n\nuniform sampler2D uSampler;\n\nvoid main(void)\n{\n    gl_FragColor = texture2D(uSampler, vTextureCoord) * uColor;\n}\n'), uniforms), this._colorDirty = !1, this.uvMatrix = new TextureMatrix(uSampler), this.batchable = void 0 === options.program, this.pluginName = options.pluginName, this.tint = options.tint, this.alpha = options.alpha }Shader && (MeshMaterial.__proto__ = Shader), (MeshMaterial.prototype = Object.create(Shader && Shader.prototype)).constructor = MeshMaterial; var prototypeAccessors = { texture: { configurable: !0 }, alpha: { configurable: !0 }, tint: { configurable: !0 } }; return prototypeAccessors.texture.get = function () { return this.uniforms.uSampler }, prototypeAccessors.texture.set = function (value) { this.uniforms.uSampler !== value && (this.uniforms.uSampler = value, this.uvMatrix.texture = value) }, prototypeAccessors.alpha.set = function (value) { value !== this._alpha && (this._alpha = value, this._colorDirty = !0) }, prototypeAccessors.alpha.get = function () { return this._alpha }, prototypeAccessors.tint.set = function (value) { value !== this._tint && (this._tint = value, this._tintRGB = (value >> 16) + (65280 & value) + ((255 & value) << 16), this._colorDirty = !0) }, prototypeAccessors.tint.get = function () { return this._tint }, MeshMaterial.prototype.update = function () { if (this._colorDirty) { this._colorDirty = !1; var baseTexture = this.texture.baseTexture; premultiplyTintToRgba(this._tint, this._alpha, this.uniforms.uColor, baseTexture.premultiplyAlpha) } this.uvMatrix.update() && (this.uniforms.uTextureMatrix = this.uvMatrix.mapCoord) }, Object.defineProperties(MeshMaterial.prototype, prototypeAccessors), MeshMaterial }(Shader)); var MeshGeometry = (function (Geometry) { function MeshGeometry (vertices, uvs, index) { Geometry.call(this); var verticesBuffer = new Buffer(vertices); var uvsBuffer = new Buffer(uvs, !0); var indexBuffer = new Buffer(index, !0, !0); this.addAttribute('aVertexPosition', verticesBuffer, 2, !1, TYPES.FLOAT).addAttribute('aTextureCoord', uvsBuffer, 2, !1, TYPES.FLOAT).addIndex(indexBuffer), this._updateId = -1 }Geometry && (MeshGeometry.__proto__ = Geometry), (MeshGeometry.prototype = Object.create(Geometry && Geometry.prototype)).constructor = MeshGeometry; var prototypeAccessors = { vertexDirtyId: { configurable: !0 } }; return prototypeAccessors.vertexDirtyId.get = function () { return this.buffers[0]._updateID }, Object.defineProperties(MeshGeometry.prototype, prototypeAccessors), MeshGeometry }(Geometry)); var PlaneGeometry = (function (MeshGeometry) { function PlaneGeometry (width, height, segWidth, segHeight) { void 0 === width && (width = 100), void 0 === height && (height = 100), void 0 === segWidth && (segWidth = 10), void 0 === segHeight && (segHeight = 10), MeshGeometry.call(this), this.segWidth = segWidth, this.segHeight = segHeight, this.width = width, this.height = height, this.build() } return MeshGeometry && (PlaneGeometry.__proto__ = MeshGeometry), ((PlaneGeometry.prototype = Object.create(MeshGeometry && MeshGeometry.prototype)).constructor = PlaneGeometry).prototype.build = function () { for (var total = this.segWidth * this.segHeight, verts = [], uvs = [], indices = [], segmentsX = this.segWidth - 1, segmentsY = this.segHeight - 1, sizeX = this.width / segmentsX, sizeY = this.height / segmentsY, i = 0; i < total; i++) { var x = i % this.segWidth; var y = i / this.segWidth | 0; verts.push(x * sizeX, y * sizeY), uvs.push(x / segmentsX, y / segmentsY) } for (var totalSub = segmentsX * segmentsY, i$1 = 0; i$1 < totalSub; i$1++) { var xpos = i$1 % segmentsX; var ypos = i$1 / segmentsX | 0; var value = ypos * this.segWidth + xpos; var value2 = ypos * this.segWidth + xpos + 1; var value3 = (1 + ypos) * this.segWidth + xpos; var value4 = (1 + ypos) * this.segWidth + xpos + 1; indices.push(value, value2, value3, value2, value4, value3) } this.buffers[0].data = new Float32Array(verts), this.buffers[1].data = new Float32Array(uvs), this.indexBuffer.data = new Uint16Array(indices), this.buffers[0].update(), this.buffers[1].update(), this.indexBuffer.update() }, PlaneGeometry }(MeshGeometry)); var RopeGeometry = (function (MeshGeometry) { function RopeGeometry (width, points) { void 0 === width && (width = 200), MeshGeometry.call(this, new Float32Array(4 * points.length), new Float32Array(4 * points.length), new Uint16Array(6 * (points.length - 1))), this.points = points, this.width = width, this.build() } return MeshGeometry && (RopeGeometry.__proto__ = MeshGeometry), ((RopeGeometry.prototype = Object.create(MeshGeometry && MeshGeometry.prototype)).constructor = RopeGeometry).prototype.build = function () { var points = this.points; if (points) { var vertexBuffer = this.getBuffer('aVertexPosition'); var uvBuffer = this.getBuffer('aTextureCoord'); var indexBuffer = this.getIndex(); if (!(points.length < 1)) { vertexBuffer.data.length / 4 !== points.length && (vertexBuffer.data = new Float32Array(4 * points.length), uvBuffer.data = new Float32Array(4 * points.length), indexBuffer.data = new Uint16Array(6 * (points.length - 1))); var uvs = uvBuffer.data; var indices = indexBuffer.data; uvs[0] = 0, uvs[1] = 0, uvs[2] = 0, uvs[3] = 1; for (var total = points.length, i = 0; i < total; i++) { var index = 4 * i; var amount = i / (total - 1); uvs[index] = amount, uvs[1 + index] = 0, uvs[2 + index] = amount, uvs[3 + index] = 1 } for (var indexCount = 0, i$1 = 0; i$1 < total - 1; i$1++) { var index$1 = 2 * i$1; indices[indexCount++] = index$1, indices[indexCount++] = 1 + index$1, indices[indexCount++] = 2 + index$1, indices[indexCount++] = 2 + index$1, indices[indexCount++] = 1 + index$1, indices[indexCount++] = 3 + index$1 }uvBuffer.update(), indexBuffer.update(), this.updateVertices() } } }, RopeGeometry.prototype.updateVertices = function () { var points = this.points; if (!(points.length < 1)) { for (var nextPoint, lastPoint = points[0], perpX = 0, perpY = 0, vertices = this.buffers[0].data, total = points.length, i = 0; i < total; i++) { var point = points[i]; var index = 4 * i; perpY = -((nextPoint = i < points.length - 1 ? points[i + 1] : point).x - lastPoint.x), perpX = nextPoint.y - lastPoint.y; var perpLength = Math.sqrt(perpX * perpX + perpY * perpY); var num = this.width / 2; perpX /= perpLength, perpY /= perpLength, perpX *= num, perpY *= num, vertices[index] = point.x + perpX, vertices[1 + index] = point.y + perpY, vertices[2 + index] = point.x - perpX, vertices[3 + index] = point.y - perpY, lastPoint = point } this.buffers[0].update() } }, RopeGeometry.prototype.update = function () { this.updateVertices() }, RopeGeometry }(MeshGeometry)); var SimpleRope = (function (Mesh) { function SimpleRope (texture, points) { var ropeGeometry = new RopeGeometry(texture.height, points); var meshMaterial = new MeshMaterial(texture); Mesh.call(this, ropeGeometry, meshMaterial), this.autoUpdate = !0 } return Mesh && (SimpleRope.__proto__ = Mesh), ((SimpleRope.prototype = Object.create(Mesh && Mesh.prototype)).constructor = SimpleRope).prototype._render = function (renderer) { !this.autoUpdate && this.geometry.width === this.shader.texture.height || (this.geometry.width = this.shader.texture.height, this.geometry.update()), Mesh.prototype._render.call(this, renderer) }, SimpleRope }(Mesh)); var SimplePlane = (function (Mesh) { function SimplePlane (texture, verticesX, verticesY) { var planeGeometry = new PlaneGeometry(texture.width, texture.height, verticesX, verticesY); var meshMaterial = new MeshMaterial(Texture.WHITE); Mesh.call(this, planeGeometry, meshMaterial), this.texture = texture }Mesh && (SimplePlane.__proto__ = Mesh); var prototypeAccessors = { texture: { configurable: !0 } }; return ((SimplePlane.prototype = Object.create(Mesh && Mesh.prototype)).constructor = SimplePlane).prototype.textureUpdated = function () { this._textureID = this.shader.texture._updateID, this.geometry.width = this.shader.texture.width, this.geometry.height = this.shader.texture.height, this.geometry.build() }, prototypeAccessors.texture.set = function (value) { this.shader.texture !== value && (this.shader.texture = value, this._textureID = -1, value.baseTexture.valid ? this.textureUpdated() : value.once('update', this.textureUpdated, this)) }, prototypeAccessors.texture.get = function () { return this.shader.texture }, SimplePlane.prototype._render = function (renderer) { this._textureID !== this.shader.texture._updateID && this.textureUpdated(), Mesh.prototype._render.call(this, renderer) }, Object.defineProperties(SimplePlane.prototype, prototypeAccessors), SimplePlane }(Mesh)); var SimpleMesh = (function (Mesh) { function SimpleMesh (texture, vertices, uvs, indices, drawMode) { void 0 === texture && (texture = Texture.EMPTY); var geometry = new MeshGeometry(vertices, uvs, indices); geometry.getBuffer('aVertexPosition').static = !1; var meshMaterial = new MeshMaterial(texture); Mesh.call(this, geometry, meshMaterial, null, drawMode), this.autoUpdate = !0 }Mesh && (SimpleMesh.__proto__ = Mesh), (SimpleMesh.prototype = Object.create(Mesh && Mesh.prototype)).constructor = SimpleMesh; var prototypeAccessors = { vertices: { configurable: !0 } }; return prototypeAccessors.vertices.get = function () { return this.geometry.getBuffer('aVertexPosition').data }, prototypeAccessors.vertices.set = function (value) { this.geometry.getBuffer('aVertexPosition').data = value }, SimpleMesh.prototype._render = function (renderer) { this.autoUpdate && this.geometry.getBuffer('aVertexPosition').update(), Mesh.prototype._render.call(this, renderer) }, Object.defineProperties(SimpleMesh.prototype, prototypeAccessors), SimpleMesh }(Mesh)); var NineSlicePlane = (function (SimplePlane) { function NineSlicePlane (texture, leftWidth, topHeight, rightWidth, bottomHeight) { SimplePlane.call(this, Texture.WHITE, 4, 4), this._origWidth = texture.orig.width, this._origHeight = texture.orig.height, this._width = this._origWidth, this._height = this._origHeight, this._leftWidth = void 0 !== leftWidth ? leftWidth : 10, this._rightWidth = void 0 !== rightWidth ? rightWidth : 10, this._topHeight = void 0 !== topHeight ? topHeight : 10, this._bottomHeight = void 0 !== bottomHeight ? bottomHeight : 10, this.texture = texture }SimplePlane && (NineSlicePlane.__proto__ = SimplePlane); var prototypeAccessors = { vertices: { configurable: !0 }, width: { configurable: !0 }, height: { configurable: !0 }, leftWidth: { configurable: !0 }, rightWidth: { configurable: !0 }, topHeight: { configurable: !0 }, bottomHeight: { configurable: !0 } }; return ((NineSlicePlane.prototype = Object.create(SimplePlane && SimplePlane.prototype)).constructor = NineSlicePlane).prototype.textureUpdated = function () { this._textureID = this.shader.texture._updateID, this._refresh() }, prototypeAccessors.vertices.get = function () { return this.geometry.getBuffer('aVertexPosition').data }, prototypeAccessors.vertices.set = function (value) { this.geometry.getBuffer('aVertexPosition').data = value }, NineSlicePlane.prototype.updateHorizontalVertices = function () { var vertices = this.vertices; var h = this._topHeight + this._bottomHeight; var scale = this._height > h ? 1 : this._height / h; vertices[9] = vertices[11] = vertices[13] = vertices[15] = this._topHeight * scale, vertices[17] = vertices[19] = vertices[21] = vertices[23] = this._height - this._bottomHeight * scale, vertices[25] = vertices[27] = vertices[29] = vertices[31] = this._height }, NineSlicePlane.prototype.updateVerticalVertices = function () { var vertices = this.vertices; var w = this._leftWidth + this._rightWidth; var scale = this._width > w ? 1 : this._width / w; vertices[2] = vertices[10] = vertices[18] = vertices[26] = this._leftWidth * scale, vertices[4] = vertices[12] = vertices[20] = vertices[28] = this._width - this._rightWidth * scale, vertices[6] = vertices[14] = vertices[22] = vertices[30] = this._width }, prototypeAccessors.width.get = function () { return this._width }, prototypeAccessors.width.set = function (value) { this._width = value, this._refresh() }, prototypeAccessors.height.get = function () { return this._height }, prototypeAccessors.height.set = function (value) { this._height = value, this._refresh() }, prototypeAccessors.leftWidth.get = function () { return this._leftWidth }, prototypeAccessors.leftWidth.set = function (value) { this._leftWidth = value, this._refresh() }, prototypeAccessors.rightWidth.get = function () { return this._rightWidth }, prototypeAccessors.rightWidth.set = function (value) { this._rightWidth = value, this._refresh() }, prototypeAccessors.topHeight.get = function () { return this._topHeight }, prototypeAccessors.topHeight.set = function (value) { this._topHeight = value, this._refresh() }, prototypeAccessors.bottomHeight.get = function () { return this._bottomHeight }, prototypeAccessors.bottomHeight.set = function (value) { this._bottomHeight = value, this._refresh() }, NineSlicePlane.prototype._refresh = function () { var texture = this.texture; var uvs = this.geometry.buffers[1].data; this._origWidth = texture.orig.width, this._origHeight = texture.orig.height; var _uvw = 1 / this._origWidth; var _uvh = 1 / this._origHeight; uvs[0] = uvs[8] = uvs[16] = uvs[24] = 0, uvs[1] = uvs[3] = uvs[5] = uvs[7] = 0, uvs[6] = uvs[14] = uvs[22] = uvs[30] = 1, uvs[25] = uvs[27] = uvs[29] = uvs[31] = 1, uvs[2] = uvs[10] = uvs[18] = uvs[26] = _uvw * this._leftWidth, uvs[4] = uvs[12] = uvs[20] = uvs[28] = 1 - _uvw * this._rightWidth, uvs[9] = uvs[11] = uvs[13] = uvs[15] = _uvh * this._topHeight, uvs[17] = uvs[19] = uvs[21] = uvs[23] = 1 - _uvh * this._bottomHeight, this.updateHorizontalVertices(), this.updateVerticalVertices(), this.geometry.buffers[0].update(), this.geometry.buffers[1].update() }, Object.defineProperties(NineSlicePlane.prototype, prototypeAccessors), NineSlicePlane }(SimplePlane)); var AnimatedSprite = (function (Sprite) { function AnimatedSprite (textures, autoUpdate) { Sprite.call(this, textures[0] instanceof Texture ? textures[0] : textures[0].texture), this._textures = null, this._durations = null, this.textures = textures, this._autoUpdate = !1 !== autoUpdate, this.animationSpeed = 1, this.loop = !0, this.updateAnchor = !1, this.onComplete = null, this.onFrameChange = null, this.onLoop = null, this._currentTime = 0, this.playing = !1 }Sprite && (AnimatedSprite.__proto__ = Sprite); var prototypeAccessors = { totalFrames: { configurable: !0 }, textures: { configurable: !0 }, currentFrame: { configurable: !0 } }; return ((AnimatedSprite.prototype = Object.create(Sprite && Sprite.prototype)).constructor = AnimatedSprite).prototype.stop = function () { this.playing && (this.playing = !1, this._autoUpdate && Ticker.shared.remove(this.update, this)) }, AnimatedSprite.prototype.play = function () { this.playing || (this.playing = !0, this._autoUpdate && Ticker.shared.add(this.update, this, UPDATE_PRIORITY.HIGH)) }, AnimatedSprite.prototype.gotoAndStop = function (frameNumber) { this.stop(); var previousFrame = this.currentFrame; this._currentTime = frameNumber, previousFrame !== this.currentFrame && this.updateTexture() }, AnimatedSprite.prototype.gotoAndPlay = function (frameNumber) { var previousFrame = this.currentFrame; this._currentTime = frameNumber, previousFrame !== this.currentFrame && this.updateTexture(), this.play() }, AnimatedSprite.prototype.update = function (deltaTime) { var elapsed = this.animationSpeed * deltaTime; var previousFrame = this.currentFrame; if (this._durations !== null) { var lag = this._currentTime % 1 * this._durations[this.currentFrame]; for (lag += elapsed / 60 * 1e3; lag < 0;) this._currentTime--, lag += this._durations[this.currentFrame]; var sign = Math.sign(this.animationSpeed * deltaTime); for (this._currentTime = Math.floor(this._currentTime); lag >= this._durations[this.currentFrame];)lag -= this._durations[this.currentFrame] * sign, this._currentTime += sign; this._currentTime += lag / this._durations[this.currentFrame] } else this._currentTime += elapsed; this._currentTime < 0 && !this.loop ? (this.gotoAndStop(0), this.onComplete && this.onComplete()) : this._currentTime >= this._textures.length && !this.loop ? (this.gotoAndStop(this._textures.length - 1), this.onComplete && this.onComplete()) : previousFrame !== this.currentFrame && (this.loop && this.onLoop && (this.animationSpeed > 0 && this.currentFrame < previousFrame ? this.onLoop() : this.animationSpeed < 0 && this.currentFrame > previousFrame && this.onLoop()), this.updateTexture()) }, AnimatedSprite.prototype.updateTexture = function () { this._texture = this._textures[this.currentFrame], this._textureID = -1, this._textureTrimmedID = -1, this._cachedTint = 16777215, this.uvs = this._texture._uvs.uvsFloat32, this.updateAnchor && this._anchor.copy(this._texture.defaultAnchor), this.onFrameChange && this.onFrameChange(this.currentFrame) }, AnimatedSprite.prototype.destroy = function (options) { this.stop(), Sprite.prototype.destroy.call(this, options), this.onComplete = null, this.onFrameChange = null, this.onLoop = null }, AnimatedSprite.fromFrames = function (frames) { for (var textures = [], i = 0; i < frames.length; ++i)textures.push(Texture.from(frames[i])); return new AnimatedSprite(textures) }, AnimatedSprite.fromImages = function (images) { for (var textures = [], i = 0; i < images.length; ++i)textures.push(Texture.from(images[i])); return new AnimatedSprite(textures) }, prototypeAccessors.totalFrames.get = function () { return this._textures.length }, prototypeAccessors.textures.get = function () { return this._textures }, prototypeAccessors.textures.set = function (value) { if (value[0] instanceof Texture) this._textures = value, this._durations = null; else { this._textures = [], this._durations = []; for (var i = 0; i < value.length; i++) this._textures.push(value[i].texture), this._durations.push(value[i].time) } this.gotoAndStop(0), this.updateTexture() }, prototypeAccessors.currentFrame.get = function () { var currentFrame = Math.floor(this._currentTime) % this._textures.length; return currentFrame < 0 && (currentFrame += this._textures.length), currentFrame }, Object.defineProperties(AnimatedSprite.prototype, prototypeAccessors), AnimatedSprite }(Sprite)); Renderer.registerPlugin('accessibility', AccessibilityManager), Renderer.registerPlugin('extract', Extract), Renderer.registerPlugin('interaction', InteractionManager), Renderer.registerPlugin('particle', ParticleRenderer), Renderer.registerPlugin('prepare', Prepare), Renderer.registerPlugin('batch', BatchRenderer), Renderer.registerPlugin('tilingSprite', TilingSpriteRenderer), Loader$2.registerPlugin(BitmapFontLoader), Loader$2.registerPlugin(SpritesheetLoader), Application.registerPlugin(TickerPlugin), Application.registerPlugin(AppLoaderPlugin); var filters = { AlphaFilter: AlphaFilter, BlurFilter: BlurFilter, BlurFilterPass: BlurFilterPass, ColorMatrixFilter: ColorMatrixFilter, DisplacementFilter: DisplacementFilter, FXAAFilter: FXAAFilter, NoiseFilter: NoiseFilter }; return exports.AbstractRenderer = AbstractRenderer, exports.AnimatedSprite = AnimatedSprite, exports.AppLoaderPlugin = AppLoaderPlugin, exports.Application = Application, exports.Attribute = Attribute, exports.BLEND_MODES = BLEND_MODES, exports.BaseRenderTexture = BaseRenderTexture, exports.BaseTexture = BaseTexture, exports.BatchDrawCall = BatchDrawCall, exports.BatchGeometry = BatchGeometry, exports.BatchRenderer = BatchRenderer, exports.BitmapFontLoader = BitmapFontLoader, exports.BitmapText = BitmapText, exports.Bounds = Bounds, exports.Buffer = Buffer, exports.Circle = Circle, exports.Container = Container, exports.CubeTexture = CubeTexture, exports.DEG_TO_RAD = DEG_TO_RAD, exports.DRAW_MODES = DRAW_MODES, exports.DisplayObject = DisplayObject, exports.ENV = ENV, exports.Ellipse = Ellipse, exports.FORMATS = FORMATS, exports.FillStyle = FillStyle, exports.Filter = Filter, exports.Framebuffer = Framebuffer, exports.GC_MODES = GC_MODES, exports.GLProgram = GLProgram, exports.GLTexture = BaseTexture, exports.GRAPHICS_CURVES = GRAPHICS_CURVES, exports.Geometry = Geometry, exports.Graphics = Graphics, exports.GraphicsData = GraphicsData, exports.GraphicsGeometry = GraphicsGeometry, exports.GroupD8 = GroupD8, exports.LineStyle = LineStyle, exports.Loader = Loader$2, exports.LoaderResource = LoaderResource, exports.MIPMAP_MODES = MIPMAP_MODES, exports.Matrix = Matrix, exports.Mesh = Mesh, exports.MeshBatchUvs = MeshBatchUvs, exports.MeshGeometry = MeshGeometry, exports.MeshMaterial = MeshMaterial, exports.NineSlicePlane = NineSlicePlane, exports.ObjectRenderer = ObjectRenderer, exports.ObservablePoint = ObservablePoint, exports.PI_2 = PI_2, exports.PRECISION = PRECISION, exports.ParticleContainer = ParticleContainer, exports.ParticleRenderer = ParticleRenderer, exports.PlaneGeometry = PlaneGeometry, exports.Point = Point, exports.Polygon = Polygon, exports.Program = Program, exports.Quad = Quad, exports.QuadUv = QuadUv, exports.RAD_TO_DEG = RAD_TO_DEG, exports.RENDERER_TYPE = RENDERER_TYPE, exports.Rectangle = Rectangle, exports.RenderTexture = RenderTexture, exports.Renderer = Renderer, exports.RopeGeometry = RopeGeometry, exports.RoundedRectangle = RoundedRectangle, exports.Runner = Runner, exports.SCALE_MODES = SCALE_MODES, exports.SHAPES = SHAPES, exports.Shader = Shader, exports.SimpleMesh = SimpleMesh, exports.SimplePlane = SimplePlane, exports.SimpleRope = SimpleRope, exports.Sprite = Sprite, exports.SpriteMaskFilter = SpriteMaskFilter, exports.Spritesheet = Spritesheet, exports.SpritesheetLoader = SpritesheetLoader, exports.State = State, exports.System = System, exports.TARGETS = TARGETS, exports.TEXT_GRADIENT = TEXT_GRADIENT, exports.TYPES = TYPES, exports.Text = Text, exports.TextMetrics = TextMetrics, exports.TextStyle = TextStyle, exports.Texture = Texture, exports.TextureLoader = TextureLoader, exports.TextureMatrix = TextureMatrix, exports.TextureUvs = TextureUvs, exports.Ticker = Ticker, exports.TickerPlugin = TickerPlugin, exports.TilingSprite = TilingSprite, exports.TilingSpriteRenderer = TilingSpriteRenderer, exports.Transform = Transform, exports.UPDATE_PRIORITY = UPDATE_PRIORITY, exports.UniformGroup = UniformGroup, exports.VERSION = '5.0.4', exports.WRAP_MODES = WRAP_MODES, exports.accessibility = accessibility_es, exports.autoDetectRenderer = autoDetectRenderer, exports.checkMaxIfStatementsInShader = checkMaxIfStatementsInShader, exports.defaultFilterVertex = defaultFilter, exports.defaultVertex = _default, exports.extract = extract_es, exports.filters = filters, exports.generateMultiTextureShader = generateMultiTextureShader, exports.interaction = interaction_es, exports.isMobile = isMobile_min, exports.prepare = prepare_es, exports.resources = index, exports.settings = settings, exports.systems = systems, exports.useDeprecated = function () { var PIXI = this; Object.defineProperties(PIXI, { SVG_SIZE: { get: function () { return deprecation(v5, 'PIXI.utils.SVG_SIZE property has moved to PIXI.resources.SVGResource.SVG_SIZE'), PIXI.SVGResource.SVG_SIZE } }, TransformStatic: { get: function () { return deprecation(v5, 'PIXI.TransformStatic class has been removed, use PIXI.Transform'), PIXI.Transform } }, TransformBase: { get: function () { return deprecation(v5, 'PIXI.TransformBase class has been removed, use PIXI.Transform'), PIXI.Transform } }, TRANSFORM_MODE: { get: function () { return deprecation(v5, 'PIXI.TRANSFORM_MODE property has been removed'), { STATIC: 0, DYNAMIC: 1 } } }, WebGLRenderer: { get: function () { return deprecation(v5, 'PIXI.WebGLRenderer class has moved to PIXI.Renderer'), PIXI.Renderer } }, CanvasRenderTarget: { get: function () { return deprecation(v5, 'PIXI.CanvasRenderTarget class has moved to PIXI.utils.CanvasRenderTarget'), PIXI.utils.CanvasRenderTarget } }, loader: { get: function () { return deprecation(v5, 'PIXI.loader instance has moved to PIXI.Loader.shared'), PIXI.Loader.shared } }, FilterManager: { get: function () { return deprecation(v5, 'PIXI.FilterManager class has moved to PIXI.systems.FilterSystem'), PIXI.systems.FilterSystem } } }), PIXI.extras = {}, Object.defineProperties(PIXI.extras, { TilingSprite: { get: function () { return deprecation(v5, 'PIXI.extras.TilingSprite class has moved to PIXI.TilingSprite'), PIXI.TilingSprite } }, TilingSpriteRenderer: { get: function () { return deprecation(v5, 'PIXI.extras.TilingSpriteRenderer class has moved to PIXI.TilingSpriteRenderer'), PIXI.TilingSpriteRenderer } }, AnimatedSprite: { get: function () { return deprecation(v5, 'PIXI.extras.AnimatedSprite class has moved to PIXI.AnimatedSprite'), PIXI.AnimatedSprite } }, BitmapText: { get: function () { return deprecation(v5, 'PIXI.extras.BitmapText class has moved to PIXI.BitmapText'), PIXI.BitmapText } } }), Object.defineProperties(PIXI.utils, { getSvgSize: { get: function () { return deprecation(v5, 'PIXI.utils.getSvgSize function has moved to PIXI.resources.SVGResource.getSize'), PIXI.SVGResource.getSize } } }), PIXI.mesh = {}, Object.defineProperties(PIXI.mesh, { Mesh: { get: function () { return deprecation(v5, 'PIXI.mesh.Mesh class has moved to PIXI.SimpleMesh'), PIXI.SimpleMesh } }, NineSlicePlane: { get: function () { return deprecation(v5, 'PIXI.mesh.NineSlicePlane class has moved to PIXI.NineSlicePlane'), PIXI.NineSlicePlane } }, Plane: { get: function () { return deprecation(v5, 'PIXI.mesh.Plane class has moved to PIXI.SimplePlane'), PIXI.SimplePlane } }, Rope: { get: function () { return deprecation(v5, 'PIXI.mesh.Rope class has moved to PIXI.SimpleRope'), PIXI.SimpleRope } }, RawMesh: { get: function () { return deprecation(v5, 'PIXI.mesh.RawMesh class has moved to PIXI.Mesh'), PIXI.Mesh } }, CanvasMeshRenderer: { get: function () { return deprecation(v5, 'PIXI.mesh.CanvasMeshRenderer class has moved to PIXI.CanvasMeshRenderer'), PIXI.CanvasMeshRenderer } }, MeshRenderer: { get: function () { return deprecation(v5, 'PIXI.mesh.MeshRenderer class has moved to PIXI.MeshRenderer'), PIXI.MeshRenderer } } }), PIXI.particles = {}, Object.defineProperties(PIXI.particles, { ParticleContainer: { get: function () { return deprecation(v5, 'PIXI.particles.ParticleContainer class has moved to PIXI.ParticleContainer'), PIXI.ParticleContainer } }, ParticleRenderer: { get: function () { return deprecation(v5, 'PIXI.particles.ParticleRenderer class has moved to PIXI.ParticleRenderer'), PIXI.ParticleRenderer } } }), PIXI.ticker = {}, Object.defineProperties(PIXI.ticker, { Ticker: { get: function () { return deprecation(v5, 'PIXI.ticker.Ticker class has moved to PIXI.Ticker'), PIXI.Ticker } }, shared: { get: function () { return deprecation(v5, 'PIXI.ticker.shared instance has moved to PIXI.Ticker.shared'), PIXI.Ticker.shared } } }), PIXI.loaders = {}, Object.defineProperties(PIXI.loaders, { Loader: { get: function () { return deprecation(v5, 'PIXI.loaders.Loader class has moved to PIXI.Loader'), PIXI.Loader } }, Resource: { get: function () { return deprecation(v5, 'PIXI.loaders.Resource class has moved to PIXI.LoaderResource'), PIXI.LoaderResource } }, bitmapFontParser: { get: function () { return deprecation(v5, 'PIXI.loaders.bitmapFontParser function has moved to PIXI.BitmapFontLoader.use'), PIXI.BitmapFontLoader.use } }, parseBitmapFontData: { get: function () { return deprecation(v5, 'PIXI.loaders.parseBitmapFontData function has moved to PIXI.BitmapFontLoader.parse'), PIXI.BitmapFontLoader.parse } }, spritesheetParser: { get: function () { return deprecation(v5, 'PIXI.loaders.spritesheetParser function has moved to PIXI.SpritesheetLoader.use'), PIXI.SpritesheetLoader.use } }, getResourcePath: { get: function () { return deprecation(v5, 'PIXI.loaders.getResourcePath property has moved to PIXI.SpritesheetLoader.getResourcePath'), PIXI.SpritesheetLoader.getResourcePath } } }), PIXI.Loader.addPixiMiddleware = function (middleware) { return deprecation(v5, 'PIXI.loaders.Loader.addPixiMiddleware function is deprecated, use PIXI.loaders.Loader.registerPlugin'), PIXI.loaders.Loader.registerPlugin({ use: middleware() }) }, Object.defineProperty(PIXI.extract, 'WebGLExtract', { get: function () { return deprecation(v5, 'PIXI.extract.WebGLExtract method has moved to PIXI.extract.Extract'), PIXI.extract.Extract } }), Object.defineProperty(PIXI.prepare, 'WebGLPrepare', { get: function () { return deprecation(v5, 'PIXI.prepare.WebGLPrepare class has moved to PIXI.prepare.Prepare'), PIXI.prepare.Prepare } }), PIXI.Container.prototype._renderWebGL = function (renderer) { deprecation(v5, 'PIXI.Container._renderWebGL method has moved to PIXI.Container._render'), this._render(renderer) }, PIXI.Container.prototype.renderWebGL = function (renderer) { deprecation(v5, 'PIXI.Container.renderWebGL method has moved to PIXI.Container.render'), this.render(renderer) }, PIXI.DisplayObject.prototype.renderWebGL = function (renderer) { deprecation(v5, 'PIXI.DisplayObject.renderWebGL method has moved to PIXI.DisplayObject.render'), this.render(renderer) }, PIXI.Container.prototype.renderAdvancedWebGL = function (renderer) { deprecation(v5, 'PIXI.Container.renderAdvancedWebGL method has moved to PIXI.Container.renderAdvanced'), this.renderAdvanced(renderer) }, Object.defineProperties(PIXI.settings, { TRANSFORM_MODE: { get: function () { return deprecation(v5, 'PIXI.settings.TRANSFORM_MODE property has been removed'), 0 }, set: function () { deprecation(v5, 'PIXI.settings.TRANSFORM_MODE property has been removed') } } }); var BaseTexture = PIXI.BaseTexture; BaseTexture.prototype.loadSource = function (image) { deprecation(v5, 'PIXI.BaseTexture.loadSource method has been deprecated'); var resource = PIXI.resources.autoDetectResource(image); resource.internal = !0, this.setResource(resource), this.update() }, Object.defineProperties(BaseTexture.prototype, { hasLoaded: { get: function () { return deprecation(v5, 'PIXI.BaseTexture.hasLoaded property has been removed, use PIXI.BaseTexture.valid'), this.valid } }, imageUrl: { get: function () { return deprecation(v5, 'PIXI.BaseTexture.imageUrl property has been removed, use resource.url'), this.resource && this.resource.url } }, source: { get: function () { return deprecation(v5, 'PIXI.BaseTexture.source property has been moved, use `resource.source`'), this.resource && this.resource.source }, set: function (source) { deprecation(v5, 'PIXI.BaseTexture.source property has been moved, use `resource.source` if you want to set HTMLCanvasElement. Otherwise, create new BaseTexture.'), this.resource && (this.resource.source = source) } } }), BaseTexture.fromImage = function (canvas, crossorigin, scaleMode, scale) { deprecation(v5, 'PIXI.BaseTexture.fromImage method has been replaced with PIXI.BaseTexture.from'); var resourceOptions = { scale: scale, crossorigin: crossorigin }; return BaseTexture.from(canvas, { scaleMode: scaleMode, resourceOptions: resourceOptions }) }, BaseTexture.fromCanvas = function (canvas, scaleMode) { return deprecation(v5, 'PIXI.BaseTexture.fromCanvas method has been replaced with PIXI.BaseTexture.from'), BaseTexture.from(canvas, { scaleMode: scaleMode }) }, BaseTexture.fromSVG = function (canvas, crossorigin, scaleMode, scale) { deprecation(v5, 'PIXI.BaseTexture.fromSVG method has been replaced with PIXI.BaseTexture.from'); var resourceOptions = { scale: scale, crossorigin: crossorigin }; return BaseTexture.from(canvas, { scaleMode: scaleMode, resourceOptions: resourceOptions }) }, PIXI.Point.prototype.copy = function (p) { return deprecation(v5, 'PIXI.Point.copy method has been replaced with PIXI.Point.copyFrom'), this.copyFrom(p) }, PIXI.ObservablePoint.prototype.copy = function (p) { return deprecation(v5, 'PIXI.ObservablePoint.copy method has been replaced with PIXI.ObservablePoint.copyFrom'), this.copyFrom(p) }, PIXI.Rectangle.prototype.copy = function (p) { return deprecation(v5, 'PIXI.Rectangle.copy method has been replaced with PIXI.Rectangle.copyFrom'), this.copyFrom(p) }, PIXI.Matrix.prototype.copy = function (p) { return deprecation(v5, 'PIXI.Matrix.copy method has been replaced with PIXI.Matrix.copyTo'), this.copyTo(p) }, Object.assign(PIXI.systems.FilterSystem.prototype, { getRenderTarget: function (clear, resolution) { return deprecation(v5, 'PIXI.FilterManager.getRenderTarget method has been replaced with PIXI.systems.FilterSystem#getFilterTexture'), this.getFilterTexture(resolution) }, returnRenderTarget: function (renderTexture) { deprecation(v5, 'PIXI.FilterManager.returnRenderTarget method has been replaced with PIXI.systems.FilterSystem.returnFilterTexture'), this.returnFilterTexture(renderTexture) }, calculateScreenSpaceMatrix: function (outputMatrix) { deprecation(v5, 'PIXI.systems.FilterSystem.calculateScreenSpaceMatrix method is removed, use `(vTextureCoord * inputSize.xy) + outputFrame.xy` instead'); var mappedMatrix = outputMatrix.identity(); var ref = this.activeState; var sourceFrame = ref.sourceFrame; var destinationFrame = ref.destinationFrame; return mappedMatrix.translate(sourceFrame.x / destinationFrame.width, sourceFrame.y / destinationFrame.height), mappedMatrix.scale(destinationFrame.width, destinationFrame.height), mappedMatrix }, calculateNormalizedScreenSpaceMatrix: function (outputMatrix) { deprecation(v5, 'PIXI.systems.FilterManager.calculateNormalizedScreenSpaceMatrix method is removed, use `((vTextureCoord * inputSize.xy) + outputFrame.xy) / outputFrame.zw` instead.'); var ref = this.activeState; var sourceFrame = ref.sourceFrame; var destinationFrame = ref.destinationFrame; var mappedMatrix = outputMatrix.identity(); mappedMatrix.translate(sourceFrame.x / destinationFrame.width, sourceFrame.y / destinationFrame.height); var translateScaleX = destinationFrame.width / sourceFrame.width; var translateScaleY = destinationFrame.height / sourceFrame.height; return mappedMatrix.scale(translateScaleX, translateScaleY), mappedMatrix } }), Object.defineProperties(PIXI.RenderTexture.prototype, { sourceFrame: { get: function () { return deprecation(v5, 'PIXI.RenderTexture.sourceFrame property has been removed'), this.filterFrame } }, size: { get: function () { return deprecation(v5, 'PIXI.RenderTexture.size property has been removed'), this._frame } } }); var BlurXFilter = (function (superclass) { function BlurXFilter (strength, quality, resolution, kernelSize) { deprecation(v5, 'PIXI.filters.BlurXFilter class is deprecated, use PIXI.filters.BlurFilterPass'), superclass.call(this, !0, strength, quality, resolution, kernelSize) } return superclass && (BlurXFilter.__proto__ = superclass), (BlurXFilter.prototype = Object.create(superclass && superclass.prototype)).constructor = BlurXFilter }(PIXI.filters.BlurFilterPass)); var BlurYFilter = (function (superclass) { function BlurYFilter (strength, quality, resolution, kernelSize) { deprecation(v5, 'PIXI.filters.BlurYFilter class is deprecated, use PIXI.filters.BlurFilterPass'), superclass.call(this, !1, strength, quality, resolution, kernelSize) } return superclass && (BlurYFilter.__proto__ = superclass), (BlurYFilter.prototype = Object.create(superclass && superclass.prototype)).constructor = BlurYFilter }(PIXI.filters.BlurFilterPass)); Object.assign(PIXI.filters, { BlurXFilter: BlurXFilter, BlurYFilter: BlurYFilter }); var Sprite = PIXI.Sprite; var Texture = PIXI.Texture; var Graphics = PIXI.Graphics; function spriteFrom (name, source, crossorigin, scaleMode) { return deprecation(v5, 'PIXI.Sprite.' + name + ' method is deprecated, use PIXI.Sprite.from'), Sprite.from(source, { resourceOptions: { scale: scaleMode, crossorigin: crossorigin } }) } function textureFrom (name, source, crossorigin, scaleMode) { return deprecation(v5, 'PIXI.Texture.' + name + ' method is deprecated, use PIXI.Texture.from'), Texture.from(source, { resourceOptions: { scale: scaleMode, crossorigin: crossorigin } }) }Graphics.prototype.generateCanvasTexture || (Graphics.prototype.generateCanvasTexture = function () { deprecation(v5, 'PIXI.Graphics.generateCanvasTexture method is only available in "pixi.js-legacy"') }), Sprite.fromImage = spriteFrom.bind(null, 'fromImage'), Sprite.fromSVG = spriteFrom.bind(null, 'fromSVG'), Sprite.fromCanvas = spriteFrom.bind(null, 'fromCanvas'), Sprite.fromVideo = spriteFrom.bind(null, 'fromVideo'), Sprite.fromFrame = spriteFrom.bind(null, 'fromFrame'), Texture.fromImage = textureFrom.bind(null, 'fromImage'), Texture.fromSVG = textureFrom.bind(null, 'fromSVG'), Texture.fromCanvas = textureFrom.bind(null, 'fromCanvas'), Texture.fromVideo = textureFrom.bind(null, 'fromVideo'), Texture.fromFrame = textureFrom.bind(null, 'fromFrame'), Object.defineProperty(PIXI.AbstractRenderer.prototype, 'autoResize', { get: function () { return deprecation(v5, 'PIXI.AbstractRenderer.autoResize property is deprecated, use autoDensity'), this.autoDensity }, set: function (value) { deprecation(v5, 'PIXI.AbstractRenderer.autoResize property is deprecated, use autoDensity'), this.autoDensity = value } }), PIXI.utils.mixins = { mixin: function () { deprecation(v5, 'PIXI.utils.mixins.mixin function is no longer available') }, delayMixin: function () { deprecation(v5, 'PIXI.utils.mixins.delayMixin function is no longer available') }, performMixins: function () { deprecation(v5, 'PIXI.utils.mixins.performMixins function is no longer available') } } }, exports.utils = utils_es, exports }({})); PIXI.useDeprecated()
